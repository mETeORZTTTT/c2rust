{
    "zopfli": {
        "description": "",
        "structs": {
            "ZopfliLZ77Store": {
                "signature": "ZopfliLZ77Store",
                "description": "/*\nStores lit/length and dist pairs for LZ77.\nParameter litlens: Contains the literal symbols or length values.\nParameter dists: Contains the distances. A value is 0 to indicate that there is\nno dist and the corresponding litlens value is a literal instead of a length.\nParameter size: The size of both the litlens and dists arrays.\nThe memory can best be managed by using ZopfliInitLZ77Store to initialize it,\nZopfliCleanLZ77Store to destroy it, and ZopfliStoreLitLenDist to append values.\n\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "unsigned short * litlens",
                        "description": ""
                    },
                    {
                        "signature": "unsigned short * dists",
                        "description": "/* Lit or len. */"
                    },
                    {
                        "signature": "size_t size",
                        "description": "/* If 0: indicates literal in corresponding litlens,\n         if > 0: length in corresponding litlens, this is the distance. */"
                    },
                    {
                        "signature": "const unsigned char * data",
                        "description": ""
                    },
                    {
                        "signature": "size_t * pos",
                        "description": "/* original data */"
                    },
                    {
                        "signature": "unsigned short * ll_symbol",
                        "description": "/* position in data where this LZ77 command begins */"
                    },
                    {
                        "signature": "unsigned short * d_symbol",
                        "description": ""
                    },
                    {
                        "signature": "size_t * ll_counts",
                        "description": "/* Cumulative histograms wrapping around per chunk. Each chunk has the amount\n    of distinct symbols as length, so using 1 value per LZ77 symbol, we have a\n    precise histogram at every N symbols, and the rest can be calculated by\n    looping through the actual symbols of this chunk. */"
                    },
                    {
                        "signature": "size_t * d_counts",
                        "description": ""
                    }
                ],
                "full_text": "struct ZopfliLZ77Store {unsigned short *litlens ;/* Lit or len. */ unsigned short *dists ;/* If 0: indicates literal in corresponding litlens,\n         if > 0: length in corresponding litlens, this is the distance. */ size_t size ;const unsigned char *data ;/* original data */ size_t *pos ;/* position in data where this LZ77 command begins */ unsigned short *ll_symbol ;unsigned short *d_symbol ;/* Cumulative histograms wrapping around per chunk. Each chunk has the amount\n    of distinct symbols as length, so using 1 value per LZ77 symbol, we have a\n    precise histogram at every N symbols, and the rest can be calculated by\n    looping through the actual symbols of this chunk. */ size_t *ll_counts ;size_t *d_counts ;}",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct ZopfliLZ77Store {\n    litlens: *mut u16, // Lit or len.\n    dists: *mut u16, // If 0: indicates literal in corresponding litlens,\n                     // if > 0: length in corresponding litlens, this is the distance.\n    size: usize,\n    data: *const u8, // Original data\n    pos: *mut usize, // Position in data where this LZ77 command begins\n    ll_symbol: *mut u16, // Cumulative histograms wrapping around per chunk.\n    d_symbol: *mut u16, // Each chunk has the amount of distinct symbols as length.\n    ll_counts: *mut usize, // Precise histogram at every N symbols.\n    d_counts: *mut usize // The rest can be calculated by looping through the actual symbols of this chunk.\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "SplitCostContext": {
                "signature": "SplitCostContext",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "const ZopfliLZ77Store * lz77",
                        "description": ""
                    },
                    {
                        "signature": "size_t start",
                        "description": ""
                    },
                    {
                        "signature": "size_t end",
                        "description": ""
                    }
                ],
                "full_text": "struct SplitCostContext {const ZopfliLZ77Store *lz77 ;size_t start ;size_t end ;}",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "typedefs"
                    }
                },
                "rust_signature": "#[derive(Debug, Clone)]\npub struct SplitCostContext {\n    pub lz77: *const ZopfliLZ77Store,\n    pub start: usize,\n    pub end: usize,\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "SymbolStats": {
                "signature": "SymbolStats",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "size_t[288] litlens",
                        "description": "/* The literal and length symbols. */"
                    },
                    {
                        "signature": "size_t[32] dists",
                        "description": "/* The 32 unique dist symbols, not the 32768 possible dists. */"
                    },
                    {
                        "signature": "double[288] ll_symbols",
                        "description": "/* Length of each lit/len symbol in bits. */"
                    },
                    {
                        "signature": "double[32] d_symbols",
                        "description": "/* Length of each dist symbol in bits. */"
                    }
                ],
                "full_text": "struct SymbolStats {/* The literal and length symbols. */ size_t litlens [ZOPFLI_NUM_LL ];/* The 32 unique dist symbols, not the 32768 possible dists. */ size_t dists [ZOPFLI_NUM_D ];/* Length of each lit/len symbol in bits. */ double ll_symbols [ZOPFLI_NUM_LL ];/* Length of each dist symbol in bits. */ double d_symbols [ZOPFLI_NUM_D ];}",
                "dependencies": {
                    "zopfli::ZOPFLI_NUM_LL": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::ZOPFLI_NUM_LL",
                        "type": "defines"
                    },
                    "zopfli::ZOPFLI_NUM_D": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::ZOPFLI_NUM_D",
                        "type": "defines"
                    }
                },
                "rust_signature": "pub struct SymbolStats {\n    /// The literal and length symbols.\n    pub litlens: [usize; ZOPFLI_NUM_LL],\n    /// The 32 unique dist symbols, not the 32768 possible dists.\n    pub dists: [usize; ZOPFLI_NUM_D],\n    /// Length of each lit/len symbol in bits.\n    pub ll_symbols: [f64; ZOPFLI_NUM_LL],\n    /// Length of each dist symbol in bits.\n    pub d_symbols: [f64; ZOPFLI_NUM_D],\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "RanState": {
                "signature": "RanState",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "unsigned int m_w",
                        "description": ""
                    },
                    {
                        "signature": "unsigned int m_z",
                        "description": ""
                    }
                ],
                "full_text": "struct RanState {unsigned int m_w ,m_z ;}",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct RanState {\n    m_w: u32,\n    m_z: u32,\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliHash": {
                "signature": "ZopfliHash",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "int * head",
                        "description": ""
                    },
                    {
                        "signature": "unsigned short * prev",
                        "description": "/* Hash value to index of its most recent occurrence. */"
                    },
                    {
                        "signature": "int * hashval",
                        "description": "/* Index to index of prev. occurrence of same hash. */"
                    },
                    {
                        "signature": "int val",
                        "description": "/* Index to hash value at this index. */"
                    },
                    {
                        "signature": "int * head2",
                        "description": "/* Fields with similar purpose as the above hash, but for the second hash with\n    a value that is calculated differently.  */"
                    },
                    {
                        "signature": "unsigned short * prev2",
                        "description": "/* Hash value to index of its most recent occurrence. */"
                    },
                    {
                        "signature": "int * hashval2",
                        "description": "/* Index to index of prev. occurrence of same hash. */"
                    },
                    {
                        "signature": "int val2",
                        "description": "/* Index to hash value at this index. */"
                    },
                    {
                        "signature": "unsigned short * same",
                        "description": "/* Current hash value. */"
                    }
                ],
                "full_text": "struct ZopfliHash {int *head ;/* Hash value to index of its most recent occurrence. */ unsigned short *prev ;/* Index to index of prev. occurrence of same hash. */ int *hashval ;/* Index to hash value at this index. */ int val ;/* Current hash value. */ /* Fields with similar purpose as the above hash, but for the second hash with\n    a value that is calculated differently.  */ int *head2 ;/* Hash value to index of its most recent occurrence. */ unsigned short *prev2 ;/* Index to index of prev. occurrence of same hash. */ int *hashval2 ;/* Index to hash value at this index. */ int val2 ;/* Current hash value. */ unsigned short *same ;/* Amount of repetitions of same byte after this .*/ }",
                "dependencies": {},
                "rust_signature": "/// Represents a hash structure with fields for tracking hash values and occurrences.\n#[repr(C)]\n#[derive(Debug, Clone)]\npub struct ZopfliHash {\n    /// Hash value to index of its most recent occurrence.\n    pub head: *mut i32,\n    /// Index to index of previous occurrence of the same hash.\n    pub prev: *mut u16,\n    /// Index to hash value at this index.\n    pub hashval: *mut i32,\n    /// Current hash value.\n    pub val: i32,\n    /// Hash value to index of its most recent occurrence for the second hash.\n    pub head2: *mut i32,\n    /// Index to index of previous occurrence of the same hash for the second hash.\n    pub prev2: *mut u16,\n    /// Index to hash value at this index for the second hash.\n    pub hashval2: *mut i32,\n    /// Current hash value for the second hash.\n    pub val2: i32,\n    /// Amount of repetitions of the same byte after this.\n    pub same: *mut u16,\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "Node": {
                "signature": "Node",
                "description": "/*\nNodes forming chains. Also used to represent leaves.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "size_t weight",
                        "description": ""
                    },
                    {
                        "signature": "Node * tail",
                        "description": "/* Total weight (symbol count) of this chain. */"
                    },
                    {
                        "signature": "int count",
                        "description": "/* Previous node(s) of this chain, or 0 if none. */"
                    }
                ],
                "full_text": "struct Node {size_t weight ;/* Total weight (symbol count) of this chain. */ Node *tail ;/* Previous node(s) of this chain, or 0 if none. */ int count ;/* Leaf symbol index, or number of leaves before this chain. */ }",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct Node {\n    weight: usize, // Total weight (symbol count) of this chain.\n    tail: Option<Box<Node>>, // Previous node(s) of this chain, or None if none.\n    count: i32 // Leaf symbol index, or number of leaves before this chain.\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "NodePool": {
                "signature": "NodePool",
                "description": "/*\nMemory pool for nodes.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "Node * next",
                        "description": ""
                    }
                ],
                "full_text": "struct NodePool {Node *next ;/* Pointer to a free node in the pool. */ }",
                "dependencies": {
                    "zopfli::Node": {
                        "qualified_name": "zopfli::Node",
                        "type": "typedefs"
                    }
                },
                "rust_signature": "struct NodePool {\n    next: *mut Node, // Pointer to a free node in the pool. May be null.\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliLongestMatchCache": {
                "signature": "ZopfliLongestMatchCache",
                "description": "/*\nCache used by ZopfliFindLongestMatch to remember previously found length/dist\nvalues.\nThis is needed because the squeeze runs will ask these values multiple times for\nthe same position.\nUses large amounts of memory, since it has to remember the distance belonging\nto every possible shorter-than-the-best length (the so called \"sublen\" array).\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "unsigned short * length",
                        "description": ""
                    },
                    {
                        "signature": "unsigned short * dist",
                        "description": ""
                    },
                    {
                        "signature": "unsigned char * sublen",
                        "description": ""
                    }
                ],
                "full_text": "struct ZopfliLongestMatchCache {unsigned short *length ;unsigned short *dist ;unsigned char *sublen ;}",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct ZopfliLongestMatchCache {\n    length: *mut u16, // Represents a raw pointer to unsigned short\n    dist: *mut u16,   // Represents a raw pointer to unsigned short\n    sublen: *mut u8   // Represents a raw pointer to unsigned char\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliOptions": {
                "signature": "ZopfliOptions",
                "description": "/*\nOptions used throughout the program.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "int verbose",
                        "description": "/* Whether to print output */"
                    },
                    {
                        "signature": "int verbose_more",
                        "description": "/* Whether to print more detailed output */"
                    },
                    {
                        "signature": "int numiterations",
                        "description": "/*\n    Maximum amount of times to rerun forward and backward pass to optimize LZ77\n    compression cost. Good values: 10, 15 for small files, 5 for files over\n    several MB in size or it will be too slow.\n    */"
                    },
                    {
                        "signature": "int blocksplitting",
                        "description": "/*\n    If true, splits the data in multiple deflate blocks with optimal choice\n    for the block boundaries. Block splitting gives better compression. Default:\n    true (1).\n    */"
                    },
                    {
                        "signature": "int blocksplittinglast",
                        "description": "/*\n    No longer used, left for compatibility.\n    */"
                    },
                    {
                        "signature": "int blocksplittingmax",
                        "description": "/*\n    Maximum amount of blocks to split into (0 for unlimited, but this can give\n    extreme results that hurt compression on some files). Default value: 15.\n    */"
                    }
                ],
                "full_text": "struct ZopfliOptions {/* Whether to print output */ int verbose ;/* Whether to print more detailed output */ int verbose_more ;/*\n    Maximum amount of times to rerun forward and backward pass to optimize LZ77\n    compression cost. Good values: 10, 15 for small files, 5 for files over\n    several MB in size or it will be too slow.\n    */ int numiterations ;/*\n    If true, splits the data in multiple deflate blocks with optimal choice\n    for the block boundaries. Block splitting gives better compression. Default:\n    true (1).\n    */ int blocksplitting ;/*\n    No longer used, left for compatibility.\n    */ int blocksplittinglast ;/*\n    Maximum amount of blocks to split into (0 for unlimited, but this can give\n    extreme results that hurt compression on some files). Default value: 15.\n    */ int blocksplittingmax ;}",
                "dependencies": {},
                "rust_signature": "/// Options for Zopfli compression\n#[derive(Debug, Clone)]\npub struct ZopfliOptions {\n    /// Whether to print output\n    pub verbose: i32,\n    /// Whether to print more detailed output\n    pub verbose_more: i32,\n    /// Maximum amount of times to rerun forward and backward pass to optimize LZ77 compression cost.\n    /// Good values: 10, 15 for small files, 5 for files over several MB in size or it will be too slow.\n    pub num_iterations: i32,\n    /// If true, splits the data in multiple deflate blocks with optimal choice for the block boundaries.\n    /// Block splitting gives better compression. Default: true (1).\n    pub block_splitting: i32,\n    /// No longer used, left for compatibility.\n    pub block_splitting_last: i32,\n    /// Maximum amount of blocks to split into (0 for unlimited, but this can give extreme results\n    /// that hurt compression on some files). Default value: 15.\n    pub block_splitting_max: i32,\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliBlockState": {
                "signature": "ZopfliBlockState",
                "description": "/*\nSome state information for compressing a block.\nThis is currently a bit under-used (with mainly only the longest match cache),\nbut is kept for easy future expansion.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "const ZopfliOptions * options",
                        "description": ""
                    },
                    {
                        "signature": "ZopfliLongestMatchCache * lmc",
                        "description": "/* Cache for length/distance pairs found so far. */"
                    },
                    {
                        "signature": "size_t blockstart",
                        "description": "/* The start (inclusive) and end (not inclusive) of the current block. */"
                    },
                    {
                        "signature": "size_t blockend",
                        "description": ""
                    }
                ],
                "full_text": "struct ZopfliBlockState {const ZopfliOptions *options ;/* Cache for length/distance pairs found so far. */ ZopfliLongestMatchCache *lmc ;/* The start (inclusive) and end (not inclusive) of the current block. */ size_t blockstart ;size_t blockend ;}",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "typedefs"
                    },
                    "zopfli::ZopfliLongestMatchCache": {
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "typedefs"
                    }
                },
                "rust_signature": "/// Represents the state of a Zopfli block.\n#[derive(Debug, Clone)]\npub struct ZopfliBlockState {\n    /// Options for Zopfli compression (immutable pointer).\n    pub options: *const ZopfliOptions,\n    /// Cache for length/distance pairs found so far (mutable pointer).\n    pub lmc: *mut ZopfliLongestMatchCache,\n    /// The start (inclusive) of the current block.\n    pub blockstart: usize,\n    /// The end (not inclusive) of the current block.\n    pub blockend: usize,\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            }
        },
        "defines": {
            "HASH_MASK": {
                "name": "HASH_MASK",
                "signature": "HASH_MASK",
                "value": "32767",
                "full_text": "#define HASH_MASK 32767",
                "rust_signature": "const HASH_MASK: u32 = 32767;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "HASH_SHIFT": {
                "name": "HASH_SHIFT",
                "signature": "HASH_SHIFT",
                "value": "5",
                "full_text": "#define HASH_SHIFT 5",
                "rust_signature": "const HASH_SHIFT: usize = 5;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "NUM": {
                "name": "NUM",
                "signature": "NUM",
                "value": "9 /* Good value: 9. */",
                "full_text": "#define NUM 9 /* Good value: 9. */",
                "rust_signature": "pub const NUM: i32 = 9; // Good value: 9.",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_SLICE_H_": {
                "name": "ZOPFLI_SLICE_H_",
                "signature": "ZOPFLI_SLICE_H_",
                "value": "",
                "full_text": "#define ZOPFLI_SLICE_H_",
                "rust_signature": "// Rust不需要头文件保护宏，直接忽略",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_NUM_LL": {
                "name": "ZOPFLI_NUM_LL",
                "signature": "ZOPFLI_NUM_LL",
                "value": "288",
                "full_text": "#define ZOPFLI_NUM_LL 288",
                "rust_signature": "const ZOPFLI_NUM_LL: usize = 288;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_NUM_D": {
                "name": "ZOPFLI_NUM_D",
                "signature": "ZOPFLI_NUM_D",
                "value": "32",
                "full_text": "#define ZOPFLI_NUM_D 32",
                "rust_signature": "pub const ZOPFLI_NUM_D: usize = 32;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_CACHE_LENGTH": {
                "name": "ZOPFLI_CACHE_LENGTH",
                "signature": "ZOPFLI_CACHE_LENGTH",
                "value": "8",
                "full_text": "#define ZOPFLI_CACHE_LENGTH 8",
                "rust_signature": "const ZOPFLI_CACHE_LENGTH: usize = 8;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MIN_MATCH": {
                "name": "ZOPFLI_MIN_MATCH",
                "signature": "ZOPFLI_MIN_MATCH",
                "value": "3",
                "full_text": "#define ZOPFLI_MIN_MATCH 3",
                "rust_signature": "pub const ZOPFLI_MIN_MATCH: usize = 3;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MAX_MATCH": {
                "name": "ZOPFLI_MAX_MATCH",
                "signature": "ZOPFLI_MAX_MATCH",
                "value": "258",
                "full_text": "#define ZOPFLI_MAX_MATCH 258",
                "rust_signature": "const ZOPFLI_MAX_MATCH: usize = 258;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MAX_CHAIN_HITS": {
                "name": "ZOPFLI_MAX_CHAIN_HITS",
                "signature": "ZOPFLI_MAX_CHAIN_HITS",
                "value": "8192",
                "full_text": "#define ZOPFLI_MAX_CHAIN_HITS 8192",
                "rust_signature": "pub const ZOPFLI_MAX_CHAIN_HITS: usize = 8192;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_WINDOW_SIZE": {
                "name": "ZOPFLI_WINDOW_SIZE",
                "signature": "ZOPFLI_WINDOW_SIZE",
                "value": "32768",
                "full_text": "#define ZOPFLI_WINDOW_SIZE 32768",
                "rust_signature": "const ZOPFLI_WINDOW_SIZE: usize = 32768;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_WINDOW_MASK": {
                "name": "ZOPFLI_WINDOW_MASK",
                "signature": "ZOPFLI_WINDOW_MASK",
                "value": "(ZOPFLI_WINDOW_SIZE - 1)",
                "full_text": "#define ZOPFLI_WINDOW_MASK (ZOPFLI_WINDOW_SIZE - 1)",
                "rust_signature": "const ZOPFLI_WINDOW_MASK: usize = ZOPFLI_WINDOW_SIZE - 1;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_LARGE_FLOAT": {
                "name": "ZOPFLI_LARGE_FLOAT",
                "signature": "ZOPFLI_LARGE_FLOAT",
                "value": "1e30",
                "full_text": "#define ZOPFLI_LARGE_FLOAT 1e30",
                "rust_signature": "const ZOPFLI_LARGE_FLOAT: f64 = 1e30;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MASTER_BLOCK_SIZE": {
                "name": "ZOPFLI_MASTER_BLOCK_SIZE",
                "signature": "ZOPFLI_MASTER_BLOCK_SIZE",
                "value": "1000000",
                "full_text": "#define ZOPFLI_MASTER_BLOCK_SIZE 1000000",
                "rust_signature": "pub const ZOPFLI_MASTER_BLOCK_SIZE: usize = 1_000_000;",
                "conversion_status": "success",
                "conversion_rounds": 1
            }
        },
        "typedefs": {
            "typedef double FindMinimumFun (size_t i ,void *context )": {
                "name": "FindMinimumFun",
                "signature": "typedef double FindMinimumFun (size_t i ,void *context )",
                "description": "/*\nThe \"f\" for the FindMinimum function below.\ni: the current parameter of f(i)\ncontext: for your implementation\n\nInstance: `SplitCost` using `SplitCostContext` as context\n*/",
                "full_text": "typedef double FindMinimumFun (size_t i ,void *context )",
                "dependencies": {},
                "rust_signature": "type FindMinimumFun = unsafe extern \"C\" fn(i: usize, context: *mut core::ffi::c_void) -> f64;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "typedef double CostModelFun (unsigned litlen ,unsigned dist ,void *context )": {
                "name": "CostModelFun",
                "signature": "typedef double CostModelFun (unsigned litlen ,unsigned dist ,void *context )",
                "description": "/*\nFunction that calculates a cost based on a model for the given LZ77 symbol.\nlitlen: means literal symbol if dist is 0, length otherwise.\n\nInstance: `GetCostFixed` using NULL as context\nInstance: `GetCostStat` using `SymbolStats` as context\n*/",
                "full_text": "typedef double CostModelFun (unsigned litlen ,unsigned dist ,void *context )",
                "dependencies": {},
                "rust_signature": "type CostModelFun = unsafe extern \"C\" fn(litlen: u32, dist: u32, context: *mut core::ffi::c_void) -> f64;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "typedef struct Node Node ": {
                "name": "Node",
                "signature": "typedef struct Node Node ",
                "description": "",
                "full_text": "typedef struct Node Node ",
                "dependencies": {},
                "rust_signature": "struct Node;",
                "conversion_status": "success",
                "conversion_rounds": 1
            }
        },
        "functions": {
            "ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)": {
                "signature": "int ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)",
                "description": "/*\nOutputs minimum-redundancy length-limited code bitlengths for symbols with the\ngiven counts. The bitlengths are limited by maxbits.\n\nThe output is tailored for DEFLATE: symbols that never occur, get a bit length\nof 0, and if only a single symbol occurs at least once, its bitlength will be 1,\nand not 0 as would theoretically be needed for a single symbol.\n\nfrequencies: The amount of occurrences of each symbol.\nn: The amount of symbols.\nmaxbits: Maximum bit length, inclusive.\nbitlengths: Output, the bitlengths for the symbol prefix codes.\nreturn: 0 for OK, non-0 for error.\n*/",
                "dependencies": {
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    },
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::LeafComparator(const void *, const void *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::LeafComparator(const void *, const void *)",
                        "type": "functions"
                    },
                    "zopfli::InitLists(NodePool *, const Node *, int, Node *(*)[2])": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitLists(NodePool *, const Node *, int, Node *(*)[2])",
                        "type": "functions"
                    },
                    "zopfli::BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)",
                        "type": "functions"
                    },
                    "zopfli::BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)",
                        "type": "functions"
                    },
                    "zopfli::ExtractBitLengths(Node *, Node *, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ExtractBitLengths(Node *, Node *, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "int ZopfliLengthLimitedCodeLengths (const size_t *frequencies ,int n ,int maxbits ,unsigned *bitlengths ){NodePool pool ;int i ;int numsymbols =0 ;/* Amount of symbols with frequency > 0. */ int numBoundaryPMRuns ;Node *nodes ;/* Array of lists of chains. Each list requires only two lookahead chains at\n    a time, so each list is a array of two Node*'s. */ Node *(*lists )[2 ];/* One leaf per symbol. Only numsymbols leaves will be used. */ Node *leaves =(Node *)malloc (n *sizeof (*leaves ));/* Initialize all bitlengths at 0. */ for (i =0 ;i <n ;i ++){bitlengths [i ]=0 ;}/* Count used symbols and place them in the leaves. */ for (i =0 ;i <n ;i ++){if (frequencies [i ]){leaves [numsymbols ].weight =frequencies [i ];leaves [numsymbols ].count =i ;/* Index of symbol this leaf represents. */ numsymbols ++;}}/* Check special cases and error conditions. */ if ((1 <<maxbits )<numsymbols ){free (leaves );return 1 ;/* Error, too few maxbits to represent symbols. */ }if (numsymbols ==0 ){free (leaves );return 0 ;/* No symbols at all. OK. */ }if (numsymbols ==1 ){bitlengths [leaves [0 ].count ]=1 ;free (leaves );return 0 ;/* Only one symbol, give it bitlength 1, not 0. OK. */ }if (numsymbols ==2 ){bitlengths [leaves [0 ].count ]++;bitlengths [leaves [1 ].count ]++;free (leaves );return 0 ;}/* Sort the leaves from lightest to heaviest. Add count into the same\n    variable for stable sorting. */ for (i =0 ;i <numsymbols ;i ++){if (leaves [i ].weight >=((size_t )1 <<(sizeof (leaves [0 ].weight )*CHAR_BIT -9 ))){free (leaves );return 1 ;/* Error, we need 9 bits for the count. */ }leaves [i ].weight =(leaves [i ].weight <<9 )|leaves [i ].count ;}qsort (leaves ,numsymbols ,sizeof (Node ),LeafComparator );for (i =0 ;i <numsymbols ;i ++){leaves [i ].weight >>=9 ;}if (numsymbols -1 <maxbits ){maxbits =numsymbols -1 ;}/* Initialize node memory pool. */ nodes =(Node *)malloc (maxbits *2 *numsymbols *sizeof (Node ));pool .next =nodes ;lists =(Node *(*)[2 ])malloc (maxbits *sizeof (*lists ));InitLists (&pool ,leaves ,maxbits ,lists );/* In the last list, 2 * numsymbols - 2 active chains need to be created. Two\n    are already created in the initialization. Each BoundaryPM run creates one. */ numBoundaryPMRuns =2 *numsymbols -4 ;for (i =0 ;i <numBoundaryPMRuns -1 ;i ++){BoundaryPM (lists ,leaves ,numsymbols ,&pool ,maxbits -1 );}BoundaryPMFinal (lists ,leaves ,numsymbols ,&pool ,maxbits -1 );ExtractBitLengths (lists [maxbits -1 ][1 ],leaves ,bitlengths );free (lists );free (leaves );free (nodes );return 0 ;/* OK. */ }",
                "rust_signature": "fn zopfli_length_limited_code_lengths(frequencies: *const usize, n: i32, maxbits: i32, bitlengths: *mut u32) -> i32 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                "signature": "void ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                "description": "/*\nCalculates the bitlengths for the Huffman tree, based on the counts of each\nsymbol.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCalculateBitLengths (const size_t *count ,size_t n ,int maxbits ,unsigned *bitlengths ){int error =ZopfliLengthLimitedCodeLengths (count ,n ,maxbits ,bitlengths );(void )error ;assert (!error );}",
                "rust_signature": "fn zopfli_calculate_bit_lengths(count: *const usize, n: usize, maxbits: i32, bitlengths: *mut u32) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)": {
                "signature": "void ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)",
                "description": "/*\nConverts a series of Huffman tree bitlengths, to the bit values of the symbols.\n*/",
                "dependencies": {},
                "full_text": "void ZopfliLengthsToSymbols (const unsigned *lengths ,size_t n ,unsigned maxbits ,unsigned *symbols ){size_t *bl_count =(size_t *)malloc (sizeof (size_t )*(maxbits +1 ));size_t *next_code =(size_t *)malloc (sizeof (size_t )*(maxbits +1 ));unsigned bits ,i ;unsigned code ;for (i =0 ;i <n ;i ++){symbols [i ]=0 ;}/* 1) Count the number of codes for each code length. Let bl_count[N] be the\n    number of codes of length N, N >= 1. */ for (bits =0 ;bits <=maxbits ;bits ++){bl_count [bits ]=0 ;}for (i =0 ;i <n ;i ++){assert (lengths [i ]<=maxbits );bl_count [lengths [i ]]++;}/* 2) Find the numerical value of the smallest code for each code length. */ code =0 ;bl_count [0 ]=0 ;for (bits =1 ;bits <=maxbits ;bits ++){code =(code +bl_count [bits -1 ])<<1 ;next_code [bits ]=code ;}/* 3) Assign numerical values to all codes, using consecutive values for all\n    codes of the same length with the base values determined at step 2. */ for (i =0 ;i <n ;i ++){unsigned len =lengths [i ];if (len !=0 ){symbols [i ]=next_code [len ];next_code [len ]++;}}free (bl_count );free (next_code );}",
                "rust_signature": "pub fn zopfli_lengths_to_symbols(lengths: &[u32], n: usize, maxbits: u32, symbols: &mut [u32]) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)": {
                "signature": "void ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)",
                "description": "/* Gets the histogram of lit/len and dist symbols in the given range, using the\ncumulative histograms, so faster than adding one by one for large range. Does\nnot add the one end symbol of value 256. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77GetHistogram (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t *ll_counts ,size_t *d_counts ){size_t i ;if (lstart +ZOPFLI_NUM_LL *3 >lend ){memset (ll_counts ,0 ,sizeof (*ll_counts )*ZOPFLI_NUM_LL );memset (d_counts ,0 ,sizeof (*d_counts )*ZOPFLI_NUM_D );for (i =lstart ;i <lend ;i ++){ll_counts [lz77 ->ll_symbol [i ]]++;if (lz77 ->dists [i ]!=0 )d_counts [lz77 ->d_symbol [i ]]++;}}else {/* Subtract the cumulative histograms at the end and the start to get the\n        histogram for this range. */ ZopfliLZ77GetHistogramAt (lz77 ,lend -1 ,ll_counts ,d_counts );if (lstart >0 ){size_t ll_counts2 [ZOPFLI_NUM_LL ];size_t d_counts2 [ZOPFLI_NUM_D ];ZopfliLZ77GetHistogramAt (lz77 ,lstart -1 ,ll_counts2 ,d_counts2 );for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){ll_counts [i ]-=ll_counts2 [i ];}for (i =0 ;i <ZOPFLI_NUM_D ;i ++){d_counts [i ]-=d_counts2 [i ];}}}}",
                "rust_signature": "fn zopfli_lz77_get_histogram(\n    lz77: *const ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    ll_counts: *mut usize,\n    d_counts: *mut usize\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/* Gets the amount of raw bytes that this range of LZ77 symbols spans. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "size_t ZopfliLZ77GetByteRange (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){size_t l =lend -1 ;if (lstart ==lend )return 0 ;return lz77 ->pos [l ]+((lz77 ->dists [l ]==0 )?1 :lz77 ->litlens [l ])-lz77 ->pos [lstart ];}",
                "rust_signature": "fn zopfli_lz77_get_byte_range(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize) -> usize {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                "signature": "double ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                "description": "/*\nCalculates block size in bits.\nlitlens: lz77 lit/lengths\ndists: ll77 distances\nlstart: start of block\nlend: end of block (not inclusive)\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::GetFixedTree(unsigned int *, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::GetFixedTree(unsigned int *, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "double ZopfliCalculateBlockSize (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,int btype ){unsigned ll_lengths [ZOPFLI_NUM_LL ];unsigned d_lengths [ZOPFLI_NUM_D ];double result =3 ;/* bfinal and btype bits */ if (btype ==0 ){size_t length =ZopfliLZ77GetByteRange (lz77 ,lstart ,lend );size_t rem =length %65535 ;size_t blocks =length /65535 +(rem ?1 :0 );/* An uncompressed block must actually be split into multiple blocks if it's\n           larger than 65535 bytes long. Eeach block header is 5 bytes: 3 bits,\n           padding, LEN and NLEN (potential less padding for first one ignored). */ return blocks *5 *8 +length *8 ;}if (btype ==1 ){GetFixedTree (ll_lengths ,d_lengths );result +=CalculateBlockSymbolSize (ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}else {result +=GetDynamicLengths (lz77 ,lstart ,lend ,ll_lengths ,d_lengths );}return result ;}",
                "rust_signature": "fn zopfli_calculate_block_size(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize, btype: i32) -> f64 {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                "signature": "unsigned int ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                "description": "/*\nReturns the length up to which could be stored in the cache.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    }
                },
                "full_text": "unsigned ZopfliMaxCachedSublen (const ZopfliLongestMatchCache *lmc ,size_t pos ,size_t length ){unsigned char *cache ;cache =&lmc ->sublen [ZOPFLI_CACHE_LENGTH *pos *3 ];(void )length ;if (cache [1 ]==0 &&cache [2 ]==0 )return 0 ;/* No sublen cached. */ return cache [(ZOPFLI_CACHE_LENGTH -1 )*3 ]+3 ;}",
                "rust_signature": "fn zopfli_max_cached_sublen(lmc: &ZopfliLongestMatchCache, pos: usize, length: usize) -> u32 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)": {
                "signature": "void ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)",
                "description": "/* Stores sublen array in the cache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    },
                    "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliSublenToCache (const unsigned short *sublen ,size_t pos ,size_t length ,ZopfliLongestMatchCache *lmc ){size_t i ;size_t j =0 ;unsigned bestlength =0 ;unsigned char *cache ;cache =&lmc ->sublen [ZOPFLI_CACHE_LENGTH *pos *3 ];if (length <3 )return ;for (i =3 ;i <=length ;i ++){if (i ==length ||sublen [i ]!=sublen [i +1 ]){cache [j *3 ]=i -3 ;cache [j *3 +1 ]=sublen [i ]%256 ;cache [j *3 +2 ]=(sublen [i ]>>8 )%256 ;bestlength =i ;j ++;if (j >=ZOPFLI_CACHE_LENGTH )break ;}}if (j <ZOPFLI_CACHE_LENGTH ){assert (bestlength ==length );cache [(ZOPFLI_CACHE_LENGTH -1 )*3 ]=bestlength -3 ;}else {assert (bestlength <=length );}assert (bestlength ==ZopfliMaxCachedSublen (lmc ,pos ,length ));}",
                "rust_signature": "fn zopfli_sublen_to_cache(sublen: &[u16], pos: usize, length: usize, lmc: &mut ZopfliLongestMatchCache) {\n    // Function body is unimplemented as per instructions\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)": {
                "signature": "void ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)",
                "description": "/* Extracts sublen array from the cache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    },
                    "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCacheToSublen (const ZopfliLongestMatchCache *lmc ,size_t pos ,size_t length ,unsigned short *sublen ){size_t i ,j ;unsigned maxlength =ZopfliMaxCachedSublen (lmc ,pos ,length );unsigned prevlength =0 ;unsigned char *cache ;if (length <3 )return ;cache =&lmc ->sublen [ZOPFLI_CACHE_LENGTH *pos *3 ];for (j =0 ;j <ZOPFLI_CACHE_LENGTH ;j ++){unsigned length =cache [j *3 ]+3 ;unsigned dist =cache [j *3 +1 ]+256 *cache [j *3 +2 ];for (i =prevlength ;i <=length ;i ++){sublen [i ]=dist ;}if (length ==maxlength )break ;prevlength =length +1 ;}}",
                "rust_signature": "fn zopfli_cache_to_sublen(lmc: &ZopfliLongestMatchCache, pos: usize, length: usize, sublen: &mut [u16]) {\n    // Placeholder implementation\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                "signature": "void ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                "description": "/*\nFinds the longest match (length and corresponding distance) for LZ77\ncompression.\nEven when not using \"sublen\", it can be more efficient to provide an array,\nbecause only then the caching is used.\narray: the data\npos: position in the data to find the match for\nsize: size of the data\nlimit: limit length to maximum this value (default should be 258). This allows\nfinding a shorter dist for that length (= less extra bits). Must be\nin the range [ZOPFLI_MIN_MATCH, ZOPFLI_MAX_MATCH].\nsublen: output array of 259 elements, or null. Has, for each length, the\nsmallest distance required to reach this length. Only 256 of its 259 values\nare used, the first 3 are ignored (the shortest length is 3. It is purely\nfor convenience that the array is made 3 longer).\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)": {
                        "return_type": "const unsigned char *",
                        "qualified_name": "zopfli::GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)",
                        "type": "functions"
                    },
                    "zopfli::StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliFindLongestMatch (ZopfliBlockState *s ,const ZopfliHash *h ,const unsigned char *array ,size_t pos ,size_t size ,size_t limit ,unsigned short *sublen ,unsigned short *distance ,unsigned short *length ){unsigned short hpos =pos &ZOPFLI_WINDOW_MASK ,p ,pp ;unsigned short bestdist =0 ;unsigned short bestlength =1 ;const unsigned char *scan ;const unsigned char *match ;const unsigned char *arrayend ;const unsigned char *arrayend_safe ;int chain_counter =ZOPFLI_MAX_CHAIN_HITS ;/* For quitting early. */ unsigned dist =0 ;/* Not unsigned short on purpose. */ int *hhead =h ->head ;unsigned short *hprev =h ->prev ;int *hhashval =h ->hashval ;int hval =h ->val ;if (TryGetFromLongestMatchCache (s ,pos ,&limit ,sublen ,distance ,length )){assert (pos +*length <=size );return ;}assert (limit <=ZOPFLI_MAX_MATCH );assert (limit >=ZOPFLI_MIN_MATCH );assert (pos <size );if (size -pos <ZOPFLI_MIN_MATCH ){/* The rest of the code assumes there are at least ZOPFLI_MIN_MATCH bytes to\n           try. */ *length =0 ;*distance =0 ;return ;}if (pos +limit >size ){limit =size -pos ;}arrayend =&array [pos ]+limit ;arrayend_safe =arrayend -8 ;assert (hval <65536 );pp =hhead [hval ];/* During the whole loop, p == hprev[pp]. */ p =hprev [pp ];assert (pp ==hpos );dist =p <pp ?pp -p :((ZOPFLI_WINDOW_SIZE -p )+pp );/* Go through all distances. */ while (dist <ZOPFLI_WINDOW_SIZE ){unsigned short currentlength =0 ;assert (p <ZOPFLI_WINDOW_SIZE );assert (p ==hprev [pp ]);assert (hhashval [p ]==hval );if (dist >0 ){assert (pos <size );assert (dist <=pos );scan =&array [pos ];match =&array [pos -dist ];/* Testing the byte at position bestlength first, goes slightly faster. */ if (pos +bestlength >=size ||*(scan +bestlength )==*(match +bestlength )){unsigned short same0 =h ->same [pos &ZOPFLI_WINDOW_MASK ];if (same0 >2 &&*scan ==*match ){unsigned short same1 =h ->same [(pos -dist )&ZOPFLI_WINDOW_MASK ];unsigned short same =same0 <same1 ?same0 :same1 ;if (same >limit )same =limit ;scan +=same ;match +=same ;}scan =GetMatch (scan ,match ,arrayend ,arrayend_safe );currentlength =scan -&array [pos ];/* The found length. */ }if (currentlength >bestlength ){if (sublen ){unsigned short j ;for (j =bestlength +1 ;j <=currentlength ;j ++){sublen [j ]=dist ;}}bestdist =dist ;bestlength =currentlength ;if (currentlength >=limit )break ;}}/* Switch to the other hash once this will be more efficient. */ if (hhead !=h ->head2 &&bestlength >=h ->same [hpos ]&&h ->val2 ==h ->hashval2 [p ]){/* Now use the hash that encodes the length and first byte. */ hhead =h ->head2 ;hprev =h ->prev2 ;hhashval =h ->hashval2 ;hval =h ->val2 ;}pp =p ;p =hprev [p ];if (p ==pp )break ;/* Uninited prev value. */ dist +=p <pp ?pp -p :((ZOPFLI_WINDOW_SIZE -p )+pp );chain_counter --;if (chain_counter <=0 )break ;}StoreInLongestMatchCache (s ,pos ,limit ,sublen ,bestdist ,bestlength );assert (bestlength <=limit );*distance =bestdist ;*length =bestlength ;assert (pos +*length <=size );}",
                "rust_signature": "pub fn zopfli_find_longest_match(\n    s: *mut ZopfliBlockState,\n    h: *const ZopfliHash,\n    array: Option<&[u8]>,\n    pos: usize,\n    size: usize,\n    limit: usize,\n    sublen: Option<&mut [u16]>,\n    distance: &mut u16,\n    length: &mut u16,\n) {\n    // This function involves complex pointer manipulations and low-level operations.\n    // The body of the function is not implemented here.\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)": {
                "signature": "void ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)",
                "description": "/*\nVerifies if length and dist are indeed valid, only used for assertion.\n*/",
                "dependencies": {},
                "full_text": "void ZopfliVerifyLenDist (const unsigned char *data ,size_t datasize ,size_t pos ,unsigned short dist ,unsigned short length ){/* TODO(lode): make this only run in a debug compile, it's for assert only. */ size_t i ;assert (pos +length <=datasize );for (i =0 ;i <length ;i ++){if (data [pos -dist +i ]!=data [pos +i ]){assert (data [pos -dist +i ]==data [pos +i ]);break ;}}}",
                "rust_signature": "pub fn zopfli_verify_len_dist(data: Option<&[u8]>, datasize: usize, pos: usize, dist: u16, length: u16) {\n    // TODO(lode): make this only run in a debug compile, it's for assert only.\n    // Original C code performs assertions and memory access checks.\n    // In Rust, this function is left unimplemented for now.\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                "signature": "void ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                "description": "/*\nPrepopulates hash:\nFills in the initial values in the hash, before ZopfliUpdateHash can be used\ncorrectly.\n*/",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliWarmupHash (const unsigned char *array ,size_t pos ,size_t end ,ZopfliHash *h ){UpdateHashValue (h ,array [pos +0 ]);if (pos +1 <end )UpdateHashValue (h ,array [pos +1 ]);}",
                "rust_signature": "pub fn zopfli_warmup_hash(array: *const u8, pos: usize, end: usize, h: *mut ZopfliHash) {\n    // Placeholder for the function body. Original C code calls UpdateHashValue.\n    // Unsafe is required because raw pointers are used to match the original C semantics.\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                "signature": "void ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                "description": "/*\nAppends the length and distance to the LZ77 arrays of the ZopfliLZ77Store.\ncontext must be a ZopfliLZ77Store*.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliStoreLitLenDist (unsigned short length ,unsigned short dist ,size_t pos ,ZopfliLZ77Store *store ){size_t i ;/* Needed for using ZOPFLI_APPEND_DATA multiple times. */ size_t origsize =store ->size ;size_t llstart =ZOPFLI_NUM_LL *(origsize /ZOPFLI_NUM_LL );size_t dstart =ZOPFLI_NUM_D *(origsize /ZOPFLI_NUM_D );/* Everytime the index wraps around, a new cumulative histogram is made: we're\n    keeping one histogram value per LZ77 symbol rather than a full histogram for\n    each to save memory. */ if (origsize %ZOPFLI_NUM_LL ==0 ){size_t llsize =origsize ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){ZOPFLI_APPEND_DATA (origsize ==0 ?0 :store ->ll_counts [origsize -ZOPFLI_NUM_LL +i ],&store ->ll_counts ,&llsize );}}if (origsize %ZOPFLI_NUM_D ==0 ){size_t dsize =origsize ;for (i =0 ;i <ZOPFLI_NUM_D ;i ++){ZOPFLI_APPEND_DATA (origsize ==0 ?0 :store ->d_counts [origsize -ZOPFLI_NUM_D +i ],&store ->d_counts ,&dsize );}}ZOPFLI_APPEND_DATA (length ,&store ->litlens ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (dist ,&store ->dists ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (pos ,&store ->pos ,&store ->size );assert (length <259 );if (dist ==0 ){store ->size =origsize ;ZOPFLI_APPEND_DATA (length ,&store ->ll_symbol ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (0 ,&store ->d_symbol ,&store ->size );store ->ll_counts [llstart +length ]++;}else {store ->size =origsize ;ZOPFLI_APPEND_DATA (ZopfliGetLengthSymbol (length ),&store ->ll_symbol ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (ZopfliGetDistSymbol (dist ),&store ->d_symbol ,&store ->size );store ->ll_counts [llstart +ZopfliGetLengthSymbol (length )]++;store ->d_counts [dstart +ZopfliGetDistSymbol (dist )]++;}}",
                "rust_signature": "fn zopfli_store_lit_len_dist(length: u16, dist: u16, pos: usize, store: &mut ZopfliLZ77Store) {\n    // Placeholder implementation\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                "signature": "void ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                "description": "/*\nUpdates the hash values based on the current position in the array. All calls\nto this must be made for consecutive bytes.\n*/",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliUpdateHash (const unsigned char *array ,size_t pos ,size_t end ,ZopfliHash *h ){unsigned short hpos =pos &ZOPFLI_WINDOW_MASK ;size_t amount =0 ;UpdateHashValue (h ,pos +ZOPFLI_MIN_MATCH <=end ?array [pos +ZOPFLI_MIN_MATCH -1 ]:0 );h ->hashval [hpos ]=h ->val ;if (h ->head [h ->val ]!=-1 &&h ->hashval [h ->head [h ->val ]]==h ->val ){h ->prev [hpos ]=h ->head [h ->val ];}else h ->prev [hpos ]=hpos ;h ->head [h ->val ]=hpos ;/* Update \"same\". */ if (h ->same [(pos -1 )&ZOPFLI_WINDOW_MASK ]>1 ){amount =h ->same [(pos -1 )&ZOPFLI_WINDOW_MASK ]-1 ;}while (pos +amount +1 <end &&array [pos ]==array [pos +amount +1 ]&&amount <(unsigned short )(-1 )){amount ++;}h ->same [hpos ]=amount ;h ->val2 =((h ->same [hpos ]-ZOPFLI_MIN_MATCH )&255 )^h ->val ;h ->hashval2 [hpos ]=h ->val2 ;if (h ->head2 [h ->val2 ]!=-1 &&h ->hashval2 [h ->head2 [h ->val2 ]]==h ->val2 ){h ->prev2 [hpos ]=h ->head2 [h ->val2 ];}else h ->prev2 [hpos ]=hpos ;h ->head2 [h ->val2 ]=hpos ;}",
                "rust_signature": "pub fn zopfli_update_hash(array: &[u8], pos: usize, end: usize, h: &mut ZopfliHash) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliResetHash(size_t, ZopfliHash *)": {
                "signature": "void ZopfliResetHash(size_t, ZopfliHash *)",
                "description": "/* Resets all fields of ZopfliHash. */",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliResetHash (size_t window_size ,ZopfliHash *h ){size_t i ;h ->val =0 ;for (i =0 ;i <65536 ;i ++){h ->head [i ]=-1 ;/* -1 indicates no head so far. */ }for (i =0 ;i <window_size ;i ++){h ->prev [i ]=i ;/* If prev[j] == j, then prev[j] is uninitialized. */ h ->hashval [i ]=-1 ;}for (i =0 ;i <window_size ;i ++){h ->same [i ]=0 ;}h ->val2 =0 ;for (i =0 ;i <65536 ;i ++){h ->head2 [i ]=-1 ;}for (i =0 ;i <window_size ;i ++){h ->prev2 [i ]=i ;h ->hashval2 [i ]=-1 ;}}",
                "rust_signature": "pub fn zopfli_reset_hash(window_size: usize, h: &mut ZopfliHash) {\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliCleanHash(ZopfliHash *)": {
                "signature": "void ZopfliCleanHash(ZopfliHash *)",
                "description": "/* Frees ZopfliHash memory. */",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliCleanHash (ZopfliHash *h ){free (h ->head );free (h ->prev );free (h ->hashval );free (h ->head2 );free (h ->prev2 );free (h ->hashval2 );free (h ->same );}",
                "rust_signature": "pub fn zopfli_clean_hash(h: &mut ZopfliHash) {\n    todo!(\"Function implementation is not provided. Memory management logic needs to be handled appropriately.\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)": {
                "signature": "void ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)",
                "description": "/*\nDoes the same as ZopfliLZ77Optimal, but optimized for the fixed tree of the\ndeflate standard.\nThe fixed tree never gives the best compression. But this gives the best\npossible LZ77 encoding possible with the fixed tree.\nThis does not create or output any fixed tree, only LZ77 data optimized for\nusing with a fixed tree.\nIf instart is larger than 0, it uses values before instart as starting\ndictionary.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)",
                        "type": "functions"
                    },
                    "zopfli::GetCostFixed(unsigned int, unsigned int, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetCostFixed(unsigned int, unsigned int, void *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanHash(ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanHash(ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77OptimalFixed (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,ZopfliLZ77Store *store ){/* Dist to get to here with smallest cost. */ size_t blocksize =inend -instart ;unsigned short *length_array =(unsigned short *)malloc (sizeof (unsigned short )*(blocksize +1 ));unsigned short *path =0 ;size_t pathsize =0 ;ZopfliHash hash ;ZopfliHash *h =&hash ;float *costs =(float *)malloc (sizeof (float )*(blocksize +1 ));if (!costs )exit (-1 );/* Allocation failed. */ if (!length_array )exit (-1 );/* Allocation failed. */ ZopfliAllocHash (ZOPFLI_WINDOW_SIZE ,h );s ->blockstart =instart ;s ->blockend =inend ;/* Shortest path for fixed tree This one should give the shortest possible\n    result for fixed tree, no repeated runs are needed since the tree is known. */ LZ77OptimalRun (s ,in ,instart ,inend ,&path ,&pathsize ,length_array ,GetCostFixed ,0 ,store ,h ,costs );free (length_array );free (path );free (costs );ZopfliCleanHash (h );}",
                "rust_signature": "pub fn zopfli_lz77_optimal_fixed(\n    s: *mut ZopfliBlockState,\n    in_data: *const u8,\n    instart: usize,\n    inend: usize,\n    store: *mut ZopfliLZ77Store,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliAllocHash(size_t, ZopfliHash *)": {
                "signature": "void ZopfliAllocHash(size_t, ZopfliHash *)",
                "description": "/* Allocates ZopfliHash memory. */",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliAllocHash (size_t window_size ,ZopfliHash *h ){h ->head =(int *)malloc (sizeof (*h ->head )*65536 );h ->prev =(unsigned short *)malloc (sizeof (*h ->prev )*window_size );h ->hashval =(int *)malloc (sizeof (*h ->hashval )*window_size );h ->same =(unsigned short *)malloc (sizeof (*h ->same )*window_size );h ->head2 =(int *)malloc (sizeof (*h ->head2 )*65536 );h ->prev2 =(unsigned short *)malloc (sizeof (*h ->prev2 )*window_size );h ->hashval2 =(int *)malloc (sizeof (*h ->hashval2 )*window_size );}",
                "rust_signature": "pub fn zopfli_alloc_hash(window_size: usize, h: &mut ZopfliHash) {\n    todo!(\"Memory allocation logic is not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCleanBlockState(ZopfliBlockState *)": {
                "signature": "void ZopfliCleanBlockState(ZopfliBlockState *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCleanCache(ZopfliLongestMatchCache *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanCache(ZopfliLongestMatchCache *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCleanBlockState (ZopfliBlockState *s ){if (s ->lmc ){ZopfliCleanCache (s ->lmc );free (s ->lmc );}}",
                "rust_signature": "pub fn zopfli_clean_block_state(s: &mut ZopfliBlockState) {\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCleanCache(ZopfliLongestMatchCache *)": {
                "signature": "void ZopfliCleanCache(ZopfliLongestMatchCache *)",
                "description": "/* Frees up the memory of the ZopfliLongestMatchCache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliCleanCache (ZopfliLongestMatchCache *lmc ){free (lmc ->length );free (lmc ->dist );free (lmc ->sublen );}",
                "rust_signature": "fn zopfli_clean_cache(lmc: *mut ZopfliLongestMatchCache) {\n    // Placeholder implementation\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                "signature": "void ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitCache(size_t, ZopfliLongestMatchCache *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitCache(size_t, ZopfliLongestMatchCache *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliInitBlockState (const ZopfliOptions *options ,size_t blockstart ,size_t blockend ,int add_lmc ,ZopfliBlockState *s ){s ->options =options ;s ->blockstart =blockstart ;s ->blockend =blockend ;if (add_lmc ){s ->lmc =(ZopfliLongestMatchCache *)malloc (sizeof (ZopfliLongestMatchCache ));ZopfliInitCache (blockend -blockstart ,s ->lmc );}else {s ->lmc =0 ;}}",
                "rust_signature": "pub fn zopfli_init_block_state(\n    options: *const ZopfliOptions,\n    blockstart: usize,\n    blockend: usize,\n    add_lmc: i32,\n    s: *mut ZopfliBlockState,\n) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliInitCache(size_t, ZopfliLongestMatchCache *)": {
                "signature": "void ZopfliInitCache(size_t, ZopfliLongestMatchCache *)",
                "description": "/* Initializes the ZopfliLongestMatchCache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliInitCache (size_t blocksize ,ZopfliLongestMatchCache *lmc ){size_t i ;lmc ->length =(unsigned short *)malloc (sizeof (unsigned short )*blocksize );lmc ->dist =(unsigned short *)malloc (sizeof (unsigned short )*blocksize );/* Rather large amount of memory. */ lmc ->sublen =(unsigned char *)malloc (ZOPFLI_CACHE_LENGTH *3 *blocksize );if (lmc ->sublen ==NULL ){fprintf (stderr ,\"Error: Out of memory. Tried allocating %lu bytes of memory.\\n\" ,(unsigned long )ZOPFLI_CACHE_LENGTH *3 *blocksize );exit (EXIT_FAILURE );}/* length > 0 and dist 0 is invalid combination, which indicates on purpose\n    that this cache value is not filled in yet. */ for (i =0 ;i <blocksize ;i ++)lmc ->length [i ]=1 ;for (i =0 ;i <blocksize ;i ++)lmc ->dist [i ]=0 ;for (i =0 ;i <ZOPFLI_CACHE_LENGTH *blocksize *3 ;i ++)lmc ->sublen [i ]=0 ;}",
                "rust_signature": "fn zopfli_init_cache(blocksize: usize, lmc: &mut ZopfliLongestMatchCache) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                "signature": "void ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliCleanLZ77Store (ZopfliLZ77Store *store ){free (store ->litlens );free (store ->dists );free (store ->pos );free (store ->ll_symbol );free (store ->d_symbol );free (store ->ll_counts );free (store ->d_counts );}",
                "rust_signature": "fn zopfli_clean_lz77_store(store: &mut ZopfliLZ77Store) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                "signature": "void ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliInitLZ77Store (const unsigned char *data ,ZopfliLZ77Store *store ){store ->size =0 ;store ->litlens =0 ;store ->dists =0 ;store ->pos =0 ;store ->data =data ;store ->ll_symbol =0 ;store ->d_symbol =0 ;store ->ll_counts =0 ;store ->d_counts =0 ;}",
                "rust_signature": "fn zopfli_init_lz77_store(data: *const u8, store: *mut ZopfliLZ77Store) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "double ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nCalculates block size in bits, automatically using the best btype.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                        "type": "functions"
                    }
                },
                "full_text": "double ZopfliCalculateBlockSizeAutoType (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){double uncompressedcost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,0 );/* Don't do the expensive fixed cost calculation for larger blocks that are\n       unlikely to use it. */ double fixedcost =(lz77 ->size >1000 )?uncompressedcost :ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,1 );double dyncost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,2 );return (uncompressedcost <fixedcost &&uncompressedcost <dyncost )?uncompressedcost :(fixedcost <dyncost ?fixedcost :dyncost );}",
                "rust_signature": "fn zopfli_calculate_block_size_auto_type(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                "signature": "void ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                "description": "/*\nDoes LZ77 using an algorithm similar to gzip, with lazy matching, rather than\nwith the slow but better \"squeeze\" implementation.\nThe result is placed in the ZopfliLZ77Store.\nIf instart is larger than 0, it uses values before instart as starting\ndictionary.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliResetHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliResetHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::GetLengthScore(int, int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::GetLengthScore(int, int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77Greedy (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,ZopfliLZ77Store *store ,ZopfliHash *h ){size_t i =0 ,j ;unsigned short leng ;unsigned short dist ;int lengthscore ;size_t windowstart =instart >ZOPFLI_WINDOW_SIZE ?instart -ZOPFLI_WINDOW_SIZE :0 ;unsigned short dummysublen [259 ];/* Lazy matching. */ unsigned prev_length =0 ;unsigned prev_match =0 ;int prevlengthscore ;int match_available =0 ;if (instart ==inend )return ;ZopfliResetHash (ZOPFLI_WINDOW_SIZE ,h );ZopfliWarmupHash (in ,windowstart ,inend ,h );for (i =windowstart ;i <instart ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );}for (i =instart ;i <inend ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );ZopfliFindLongestMatch (s ,h ,in ,i ,inend ,ZOPFLI_MAX_MATCH ,dummysublen ,&dist ,&leng );lengthscore =GetLengthScore (leng ,dist );/* Lazy matching. */ prevlengthscore =GetLengthScore (prev_length ,prev_match );if (match_available ){match_available =0 ;if (lengthscore >prevlengthscore +1 ){ZopfliStoreLitLenDist (in [i -1 ],0 ,i -1 ,store );if (lengthscore >=ZOPFLI_MIN_MATCH &&leng <ZOPFLI_MAX_MATCH ){match_available =1 ;prev_length =leng ;prev_match =dist ;continue ;}}else {/* Add previous to output. */ leng =prev_length ;dist =prev_match ;lengthscore =prevlengthscore ;/* Add to output. */ ZopfliVerifyLenDist (in ,inend ,i -1 ,dist ,leng );ZopfliStoreLitLenDist (leng ,dist ,i -1 ,store );for (j =2 ;j <leng ;j ++){assert (i <inend );i ++;ZopfliUpdateHash (in ,i ,inend ,h );}continue ;}}else if (lengthscore >=ZOPFLI_MIN_MATCH &&leng <ZOPFLI_MAX_MATCH ){match_available =1 ;prev_length =leng ;prev_match =dist ;continue ;}/* End of lazy matching. */ /* Add to output. */ if (lengthscore >=ZOPFLI_MIN_MATCH ){ZopfliVerifyLenDist (in ,inend ,i ,dist ,leng );ZopfliStoreLitLenDist (leng ,dist ,i ,store );}else {leng =1 ;ZopfliStoreLitLenDist (in [i ],0 ,i ,store );}for (j =1 ;j <leng ;j ++){assert (i <inend );i ++;ZopfliUpdateHash (in ,i ,inend ,h );}}}",
                "rust_signature": "pub fn zopfli_lz77_greedy(\n    s: &mut ZopfliBlockState,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    store: &mut ZopfliLZ77Store,\n    h: &mut ZopfliHash,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCalculateEntropy(const size_t *, size_t, double *)": {
                "signature": "void ZopfliCalculateEntropy(const size_t *, size_t, double *)",
                "description": "/*\nCalculates the entropy of each symbol, based on the counts of each symbol. The\nresult is similar to the result of ZopfliCalculateBitLengths, but with the\nactual theoritical bit lengths according to the entropy. Since the resulting\nvalues are fractional, they cannot be used to encode the tree specified by\nDEFLATE.\n*/",
                "dependencies": {},
                "full_text": "void ZopfliCalculateEntropy (const size_t *count ,size_t n ,double *bitlengths ){static const double kInvLog2 =1.4426950408889 ;/* 1.0 / log(2.0) */ unsigned sum =0 ;unsigned i ;double log2sum ;for (i =0 ;i <n ;++i ){sum +=count [i ];}log2sum =(sum ==0 ?log (n ):log (sum ))*kInvLog2 ;for (i =0 ;i <n ;++i ){/* When the count of the symbol is 0, but its cost is requested anyway, it\n        means the symbol will appear at least once anyway, so give it the cost as if\n        its count is 1.*/ if (count [i ]==0 )bitlengths [i ]=log2sum ;else bitlengths [i ]=log2sum -log (count [i ])*kInvLog2 ;/* Depending on compiler and architecture, the above subtraction of two\n        floating point numbers may give a negative result very close to zero\n        instead of zero (e.g. -5.973954e-17 with gcc 4.1.2 on Ubuntu 11.4). Clamp\n        it to zero. These floating point imprecisions do not affect the cost model\n        significantly so this is ok. */ if (bitlengths [i ]<0 &&bitlengths [i ]>-1e-5 )bitlengths [i ]=0 ;assert (bitlengths [i ]>=0 );}}",
                "rust_signature": "fn zopfli_calculate_entropy(count: &[usize], n: usize, bitlengths: &mut [f64]) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                "signature": "void ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CeilDiv(size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CeilDiv(size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCopyLZ77Store (const ZopfliLZ77Store *source ,ZopfliLZ77Store *dest ){size_t i ;size_t llsize =ZOPFLI_NUM_LL *CeilDiv (source ->size ,ZOPFLI_NUM_LL );size_t dsize =ZOPFLI_NUM_D *CeilDiv (source ->size ,ZOPFLI_NUM_D );ZopfliCleanLZ77Store (dest );ZopfliInitLZ77Store (source ->data ,dest );dest ->litlens =(unsigned short *)malloc (sizeof (*dest ->litlens )*source ->size );dest ->dists =(unsigned short *)malloc (sizeof (*dest ->dists )*source ->size );dest ->pos =(size_t *)malloc (sizeof (*dest ->pos )*source ->size );dest ->ll_symbol =(unsigned short *)malloc (sizeof (*dest ->ll_symbol )*source ->size );dest ->d_symbol =(unsigned short *)malloc (sizeof (*dest ->d_symbol )*source ->size );dest ->ll_counts =(size_t *)malloc (sizeof (*dest ->ll_counts )*llsize );dest ->d_counts =(size_t *)malloc (sizeof (*dest ->d_counts )*dsize );/* Allocation failed. */ if (!dest ->litlens ||!dest ->dists )exit (-1 );if (!dest ->pos )exit (-1 );if (!dest ->ll_symbol ||!dest ->d_symbol )exit (-1 );if (!dest ->ll_counts ||!dest ->d_counts )exit (-1 );dest ->size =source ->size ;for (i =0 ;i <source ->size ;i ++){dest ->litlens [i ]=source ->litlens [i ];dest ->dists [i ]=source ->dists [i ];dest ->pos [i ]=source ->pos [i ];dest ->ll_symbol [i ]=source ->ll_symbol [i ];dest ->d_symbol [i ]=source ->d_symbol [i ];}for (i =0 ;i <llsize ;i ++){dest ->ll_counts [i ]=source ->ll_counts [i ];}for (i =0 ;i <dsize ;i ++){dest ->d_counts [i ]=source ->d_counts [i ];}}",
                "rust_signature": "fn zopfli_copy_lz77_store(source: &ZopfliLZ77Store, dest: &mut ZopfliLZ77Store) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)": {
                "signature": "void ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)",
                "description": "/*\nCalculates lit/len and dist pairs for given data.\nIf instart is larger than 0, it uses values before instart as starting\ndictionary.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    },
                    "zopfli::InitRanState(RanState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitRanState(RanState *)",
                        "type": "functions"
                    },
                    "zopfli::InitStats(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitStats(SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::GetStatistics(const ZopfliLZ77Store *, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::GetStatistics(const ZopfliLZ77Store *, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)",
                        "type": "functions"
                    },
                    "zopfli::GetCostStat(unsigned int, unsigned int, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetCostStat(unsigned int, unsigned int, void *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::CopyStats(SymbolStats *, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::CopyStats(SymbolStats *, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ClearStatFreqs(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ClearStatFreqs(SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateStatistics(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::CalculateStatistics(SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::RandomizeStatFreqs(RanState *, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::RandomizeStatFreqs(RanState *, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanHash(ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanHash(ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77Optimal (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,int numiterations ,ZopfliLZ77Store *store ){/* Dist to get to here with smallest cost. */ size_t blocksize =inend -instart ;unsigned short *length_array =(unsigned short *)malloc (sizeof (unsigned short )*(blocksize +1 ));unsigned short *path =0 ;size_t pathsize =0 ;ZopfliLZ77Store currentstore ;ZopfliHash hash ;ZopfliHash *h =&hash ;SymbolStats stats ,beststats ,laststats ;int i ;float *costs =(float *)malloc (sizeof (float )*(blocksize +1 ));double cost ;double bestcost =ZOPFLI_LARGE_FLOAT ;double lastcost =0 ;/* Try randomizing the costs a bit once the size stabilizes. */ RanState ran_state ;int lastrandomstep =-1 ;if (!costs )exit (-1 );/* Allocation failed. */ if (!length_array )exit (-1 );/* Allocation failed. */ InitRanState (&ran_state );InitStats (&stats );ZopfliInitLZ77Store (in ,&currentstore );ZopfliAllocHash (ZOPFLI_WINDOW_SIZE ,h );/* Do regular deflate, then loop multiple shortest path runs, each time using\n    the statistics of the previous run. */ /* Initial run. */ ZopfliLZ77Greedy (s ,in ,instart ,inend ,&currentstore ,h );GetStatistics (&currentstore ,&stats );/* Repeat statistics with each time the cost model from the previous stat\n    run. */ for (i =0 ;i <numiterations ;i ++){ZopfliCleanLZ77Store (&currentstore );ZopfliInitLZ77Store (in ,&currentstore );LZ77OptimalRun (s ,in ,instart ,inend ,&path ,&pathsize ,length_array ,GetCostStat ,(void *)&stats ,&currentstore ,h ,costs );cost =ZopfliCalculateBlockSize (&currentstore ,0 ,currentstore .size ,2 );if (s ->options ->verbose_more ||(s ->options ->verbose &&cost <bestcost )){fprintf (stderr ,\"Iteration %d: %d bit\\n\" ,i ,(int )cost );}if (cost <bestcost ){/* Copy to the output store. */ ZopfliCopyLZ77Store (&currentstore ,store );CopyStats (&stats ,&beststats );bestcost =cost ;}CopyStats (&stats ,&laststats );ClearStatFreqs (&stats );GetStatistics (&currentstore ,&stats );if (lastrandomstep !=-1 ){/* This makes it converge slower but better. Do it only once the\n            randomness kicks in so that if the user does few iterations, it gives a\n            better result sooner. */ AddWeighedStatFreqs (&stats ,1.0 ,&laststats ,0.5 ,&stats );CalculateStatistics (&stats );}if (i >5 &&cost ==lastcost ){CopyStats (&beststats ,&stats );RandomizeStatFreqs (&ran_state ,&stats );CalculateStatistics (&stats );lastrandomstep =i ;}lastcost =cost ;}free (length_array );free (path );free (costs );ZopfliCleanLZ77Store (&currentstore );ZopfliCleanHash (h );}",
                "rust_signature": "pub fn zopfli_lz77_optimal(\n    s: &mut ZopfliBlockState,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    num_iterations: i32,\n    store: &mut ZopfliLZ77Store,\n) {\n    // Placeholder for the function body. Original C code contains complex logic.\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)": {
                "signature": "void ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)",
                "description": "/*\nDoes blocksplitting on LZ77 data.\nThe output splitpoints are indices in the LZ77 data.\nmaxblocks: set a limit to the amount of blocks. Set to 0 to mean no limit.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::SplitCostContext": {
                        "return_type": "SplitCostContext",
                        "qualified_name": "zopfli::SplitCostContext",
                        "type": "structs"
                    },
                    "zopfli::FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)",
                        "type": "functions"
                    },
                    "zopfli::SplitCost(size_t, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::SplitCost(size_t, void *)",
                        "type": "functions"
                    },
                    "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::AddSorted(size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddSorted(size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliBlockSplitLZ77 (const ZopfliOptions *options ,const ZopfliLZ77Store *lz77 ,size_t maxblocks ,size_t **splitpoints ,size_t *npoints ){size_t lstart ,lend ;size_t i ;size_t llpos =0 ;size_t numblocks =1 ;unsigned char *done ;double splitcost ,origcost ;if (lz77 ->size <10 )return ;/* This code fails on tiny files. */ done =(unsigned char *)malloc (lz77 ->size );if (!done )exit (-1 );/* Allocation failed. */ for (i =0 ;i <lz77 ->size ;i ++)done [i ]=0 ;lstart =0 ;lend =lz77 ->size ;for (;;){SplitCostContext c ;if (maxblocks >0 &&numblocks >=maxblocks ){break ;}c .lz77 =lz77 ;c .start =lstart ;c .end =lend ;assert (lstart <lend );llpos =FindMinimum (SplitCost ,&c ,lstart +1 ,lend ,&splitcost );assert (llpos >lstart );assert (llpos <lend );origcost =EstimateCost (lz77 ,lstart ,lend );if (splitcost >origcost ||llpos ==lstart +1 ||llpos ==lend ){done [lstart ]=1 ;}else {AddSorted (llpos ,splitpoints ,npoints );numblocks ++;}if (!FindLargestSplittableBlock (lz77 ->size ,done ,*splitpoints ,*npoints ,&lstart ,&lend )){break ;/* No further split will probably reduce compression. */ }if (lend -lstart <10 ){break ;}}if (options ->verbose ){PrintBlockSplitPoints (lz77 ,*splitpoints ,*npoints );}free (done );}",
                "rust_signature": "pub fn zopfli_block_split_lz77(\n    options: *const ZopfliOptions, \n    lz77: *const ZopfliLZ77Store, \n    maxblocks: usize, \n    splitpoints: *mut *mut usize, \n    npoints: *mut usize\n) {\n    unsafe {\n        // Function body not implemented\n        todo!(\"Function body not implemented\");\n    }\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)": {
                "signature": "void ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)",
                "description": "/*\nDoes blocksplitting on uncompressed data.\nThe output splitpoints are indices in the uncompressed bytes.\n\noptions: general program options.\nin: uncompressed input data\ninstart: where to start splitting\ninend: where to end splitting (not inclusive)\nmaxblocks: maximum amount of blocks to split into, or 0 for no limit\nsplitpoints: dynamic array to put the resulting split point coordinates into.\nThe coordinates are indices in the input array.\nnpoints: pointer to amount of splitpoints, for the dynamic array. The amount of\nblocks is the amount of splitpoitns + 1.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanHash(ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanHash(ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliBlockSplit (const ZopfliOptions *options ,const unsigned char *in ,size_t instart ,size_t inend ,size_t maxblocks ,size_t **splitpoints ,size_t *npoints ){size_t pos =0 ;size_t i ;ZopfliBlockState s ;size_t *lz77splitpoints =0 ;size_t nlz77points =0 ;ZopfliLZ77Store store ;ZopfliHash hash ;ZopfliHash *h =&hash ;ZopfliInitLZ77Store (in ,&store );ZopfliInitBlockState (options ,instart ,inend ,0 ,&s );ZopfliAllocHash (ZOPFLI_WINDOW_SIZE ,h );*npoints =0 ;*splitpoints =0 ;/* Unintuitively, Using a simple LZ77 method here instead of ZopfliLZ77Optimal\n    results in better blocks. */ ZopfliLZ77Greedy (&s ,in ,instart ,inend ,&store ,h );ZopfliBlockSplitLZ77 (options ,&store ,maxblocks ,&lz77splitpoints ,&nlz77points );/* Convert LZ77 positions to positions in the uncompressed input. */ pos =instart ;if (nlz77points >0 ){for (i =0 ;i <store .size ;i ++){size_t length =store .dists [i ]==0 ?1 :store .litlens [i ];if (lz77splitpoints [*npoints ]==i ){ZOPFLI_APPEND_DATA (pos ,splitpoints ,npoints );if (*npoints ==nlz77points )break ;}pos +=length ;}}assert (*npoints ==nlz77points );free (lz77splitpoints );ZopfliCleanBlockState (&s );ZopfliCleanLZ77Store (&store );ZopfliCleanHash (h );}",
                "rust_signature": "pub fn zopfli_block_split(\n    options: &ZopfliOptions,\n    in_data: *const u8,\n    instart: usize,\n    inend: usize,\n    maxblocks: usize,\n    splitpoints: &mut *mut usize,\n    npoints: &mut usize,\n) {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                "signature": "void ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliAppendLZ77Store (const ZopfliLZ77Store *store ,ZopfliLZ77Store *target ){size_t i ;for (i =0 ;i <store ->size ;i ++){ZopfliStoreLitLenDist (store ->litlens [i ],store ->dists [i ],store ->pos [i ],target );}}",
                "rust_signature": "fn zopfli_append_lz77_store(store: &ZopfliLZ77Store, target: &mut ZopfliLZ77Store) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nDeflate a part, to allow ZopfliDeflate() to use multiple master blocks if\nneeded.\nIt is possible to call this function multiple times in a row, shifting\ninstart and inend to next bytes of the data. If instart is larger than 0, then\nprevious bytes are used as the initial dictionary for LZ77.\nThis function will usually output multiple deflate blocks. If final is 1, then\nthe final bit will be set on the last block.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliDeflatePart (const ZopfliOptions *options ,int btype ,int final ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t i ;/* byte coordinates rather than lz77 index */ size_t *splitpoints_uncompressed =0 ;size_t npoints =0 ;size_t *splitpoints =0 ;double totalcost =0 ;ZopfliLZ77Store lz77 ;/* If btype=2 is specified, it tries all block types. If a lesser btype is\n    given, then however it forces that one. Neither of the lesser types needs\n    block splitting as they have no dynamic huffman trees. */ if (btype ==0 ){AddNonCompressedBlock (options ,final ,in ,instart ,inend ,bp ,out ,outsize );return ;}else if (btype ==1 ){ZopfliLZ77Store store ;ZopfliBlockState s ;ZopfliInitLZ77Store (in ,&store );ZopfliInitBlockState (options ,instart ,inend ,1 ,&s );ZopfliLZ77OptimalFixed (&s ,in ,instart ,inend ,&store );AddLZ77Block (options ,btype ,final ,&store ,0 ,store .size ,0 ,bp ,out ,outsize );ZopfliCleanBlockState (&s );ZopfliCleanLZ77Store (&store );return ;}if (options ->blocksplitting ){ZopfliBlockSplit (options ,in ,instart ,inend ,options ->blocksplittingmax ,&splitpoints_uncompressed ,&npoints );splitpoints =(size_t *)malloc (sizeof (*splitpoints )*npoints );}ZopfliInitLZ77Store (in ,&lz77 );for (i =0 ;i <=npoints ;i ++){size_t start =i ==0 ?instart :splitpoints_uncompressed [i -1 ];size_t end =i ==npoints ?inend :splitpoints_uncompressed [i ];ZopfliBlockState s ;ZopfliLZ77Store store ;ZopfliInitLZ77Store (in ,&store );ZopfliInitBlockState (options ,start ,end ,1 ,&s );ZopfliLZ77Optimal (&s ,in ,start ,end ,options ->numiterations ,&store );totalcost +=ZopfliCalculateBlockSizeAutoType (&store ,0 ,store .size );ZopfliAppendLZ77Store (&store ,&lz77 );if (i <npoints )splitpoints [i ]=lz77 .size ;ZopfliCleanBlockState (&s );ZopfliCleanLZ77Store (&store );}/* Second block splitting attempt */ if (options ->blocksplitting &&npoints >1 ){size_t *splitpoints2 =0 ;size_t npoints2 =0 ;double totalcost2 =0 ;ZopfliBlockSplitLZ77 (options ,&lz77 ,options ->blocksplittingmax ,&splitpoints2 ,&npoints2 );for (i =0 ;i <=npoints2 ;i ++){size_t start =i ==0 ?0 :splitpoints2 [i -1 ];size_t end =i ==npoints2 ?lz77 .size :splitpoints2 [i ];totalcost2 +=ZopfliCalculateBlockSizeAutoType (&lz77 ,start ,end );}if (totalcost2 <totalcost ){free (splitpoints );splitpoints =splitpoints2 ;npoints =npoints2 ;}else {free (splitpoints2 );}}for (i =0 ;i <=npoints ;i ++){size_t start =i ==0 ?0 :splitpoints [i -1 ];size_t end =i ==npoints ?lz77 .size :splitpoints [i ];AddLZ77BlockAutoType (options ,i ==npoints &&final ,&lz77 ,start ,end ,0 ,bp ,out ,outsize );}ZopfliCleanLZ77Store (&lz77 );free (splitpoints );free (splitpoints_uncompressed );}",
                "rust_signature": "pub fn zopfli_deflate_part(\n    options: &ZopfliOptions,\n    btype: i32,\n    final_block: i32,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    bp: &mut u8,\n    out: &mut Vec<u8>,\n    outsize: &mut usize,\n) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nCompresses according to the deflate specification and append the compressed\nresult to the output.\nThis function will usually output multiple deflate blocks. If final is 1, then\nthe final bit will be set on the last block.\n\noptions: global program options\nbtype: the deflate block type. Use 2 for best compression.\n-0: non compressed blocks (00)\n-1: blocks with fixed tree (01)\n-2: blocks with dynamic tree (10)\nfinal: whether this is the last section of the input, sets the final bit to the\nlast deflate block.\nin: the input bytes\ninsize: number of input bytes\nbp: bit pointer for the output array. This must initially be 0, and for\nconsecutive calls must be reused (it can have values from 0-7). This is\nbecause deflate appends blocks as bit-based data, rather than on byte\nboundaries.\nout: pointer to the dynamic output array to which the result is appended. Must\nbe freed after use.\noutsize: pointer to the dynamic output array size.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliDeflate (const ZopfliOptions *options ,int btype ,int final ,const unsigned char *in ,size_t insize ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t offset =*outsize ;size_t i =0 ;do {int masterfinal =(i +ZOPFLI_MASTER_BLOCK_SIZE >=insize );int final2 =final &&masterfinal ;size_t size =masterfinal ?insize -i :ZOPFLI_MASTER_BLOCK_SIZE ;ZopfliDeflatePart (options ,btype ,final2 ,in ,i ,i +size ,bp ,out ,outsize );i +=size ;}while (i <insize );if (options ->verbose ){fprintf (stderr ,\"Original Size: %lu, Deflate: %lu, Compression: %.2f%%\\n\" ,(unsigned long )insize ,(unsigned long )(*outsize -offset ),100.0 *(double )(insize -(*outsize -offset ))/(double )insize );}}",
                "rust_signature": "pub fn zopfli_deflate(\n    options: *const ZopfliOptions,\n    btype: i32,\n    final_block: i32,\n    input: *const u8,\n    insize: usize,\n    bp: *mut u8,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliGetLengthSymbol(int)": {
                "signature": "int ZopfliGetLengthSymbol(int)",
                "description": "/*\nGets the symbol for the given length, cfr. the DEFLATE spec.\nReturns the symbol in the range [257-285] (inclusive)\n*/",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthSymbol (int l ){static const int table [259 ]={0 ,0 ,0 ,257 ,258 ,259 ,260 ,261 ,262 ,263 ,264 ,265 ,265 ,266 ,266 ,267 ,267 ,268 ,268 ,269 ,269 ,269 ,269 ,270 ,270 ,270 ,270 ,271 ,271 ,271 ,271 ,272 ,272 ,272 ,272 ,273 ,273 ,273 ,273 ,273 ,273 ,273 ,273 ,274 ,274 ,274 ,274 ,274 ,274 ,274 ,274 ,275 ,275 ,275 ,275 ,275 ,275 ,275 ,275 ,276 ,276 ,276 ,276 ,276 ,276 ,276 ,276 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,285 };return table [l ];}",
                "rust_signature": "fn zopfli_get_length_symbol(l: usize) -> i32 {\n    todo!(\"Function implementation is not provided.\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliGetDistSymbol(int)": {
                "signature": "int ZopfliGetDistSymbol(int)",
                "description": "/* Gets the symbol for the given dist, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistSymbol (int dist ){if (dist <5 ){return dist -1 ;}else {int l =(31 ^__builtin_clz (dist -1 ));/* log2(dist - 1) */ int r =((dist -1 )>>(l -1 ))&1 ;return l *2 +r ;}}",
                "rust_signature": "pub fn zopfli_get_dist_symbol(dist: i32) -> i32 {\n    // Placeholder implementation\n    todo!(\"Implement the function logic\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "AbsDiff(size_t, size_t)": {
                "signature": "size_t AbsDiff(size_t, size_t)",
                "description": "",
                "dependencies": {},
                "full_text": "static size_t AbsDiff (size_t x ,size_t y ){if (x >y )return x -y ;else return y -x ;}",
                "rust_signature": "fn abs_diff(x: usize, y: usize) -> usize {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "OptimizeHuffmanForRle(int, size_t *)": {
                "signature": "void OptimizeHuffmanForRle(int, size_t *)",
                "description": "/*\nChanges the population counts in a way that the consequent Huffman tree\ncompression, especially its rle-part, will be more likely to compress this data\nmore efficiently. length contains the size of the histogram.\n*/",
                "dependencies": {
                    "zopfli::AbsDiff(size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::AbsDiff(size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void OptimizeHuffmanForRle (int length ,size_t *counts ){int i ,k ,stride ;size_t symbol ,sum ,limit ;int *good_for_rle ;/* 1) We don't want to touch the trailing zeros. We may break the\n    rules of the format by adding more data in the distance codes. */ for (;length >=0 ;--length ){if (length ==0 ){return ;}if (counts [length -1 ]!=0 ){/* Now counts[0..length - 1] does not have trailing zeros. */ break ;}}/* 2) Let's mark all population counts that already can be encoded\n    with an rle code.*/ good_for_rle =(int *)malloc ((unsigned )length *sizeof (int ));for (i =0 ;i <length ;++i )good_for_rle [i ]=0 ;/* Let's not spoil any of the existing good rle codes.\n    Mark any seq of 0's that is longer than 5 as a good_for_rle.\n    Mark any seq of non-0's that is longer than 7 as a good_for_rle.*/ symbol =counts [0 ];stride =0 ;for (i =0 ;i <length +1 ;++i ){if (i ==length ||counts [i ]!=symbol ){if ((symbol ==0 &&stride >=5 )||(symbol !=0 &&stride >=7 )){for (k =0 ;k <stride ;++k ){good_for_rle [i -k -1 ]=1 ;}}stride =1 ;if (i !=length ){symbol =counts [i ];}}else {++stride ;}}/* 3) Let's replace those population counts that lead to more rle codes. */ stride =0 ;limit =counts [0 ];sum =0 ;for (i =0 ;i <length +1 ;++i ){if (i ==length ||good_for_rle [i ]/* Heuristic for selecting the stride ranges to collapse. */ ||AbsDiff (counts [i ],limit )>=4 ){if (stride >=4 ||(stride >=3 &&sum ==0 )){/* The stride must end, collapse what we have, if we have enough (4). */ int count =(sum +stride /2 )/stride ;if (count <1 )count =1 ;if (sum ==0 ){/* Don't make an all zeros stride to be upgraded to ones. */ count =0 ;}for (k =0 ;k <stride ;++k ){/* We don't want to change value at counts[i],\n                    that is already belonging to the next stride. Thus - 1. */ counts [i -k -1 ]=count ;}}stride =0 ;sum =0 ;if (i <length -3 ){/* All interesting strides have a count of at least 4,\n                at least when non-zeros. */ limit =(counts [i ]+counts [i +1 ]+counts [i +2 ]+counts [i +3 ]+2 )/4 ;}else if (i <length ){limit =counts [i ];}else {limit =0 ;}}++stride ;if (i !=length ){sum +=counts [i ];}}free (good_for_rle );}",
                "rust_signature": "fn optimize_huffman_for_rle(length: i32, counts: &mut Vec<usize>) {\n    // Placeholder for the function body\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliGetDistSymbolExtraBits(int)": {
                "signature": "int ZopfliGetDistSymbolExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given distance symbol. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistSymbolExtraBits (int s ){static const int table [30 ]={0 ,0 ,0 ,0 ,1 ,1 ,2 ,2 ,3 ,3 ,4 ,4 ,5 ,5 ,6 ,6 ,7 ,7 ,8 ,8 ,9 ,9 ,10 ,10 ,11 ,11 ,12 ,12 ,13 ,13 };return table [s ];}",
                "rust_signature": "fn zopfli_get_dist_symbol_extra_bits(s: usize) -> i32 {\n    todo!(\"Implement logic\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliGetLengthSymbolExtraBits(int)": {
                "signature": "int ZopfliGetLengthSymbolExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given length symbol. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthSymbolExtraBits (int s ){static const int table [29 ]={0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,1 ,1 ,1 ,2 ,2 ,2 ,2 ,3 ,3 ,3 ,3 ,4 ,4 ,4 ,4 ,5 ,5 ,5 ,5 ,0 };return table [s -257 ];}",
                "rust_signature": "fn zopfli_get_length_symbol_extra_bits(s: i32) -> i32 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 4
            },
            "CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nSame as CalculateBlockSymbolSize, but for block size smaller than histogram\nsize.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbolExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbolExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateBlockSymbolSizeSmall (const unsigned *ll_lengths ,const unsigned *d_lengths ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){size_t result =0 ;size_t i ;for (i =lstart ;i <lend ;i ++){assert (i <lz77 ->size );assert (lz77 ->litlens [i ]<259 );if (lz77 ->dists [i ]==0 ){result +=ll_lengths [lz77 ->litlens [i ]];}else {int ll_symbol =ZopfliGetLengthSymbol (lz77 ->litlens [i ]);int d_symbol =ZopfliGetDistSymbol (lz77 ->dists [i ]);result +=ll_lengths [ll_symbol ];result +=d_lengths [d_symbol ];result +=ZopfliGetLengthSymbolExtraBits (ll_symbol );result +=ZopfliGetDistSymbolExtraBits (d_symbol );}}result +=ll_lengths [256 ];/*end symbol*/ return result ;}",
                "rust_signature": "pub fn calculate_block_symbol_size_small(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize\n) -> usize {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nSame as CalculateBlockSymbolSize, but with the histogram provided by the caller.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbolExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbolExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateBlockSymbolSizeGivenCounts (const size_t *ll_counts ,const size_t *d_counts ,const unsigned *ll_lengths ,const unsigned *d_lengths ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){size_t result =0 ;size_t i ;if (lstart +ZOPFLI_NUM_LL *3 >lend ){return CalculateBlockSymbolSizeSmall (ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}else {for (i =0 ;i <256 ;i ++){result +=ll_lengths [i ]*ll_counts [i ];}for (i =257 ;i <286 ;i ++){result +=ll_lengths [i ]*ll_counts [i ];result +=ZopfliGetLengthSymbolExtraBits (i )*ll_counts [i ];}for (i =0 ;i <30 ;i ++){result +=d_lengths [i ]*d_counts [i ];result +=ZopfliGetDistSymbolExtraBits (i )*d_counts [i ];}result +=ll_lengths [256 ];/*end symbol*/ return result ;}}",
                "rust_signature": "pub fn calculate_block_symbol_size_given_counts(\n    ll_counts: &[usize],\n    d_counts: &[usize],\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize\n) -> usize {\n    // Placeholder implementation\n    0usize\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "LeafComparator(const void *, const void *)": {
                "signature": "int LeafComparator(const void *, const void *)",
                "description": "/*\nComparator for sorting the leaves. Has the function signature for qsort.\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    }
                },
                "full_text": "static int LeafComparator (const void *a ,const void *b ){return ((const Node *)a )->weight -((const Node *)b )->weight ;}",
                "rust_signature": "fn leaf_comparator(a: *const core::ffi::c_void, b: *const core::ffi::c_void) -> i32 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ExtractBitLengths(Node *, Node *, unsigned int *)": {
                "signature": "void ExtractBitLengths(Node *, Node *, unsigned int *)",
                "description": "/*\nConverts result of boundary package-merge to the bitlengths. The result in the\nlast chain of the last list contains the amount of active leaves in each list.\nchain: Chain to extract the bit length from (last chain from last list).\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    }
                },
                "full_text": "static void ExtractBitLengths (Node *chain ,Node *leaves ,unsigned *bitlengths ){int counts [16 ]={0 };unsigned end =16 ;unsigned ptr =15 ;unsigned value =1 ;Node *node ;int val ;for (node =chain ;node ;node =node ->tail ){counts [--end ]=node ->count ;}val =counts [15 ];while (ptr >=end ){for (;val >counts [ptr -1 ];val --){bitlengths [leaves [val -1 ].count ]=value ;}ptr --;value ++;}}",
                "rust_signature": "unsafe fn extract_bit_lengths(chain: *mut Node, leaves: *mut Node, bitlengths: *mut u32) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "InitNode(size_t, int, Node *, Node *)": {
                "signature": "void InitNode(size_t, int, Node *, Node *)",
                "description": "/*\nInitializes a chain node with the given values and marks it as in use.\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    }
                },
                "full_text": "static void InitNode (size_t weight ,int count ,Node *tail ,Node *node ){node ->weight =weight ;node ->count =count ;node ->tail =tail ;}",
                "rust_signature": "fn init_node(weight: usize, count: i32, tail: Option<Box<Node>>, node: &mut Node) { unimplemented!() }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "InitLists(NodePool *, const Node *, int, Node *(*)[2])": {
                "signature": "void InitLists(NodePool *, const Node *, int, Node *(*)[2])",
                "description": "/*\nInitializes each list with as lookahead chains the two leaves with lowest\nweights.\n*/",
                "dependencies": {
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    },
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::InitNode(size_t, int, Node *, Node *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitNode(size_t, int, Node *, Node *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void InitLists (NodePool *pool ,const Node *leaves ,int maxbits ,Node *(*lists )[2 ]){int i ;Node *node0 =pool ->next ++;Node *node1 =pool ->next ++;InitNode (leaves [0 ].weight ,1 ,0 ,node0 );InitNode (leaves [1 ].weight ,2 ,0 ,node1 );for (i =0 ;i <maxbits ;i ++){lists [i ][0 ]=node0 ;lists [i ][1 ]=node1 ;}}",
                "rust_signature": "fn init_lists(pool: *mut NodePool, leaves: *const Node, maxbits: i32, lists: *mut [*mut Node; 2]) { unsafe { todo!() } }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)": {
                "signature": "void BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)",
                "description": "",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    }
                },
                "full_text": "static void BoundaryPMFinal (Node *(*lists )[2 ],Node *leaves ,int numsymbols ,NodePool *pool ,int index ){int lastcount =lists [index ][1 ]->count ;/* Count of last chain of list. */ size_t sum =lists [index -1 ][0 ]->weight +lists [index -1 ][1 ]->weight ;if (lastcount <numsymbols &&sum >leaves [lastcount ].weight ){Node *newchain =pool ->next ;Node *oldchain =lists [index ][1 ]->tail ;lists [index ][1 ]=newchain ;newchain ->count =lastcount +1 ;newchain ->tail =oldchain ;}else {lists [index ][1 ]->tail =lists [index -1 ][1 ];}}",
                "rust_signature": "fn boundary_pm_final(lists: *mut [[*mut Node; 2]], leaves: *const Node, numsymbols: i32, pool: *mut NodePool, index: usize) { unsafe { todo!() } }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)": {
                "signature": "void BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)",
                "description": "/*\nPerforms a Boundary Package-Merge step. Puts a new chain in the given list. The\nnew chain is, depending on the weights, a leaf or a combination of two chains\nfrom the previous list.\nlists: The lists of chains.\nmaxbits: Number of lists.\nleaves: The leaves, one per symbol.\nnumsymbols: Number of leaves.\npool: the node memory pool.\nindex: The index of the list in which a new chain or leaf is required.\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    },
                    "zopfli::InitNode(size_t, int, Node *, Node *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitNode(size_t, int, Node *, Node *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void BoundaryPM (Node *(*lists )[2 ],Node *leaves ,int numsymbols ,NodePool *pool ,int index ){Node *newchain ;Node *oldchain ;int lastcount =lists [index ][1 ]->count ;/* Count of last chain of list. */ if (index ==0 &&lastcount >=numsymbols )return ;newchain =pool ->next ++;oldchain =lists [index ][1 ];/* These are set up before the recursive calls below, so that there is a list\n    pointing to the new node, to let the garbage collection know it's in use. */ lists [index ][0 ]=oldchain ;lists [index ][1 ]=newchain ;if (index ==0 ){/* New leaf node in list 0. */ InitNode (leaves [lastcount ].weight ,lastcount +1 ,0 ,newchain );}else {size_t sum =lists [index -1 ][0 ]->weight +lists [index -1 ][1 ]->weight ;if (lastcount <numsymbols &&sum >leaves [lastcount ].weight ){/* New leaf inserted in list, so count is incremented. */ InitNode (leaves [lastcount ].weight ,lastcount +1 ,oldchain ->tail ,newchain );}else {InitNode (sum ,lastcount ,lists [index -1 ][1 ],newchain );/* Two lookahead chains of previous list used up, create new ones. */ BoundaryPM (lists ,leaves ,numsymbols ,pool ,index -1 );BoundaryPM (lists ,leaves ,numsymbols ,pool ,index -1 );}}}",
                "rust_signature": "fn boundary_pm(lists: *mut [*mut Node; 2], leaves: *const Node, numsymbols: i32, pool: &mut NodePool, index: usize) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nAdds bits, like AddBits, but the order is inverted. The deflate specification\nuses both orders in one standard.\n*/",
                "dependencies": {},
                "full_text": "static void AddHuffmanBits (unsigned symbol ,unsigned length ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){/* TODO(lode): make more efficient (add more bits at once). */ unsigned i ;for (i =0 ;i <length ;i ++){unsigned bit =(symbol >>(length -i -1 ))&1 ;if (*bp ==0 )ZOPFLI_APPEND_DATA (0 ,out ,outsize );(*out )[*outsize -1 ]|=bit <<*bp ;*bp =(*bp +1 )&7 ;}}",
                "rust_signature": "fn add_huffman_bits(symbol: u32, length: u32, bp: &mut u8, out: &mut Vec<u8>, outsize: &mut usize) { todo!(\"Original C function logic not implemented\"); }",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                "description": "",
                "dependencies": {},
                "full_text": "static void AddBits (unsigned symbol ,unsigned length ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){/* TODO(lode): make more efficient (add more bits at once). */ unsigned i ;for (i =0 ;i <length ;i ++){unsigned bit =(symbol >>i )&1 ;if (*bp ==0 )ZOPFLI_APPEND_DATA (0 ,out ,outsize );(*out )[*outsize -1 ]|=bit <<*bp ;*bp =(*bp +1 )&7 ;}}",
                "rust_signature": "pub fn add_bits(symbol: u32, length: u32, bp: &mut u8, out: &mut Vec<u8>, outsize: &mut usize) {\n    // TODO: make more efficient (add more bits at once).\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "size_t EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nEncodes the Huffman tree and returns how many bits its encoding takes. If out\nis a null pointer, only returns the size and runs faster.\n*/",
                "dependencies": {
                    "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t EncodeTree (const unsigned *ll_lengths ,const unsigned *d_lengths ,int use_16 ,int use_17 ,int use_18 ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){unsigned lld_total ;/* Total amount of literal, length, distance codes. */ /* Runlength encoded version of lengths of litlen and dist trees. */ unsigned *rle =0 ;unsigned *rle_bits =0 ;/* Extra bits for rle values 16, 17 and 18. */ size_t rle_size =0 ;/* Size of rle array. */ size_t rle_bits_size =0 ;/* Should have same value as rle_size. */ unsigned hlit =29 ;/* 286 - 257 */ unsigned hdist =29 ;/* 32 - 1, but gzip does not like hdist > 29.*/ unsigned hclen ;unsigned hlit2 ;size_t i ,j ;size_t clcounts [19 ];unsigned clcl [19 ];/* Code length code lengths. */ unsigned clsymbols [19 ];/* The order in which code length code lengths are encoded as per deflate. */ static const unsigned order [19 ]={16 ,17 ,18 ,0 ,8 ,7 ,9 ,6 ,10 ,5 ,11 ,4 ,12 ,3 ,13 ,2 ,14 ,1 ,15 };int size_only =!out ;size_t result_size =0 ;for (i =0 ;i <19 ;i ++)clcounts [i ]=0 ;/* Trim zeros. */ while (hlit >0 &&ll_lengths [257 +hlit -1 ]==0 )hlit --;while (hdist >0 &&d_lengths [1 +hdist -1 ]==0 )hdist --;hlit2 =hlit +257 ;lld_total =hlit2 +hdist +1 ;for (i =0 ;i <lld_total ;i ++){/* This is an encoding of a huffman tree, so now the length is a symbol */ unsigned char symbol =i <hlit2 ?ll_lengths [i ]:d_lengths [i -hlit2 ];unsigned count =1 ;if (use_16 ||(symbol ==0 &&(use_17 ||use_18 ))){for (j =i +1 ;j <lld_total &&symbol ==(j <hlit2 ?ll_lengths [j ]:d_lengths [j -hlit2 ]);j ++){count ++;}}i +=count -1 ;/* Repetitions of zeroes */ if (symbol ==0 &&count >=3 ){if (use_18 ){while (count >=11 ){unsigned count2 =count >138 ?138 :count ;if (!size_only ){ZOPFLI_APPEND_DATA (18 ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (count2 -11 ,&rle_bits ,&rle_bits_size );}clcounts [18 ]++;count -=count2 ;}}if (use_17 ){while (count >=3 ){unsigned count2 =count >10 ?10 :count ;if (!size_only ){ZOPFLI_APPEND_DATA (17 ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (count2 -3 ,&rle_bits ,&rle_bits_size );}clcounts [17 ]++;count -=count2 ;}}}/* Repetitions of any symbol */ if (use_16 &&count >=4 ){count --;/* Since the first one is hardcoded. */ clcounts [symbol ]++;if (!size_only ){ZOPFLI_APPEND_DATA (symbol ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (0 ,&rle_bits ,&rle_bits_size );}while (count >=3 ){unsigned count2 =count >6 ?6 :count ;if (!size_only ){ZOPFLI_APPEND_DATA (16 ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (count2 -3 ,&rle_bits ,&rle_bits_size );}clcounts [16 ]++;count -=count2 ;}}/* No or insufficient repetition */ clcounts [symbol ]+=count ;while (count >0 ){if (!size_only ){ZOPFLI_APPEND_DATA (symbol ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (0 ,&rle_bits ,&rle_bits_size );}count --;}}ZopfliCalculateBitLengths (clcounts ,19 ,7 ,clcl );if (!size_only )ZopfliLengthsToSymbols (clcl ,19 ,7 ,clsymbols );hclen =15 ;/* Trim zeros. */ while (hclen >0 &&clcounts [order [hclen +4 -1 ]]==0 )hclen --;if (!size_only ){AddBits (hlit ,5 ,bp ,out ,outsize );AddBits (hdist ,5 ,bp ,out ,outsize );AddBits (hclen ,4 ,bp ,out ,outsize );for (i =0 ;i <hclen +4 ;i ++){AddBits (clcl [order [i ]],3 ,bp ,out ,outsize );}for (i =0 ;i <rle_size ;i ++){unsigned symbol =clsymbols [rle [i ]];AddHuffmanBits (symbol ,clcl [rle [i ]],bp ,out ,outsize );/* Extra bits. */ if (rle [i ]==16 )AddBits (rle_bits [i ],2 ,bp ,out ,outsize );else if (rle [i ]==17 )AddBits (rle_bits [i ],3 ,bp ,out ,outsize );else if (rle [i ]==18 )AddBits (rle_bits [i ],7 ,bp ,out ,outsize );}}result_size +=14 ;/* hlit, hdist, hclen bits */ result_size +=(hclen +4 )*3 ;/* clcl bits */ for (i =0 ;i <19 ;i ++){result_size +=clcl [i ]*clcounts [i ];}/* Extra bits. */ result_size +=clcounts [16 ]*2 ;result_size +=clcounts [17 ]*3 ;result_size +=clcounts [18 ]*7 ;/* Note: in case of \"size_only\" these are null pointers so no effect. */ free (rle );free (rle_bits );return result_size ;}",
                "rust_signature": "pub fn encode_tree(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    use_16: bool,\n    use_17: bool,\n    use_18: bool,\n    bp: &mut u8,\n    out: Option<&mut Vec<u8>>,\n    outsize: &mut usize,\n) -> usize {\n    // Function body placeholder\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "CalculateTreeSize(const unsigned int *, const unsigned int *)": {
                "signature": "size_t CalculateTreeSize(const unsigned int *, const unsigned int *)",
                "description": "/*\nGives the exact size of the tree, in bits, as it will be encoded in DEFLATE.\n*/",
                "dependencies": {
                    "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateTreeSize (const unsigned *ll_lengths ,const unsigned *d_lengths ){size_t result =0 ;int i ;for (i =0 ;i <8 ;i ++){size_t size =EncodeTree (ll_lengths ,d_lengths ,i &1 ,i &2 ,i &4 ,0 ,0 ,0 );if (result ==0 ||size <result )result =size ;}return result ;}",
                "rust_signature": "pub fn calculate_tree_size(ll_lengths: &[u32], d_lengths: &[u32]) -> usize {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "PatchDistanceCodesForBuggyDecoders(unsigned int *)": {
                "signature": "void PatchDistanceCodesForBuggyDecoders(unsigned int *)",
                "description": "/*\nEnsures there are at least 2 distance codes to support buggy decoders.\nZlib 1.2.1 and below have a bug where it fails if there isn't at least 1\ndistance code (with length > 0), even though it's valid according to the\ndeflate spec to have 0 distance codes. On top of that, some mobile phones\nrequire at least two distance codes. To support these decoders too (but\npotentially at the cost of a few bytes), add dummy code lengths of 1.\nReferences to this bug can be found in the changelog of\nZlib 1.2.2 and here: http://www.jonof.id.au/forum/index.php?topic=515.0.\n\nd_lengths: the 32 lengths of the distance codes.\n*/",
                "dependencies": {},
                "full_text": "static void PatchDistanceCodesForBuggyDecoders (unsigned *d_lengths ){int num_dist_codes =0 ;/* Amount of non-zero distance codes */ int i ;for (i =0 ;i <30 /* Ignore the two unused codes from the spec */ ;i ++){if (d_lengths [i ])num_dist_codes ++;if (num_dist_codes >=2 )return ;/* Two or more codes is fine. */ }if (num_dist_codes ==0 ){d_lengths [0 ]=d_lengths [1 ]=1 ;}else if (num_dist_codes ==1 ){d_lengths [d_lengths [0 ]?1 :0 ]=1 ;}}",
                "rust_signature": "fn patch_distance_codes_for_buggy_decoders(d_lengths: &mut [u32; 30]) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)": {
                "signature": "double TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)",
                "description": "/*\nTries out OptimizeHuffmanForRle for this block, if the result is smaller,\nuses it, otherwise keeps the original. Returns size of encoded tree and data in\nbits, not including the 3-bit block header.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CalculateTreeSize(const unsigned int *, const unsigned int *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateTreeSize(const unsigned int *, const unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::OptimizeHuffmanForRle(int, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::OptimizeHuffmanForRle(int, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "static double TryOptimizeHuffmanForRle (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,const size_t *ll_counts ,const size_t *d_counts ,unsigned *ll_lengths ,unsigned *d_lengths ){size_t ll_counts2 [ZOPFLI_NUM_LL ];size_t d_counts2 [ZOPFLI_NUM_D ];unsigned ll_lengths2 [ZOPFLI_NUM_LL ];unsigned d_lengths2 [ZOPFLI_NUM_D ];double treesize ;double datasize ;double treesize2 ;double datasize2 ;treesize =CalculateTreeSize (ll_lengths ,d_lengths );datasize =CalculateBlockSymbolSizeGivenCounts (ll_counts ,d_counts ,ll_lengths ,d_lengths ,lz77 ,lstart ,lend );memcpy (ll_counts2 ,ll_counts ,sizeof (ll_counts2 ));memcpy (d_counts2 ,d_counts ,sizeof (d_counts2 ));OptimizeHuffmanForRle (ZOPFLI_NUM_LL ,ll_counts2 );OptimizeHuffmanForRle (ZOPFLI_NUM_D ,d_counts2 );ZopfliCalculateBitLengths (ll_counts2 ,ZOPFLI_NUM_LL ,15 ,ll_lengths2 );ZopfliCalculateBitLengths (d_counts2 ,ZOPFLI_NUM_D ,15 ,d_lengths2 );PatchDistanceCodesForBuggyDecoders (d_lengths2 );treesize2 =CalculateTreeSize (ll_lengths2 ,d_lengths2 );datasize2 =CalculateBlockSymbolSizeGivenCounts (ll_counts ,d_counts ,ll_lengths2 ,d_lengths2 ,lz77 ,lstart ,lend );if (treesize2 +datasize2 <treesize +datasize ){memcpy (ll_lengths ,ll_lengths2 ,sizeof (ll_lengths2 ));memcpy (d_lengths ,d_lengths2 ,sizeof (d_lengths2 ));return treesize2 +datasize2 ;}return treesize +datasize ;}",
                "rust_signature": "pub fn try_optimize_huffman_for_rle(\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    ll_counts: &[usize],\n    d_counts: &[usize],\n    ll_lengths: &mut [u32; ZOPFLI_NUM_LL],\n    d_lengths: &mut [u32; ZOPFLI_NUM_D]\n) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)": {
                "signature": "void ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)",
                "description": "/* Gets the histogram of lit/len and dist symbols in the given range, using the\ncumulative histograms, so faster than adding one by one for large range. Does\nnot add the one end symbol of value 256. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "static void ZopfliLZ77GetHistogramAt (const ZopfliLZ77Store *lz77 ,size_t lpos ,size_t *ll_counts ,size_t *d_counts ){/* The real histogram is created by using the histogram for this chunk, but\n    all superfluous values of this chunk subtracted. */ size_t llpos =ZOPFLI_NUM_LL *(lpos /ZOPFLI_NUM_LL );size_t dpos =ZOPFLI_NUM_D *(lpos /ZOPFLI_NUM_D );size_t i ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){ll_counts [i ]=lz77 ->ll_counts [llpos +i ];}for (i =lpos +1 ;i <llpos +ZOPFLI_NUM_LL &&i <lz77 ->size ;i ++){ll_counts [lz77 ->ll_symbol [i ]]--;}for (i =0 ;i <ZOPFLI_NUM_D ;i ++){d_counts [i ]=lz77 ->d_counts [dpos +i ];}for (i =lpos +1 ;i <dpos +ZOPFLI_NUM_D &&i <lz77 ->size ;i ++){if (lz77 ->dists [i ]!=0 )d_counts [lz77 ->d_symbol [i ]]--;}}",
                "rust_signature": "fn zopfli_lz77_get_histogram_at(\n    lz77: &ZopfliLZ77Store,\n    lpos: usize,\n    ll_counts: &mut [usize],\n    d_counts: &mut [usize],\n) {\n    // The real histogram is created by using the histogram for this chunk, but\n    // all superfluous values of this chunk subtracted.\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)": {
                "signature": "double GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)",
                "description": "/*\nCalculates the bit lengths for the symbols for dynamic blocks. Chooses bit\nlengths that give the smallest size of tree encoding + encoding of all the\nsymbols to have smallest output size. This are not necessarily the ideal Huffman\nbit lengths. Returns size of encoded tree and data in bits, not including the\n3-bit block header.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetDynamicLengths (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,unsigned *ll_lengths ,unsigned *d_lengths ){size_t ll_counts [ZOPFLI_NUM_LL ];size_t d_counts [ZOPFLI_NUM_D ];ZopfliLZ77GetHistogram (lz77 ,lstart ,lend ,ll_counts ,d_counts );ll_counts [256 ]=1 ;/* End symbol. */ ZopfliCalculateBitLengths (ll_counts ,ZOPFLI_NUM_LL ,15 ,ll_lengths );ZopfliCalculateBitLengths (d_counts ,ZOPFLI_NUM_D ,15 ,d_lengths );PatchDistanceCodesForBuggyDecoders (d_lengths );return TryOptimizeHuffmanForRle (lz77 ,lstart ,lend ,ll_counts ,d_counts ,ll_lengths ,d_lengths );}",
                "rust_signature": "pub fn get_dynamic_lengths(\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    ll_lengths: &mut [u32; ZOPFLI_NUM_LL],\n    d_lengths: &mut [u32; ZOPFLI_NUM_D]\n) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "GetFixedTree(unsigned int *, unsigned int *)": {
                "signature": "void GetFixedTree(unsigned int *, unsigned int *)",
                "description": "",
                "dependencies": {},
                "full_text": "static void GetFixedTree (unsigned *ll_lengths ,unsigned *d_lengths ){size_t i ;for (i =0 ;i <144 ;i ++)ll_lengths [i ]=8 ;for (i =144 ;i <256 ;i ++)ll_lengths [i ]=9 ;for (i =256 ;i <280 ;i ++)ll_lengths [i ]=7 ;for (i =280 ;i <288 ;i ++)ll_lengths [i ]=8 ;for (i =0 ;i <32 ;i ++)d_lengths [i ]=5 ;}",
                "rust_signature": "fn get_fixed_tree(ll_lengths: &mut [u32; 288], d_lengths: &mut [u32; 32]) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nCalculates size of the part after the header and tree of an LZ77 block, in bits.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateBlockSymbolSize (const unsigned *ll_lengths ,const unsigned *d_lengths ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){if (lstart +ZOPFLI_NUM_LL *3 >lend ){return CalculateBlockSymbolSizeSmall (ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}else {size_t ll_counts [ZOPFLI_NUM_LL ];size_t d_counts [ZOPFLI_NUM_D ];ZopfliLZ77GetHistogram (lz77 ,lstart ,lend ,ll_counts ,d_counts );return CalculateBlockSymbolSizeGivenCounts (ll_counts ,d_counts ,ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}}",
                "rust_signature": "pub fn calculate_block_symbol_size(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize\n) -> usize {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "EstimateCost(const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "double EstimateCost(const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nReturns estimated cost of a block in bits.  It includes the size to encode the\ntree and the size to encode all literal, length and distance symbols and their\nextra bits.\n\nlitlens: lz77 lit/lengths\ndists: ll77 distances\nlstart: start of block\nlend: end of block (not inclusive)\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static double EstimateCost (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){return ZopfliCalculateBlockSizeAutoType (lz77 ,lstart ,lend );}",
                "rust_signature": "fn estimate_cost(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize) -> f64 {\n    // Placeholder implementation. Original C code calls ZopfliCalculateBlockSizeAutoType.\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "SplitCost(size_t, void *)": {
                "signature": "double SplitCost(size_t, void *)",
                "description": "/*\nGets the cost which is the sum of the cost of the left and the right section\nof the data.\ntype: FindMinimumFun\n*/",
                "dependencies": {
                    "zopfli::SplitCostContext": {
                        "return_type": "SplitCostContext",
                        "qualified_name": "zopfli::SplitCostContext",
                        "type": "structs"
                    },
                    "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static double SplitCost (size_t i ,void *context ){SplitCostContext *c =(SplitCostContext *)context ;return EstimateCost (c ->lz77 ,c ->start ,i )+EstimateCost (c ->lz77 ,i ,c ->end );}",
                "rust_signature": "fn split_cost(i: usize, context: *mut std::ffi::c_void) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliGetLengthExtraBits(int)": {
                "signature": "int ZopfliGetLengthExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given length, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthExtraBits (int l ){static const int table [259 ]={0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,0 };return table [l ];}",
                "rust_signature": "fn zopfli_get_length_extra_bits(l: usize) -> i32 {\n    todo!(\"Function implementation is not provided.\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliGetDistExtraBits(int)": {
                "signature": "int ZopfliGetDistExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given dist, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistExtraBits (int dist ){if (dist <5 )return 0 ;return (31 ^__builtin_clz (dist -1 ))-1 ;/* log2(dist - 1) - 1 */ }",
                "rust_signature": "pub fn zopfli_get_dist_extra_bits(dist: i32) -> i32 {\n    // 原始C代码逻辑未实现，仅提供函数签名\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "GetCostStat(unsigned int, unsigned int, void *)": {
                "signature": "double GetCostStat(unsigned int, unsigned int, void *)",
                "description": "/*\nCost model based on symbol statistics.\ntype: CostModelFun\n*/",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetCostStat (unsigned litlen ,unsigned dist ,void *context ){SymbolStats *stats =(SymbolStats *)context ;if (dist ==0 ){return stats ->ll_symbols [litlen ];}else {int lsym =ZopfliGetLengthSymbol (litlen );int lbits =ZopfliGetLengthExtraBits (litlen );int dsym =ZopfliGetDistSymbol (dist );int dbits =ZopfliGetDistExtraBits (dist );return lbits +dbits +stats ->ll_symbols [lsym ]+stats ->d_symbols [dsym ];}}",
                "rust_signature": "pub unsafe fn get_cost_stat(litlen: u32, dist: u32, context: *mut std::ffi::c_void) -> f64 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "GetCostFixed(unsigned int, unsigned int, void *)": {
                "signature": "double GetCostFixed(unsigned int, unsigned int, void *)",
                "description": "/*\nCost model which should exactly match fixed tree.\ntype: CostModelFun\n*/",
                "dependencies": {
                    "zopfli::ZopfliGetDistExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetCostFixed (unsigned litlen ,unsigned dist ,void *unused ){(void )unused ;if (dist ==0 ){if (litlen <=143 )return 8 ;else return 9 ;}else {int dbits =ZopfliGetDistExtraBits (dist );int lbits =ZopfliGetLengthExtraBits (litlen );int lsym =ZopfliGetLengthSymbol (litlen );int cost =0 ;if (lsym <=279 )cost +=7 ;else cost +=8 ;cost +=5 ;/* Every dist symbol has length 5. */ return cost +dbits +lbits ;}}",
                "rust_signature": "pub fn get_cost_fixed(litlen: u32, dist: u32, unused: *mut std::ffi::c_void) -> f64 {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "AddBit(int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddBit(int, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nbp = bitpointer, always in range [0, 7].\nThe outsize is number of necessary bytes to encode the bits.\nGiven the value of bp and the amount of bytes, the amount of bits represented\nis not simply bytesize * 8 + bp because even representing one bit requires a\nwhole byte. It is: (bp == 0) ? (bytesize * 8) : ((bytesize - 1) * 8 + bp)\n*/",
                "dependencies": {},
                "full_text": "static void AddBit (int bit ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){if (*bp ==0 )ZOPFLI_APPEND_DATA (0 ,out ,outsize );(*out )[*outsize -1 ]|=bit <<*bp ;*bp =(*bp +1 )&7 ;}",
                "rust_signature": "pub fn add_bit(bit: i32, bp: &mut u8, out: &mut Vec<u8>, outsize: &mut usize) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/* Since an uncompressed block can be max 65535 in size, it actually adds\nmultible blocks if needed. */",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddNonCompressedBlock (const ZopfliOptions *options ,int final ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t pos =instart ;(void )options ;for (;;){size_t i ;unsigned short blocksize =65535 ;unsigned short nlen ;int currentfinal ;if (pos +blocksize >inend )blocksize =inend -pos ;currentfinal =pos +blocksize >=inend ;nlen =~blocksize ;AddBit (final &&currentfinal ,bp ,out ,outsize );/* BTYPE 00 */ AddBit (0 ,bp ,out ,outsize );AddBit (0 ,bp ,out ,outsize );/* Any bits of input up to the next byte boundary are ignored. */ *bp =0 ;ZOPFLI_APPEND_DATA (blocksize %256 ,out ,outsize );ZOPFLI_APPEND_DATA ((blocksize /256 )%256 ,out ,outsize );ZOPFLI_APPEND_DATA (nlen %256 ,out ,outsize );ZOPFLI_APPEND_DATA ((nlen /256 )%256 ,out ,outsize );for (i =0 ;i <blocksize ;i ++){ZOPFLI_APPEND_DATA (in [pos +i ],out ,outsize );}if (currentfinal )break ;pos +=blocksize ;}}",
                "rust_signature": "pub fn add_non_compressed_block(\n    options: &ZopfliOptions,\n    final_block: i32,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    bp: &mut u8,\n    out: &mut Vec<u8>,\n    outsize: &mut usize,\n) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliGetLengthExtraBitsValue(int)": {
                "signature": "int ZopfliGetLengthExtraBitsValue(int)",
                "description": "/* Gets value of the extra bits for the given length, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthExtraBitsValue (int l ){static const int table [259 ]={0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,1 ,0 ,1 ,0 ,1 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,31 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,31 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,31 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,0 };return table [l ];}",
                "rust_signature": "fn zopfli_get_length_extra_bits_value(l: usize) -> Option<i32> {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliGetDistExtraBitsValue(int)": {
                "signature": "int ZopfliGetDistExtraBitsValue(int)",
                "description": "/* Gets value of the extra bits for the given dist, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistExtraBitsValue (int dist ){if (dist <5 ){return 0 ;}else {int l =31 ^__builtin_clz (dist -1 );/* log2(dist - 1) */ return (dist -(1 +(1 <<l )))&((1 <<(l -1 ))-1 );}}",
                "rust_signature": "pub fn zopfli_get_dist_extra_bits_value(dist: i32) -> i32 {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nAdds all lit/len and dist codes from the lists as huffman symbols. Does not add\nend code 256. expected_data_size is the uncompressed block size, used for\nassert, but you can set it to 0 to not do the assertion.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBitsValue(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBitsValue(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistExtraBitsValue(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBitsValue(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddLZ77Data (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t expected_data_size ,const unsigned *ll_symbols ,const unsigned *ll_lengths ,const unsigned *d_symbols ,const unsigned *d_lengths ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t testlength =0 ;size_t i ;for (i =lstart ;i <lend ;i ++){unsigned dist =lz77 ->dists [i ];unsigned litlen =lz77 ->litlens [i ];if (dist ==0 ){assert (litlen <256 );assert (ll_lengths [litlen ]>0 );AddHuffmanBits (ll_symbols [litlen ],ll_lengths [litlen ],bp ,out ,outsize );testlength ++;}else {unsigned lls =ZopfliGetLengthSymbol (litlen );unsigned ds =ZopfliGetDistSymbol (dist );assert (litlen >=3 &&litlen <=288 );assert (ll_lengths [lls ]>0 );assert (d_lengths [ds ]>0 );AddHuffmanBits (ll_symbols [lls ],ll_lengths [lls ],bp ,out ,outsize );AddBits (ZopfliGetLengthExtraBitsValue (litlen ),ZopfliGetLengthExtraBits (litlen ),bp ,out ,outsize );AddHuffmanBits (d_symbols [ds ],d_lengths [ds ],bp ,out ,outsize );AddBits (ZopfliGetDistExtraBitsValue (dist ),ZopfliGetDistExtraBits (dist ),bp ,out ,outsize );testlength +=litlen ;}}assert (expected_data_size ==0 ||testlength ==expected_data_size );}",
                "rust_signature": "pub fn add_lz77_data(\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    ll_symbols: &[u32],\n    ll_lengths: &[u32],\n    d_symbols: &[u32],\n    d_lengths: &[u32],\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    // Function body intentionally left unimplemented\n    unimplemented!();\n}\n",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                "description": "",
                "dependencies": {
                    "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddDynamicTree (const unsigned *ll_lengths ,const unsigned *d_lengths ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){int i ;int best =0 ;size_t bestsize =0 ;for (i =0 ;i <8 ;i ++){size_t size =EncodeTree (ll_lengths ,d_lengths ,i &1 ,i &2 ,i &4 ,0 ,0 ,0 );if (bestsize ==0 ||size <bestsize ){bestsize =size ;best =i ;}}EncodeTree (ll_lengths ,d_lengths ,best &1 ,best &2 ,best &4 ,bp ,out ,outsize );}",
                "rust_signature": "pub fn add_dynamic_tree(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    bp: &mut u8,\n    out: &mut *mut u8,\n    outsize: &mut usize,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nAdds a deflate block with the given LZ77 data to the output.\noptions: global program options\nbtype: the block type, must be 1 or 2\nfinal: whether to set the \"final\" bit on this block, must be the last block\nlitlens: literal/length array of the LZ77 data, in the same format as in\nZopfliLZ77Store.\ndists: distance array of the LZ77 data, in the same format as in\nZopfliLZ77Store.\nlstart: where to start in the LZ77 data\nlend: where to end in the LZ77 data (not inclusive)\nexpected_data_size: the uncompressed block size, used for assert, but you can\nset it to 0 to not do the assertion.\nbp: output bit pointer\nout: dynamic output array to append to\noutsize: dynamic output array size\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::GetFixedTree(unsigned int *, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::GetFixedTree(unsigned int *, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddLZ77Block (const ZopfliOptions *options ,int btype ,int final ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t expected_data_size ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){unsigned ll_lengths [ZOPFLI_NUM_LL ];unsigned d_lengths [ZOPFLI_NUM_D ];unsigned ll_symbols [ZOPFLI_NUM_LL ];unsigned d_symbols [ZOPFLI_NUM_D ];size_t detect_block_size =*outsize ;size_t compressed_size ;size_t uncompressed_size =0 ;size_t i ;if (btype ==0 ){size_t length =ZopfliLZ77GetByteRange (lz77 ,lstart ,lend );size_t pos =lstart ==lend ?0 :lz77 ->pos [lstart ];size_t end =pos +length ;AddNonCompressedBlock (options ,final ,lz77 ->data ,pos ,end ,bp ,out ,outsize );return ;}AddBit (final ,bp ,out ,outsize );AddBit (btype &1 ,bp ,out ,outsize );AddBit ((btype &2 )>>1 ,bp ,out ,outsize );if (btype ==1 ){/* Fixed block. */ GetFixedTree (ll_lengths ,d_lengths );}else {/* Dynamic block. */ unsigned detect_tree_size ;assert (btype ==2 );GetDynamicLengths (lz77 ,lstart ,lend ,ll_lengths ,d_lengths );detect_tree_size =*outsize ;AddDynamicTree (ll_lengths ,d_lengths ,bp ,out ,outsize );if (options ->verbose ){fprintf (stderr ,\"treesize: %d\\n\" ,(int )(*outsize -detect_tree_size ));}}ZopfliLengthsToSymbols (ll_lengths ,ZOPFLI_NUM_LL ,15 ,ll_symbols );ZopfliLengthsToSymbols (d_lengths ,ZOPFLI_NUM_D ,15 ,d_symbols );detect_block_size =*outsize ;AddLZ77Data (lz77 ,lstart ,lend ,expected_data_size ,ll_symbols ,ll_lengths ,d_symbols ,d_lengths ,bp ,out ,outsize );/* End symbol. */ AddHuffmanBits (ll_symbols [256 ],ll_lengths [256 ],bp ,out ,outsize );for (i =lstart ;i <lend ;i ++){uncompressed_size +=lz77 ->dists [i ]==0 ?1 :lz77 ->litlens [i ];}compressed_size =*outsize -detect_block_size ;if (options ->verbose ){fprintf (stderr ,\"compressed block size: %d (%dk) (unc: %d)\\n\" ,(int )compressed_size ,(int )(compressed_size /1024 ),(int )(uncompressed_size ));}}",
                "rust_signature": "pub fn add_lz77_block(\n    options: *const ZopfliOptions,\n    btype: i32,\n    final_block: i32,\n    lz77: *const ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    bp: *mut u8,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)": {
                "signature": "void StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)",
                "description": "/*\nStores the found sublen, distance and length in the longest match cache, if\npossible.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void StoreInLongestMatchCache (ZopfliBlockState *s ,size_t pos ,size_t limit ,const unsigned short *sublen ,unsigned short distance ,unsigned short length ){/* The LMC cache starts at the beginning of the block rather than the\n       beginning of the whole array. */ size_t lmcpos =pos -s ->blockstart ;/* Length > 0 and dist 0 is invalid combination, which indicates on purpose\n       that this cache value is not filled in yet. */ unsigned char cache_available =s ->lmc &&(s ->lmc ->length [lmcpos ]==0 ||s ->lmc ->dist [lmcpos ]!=0 );if (s ->lmc &&limit ==ZOPFLI_MAX_MATCH &&sublen &&!cache_available ){assert (s ->lmc ->length [lmcpos ]==1 &&s ->lmc ->dist [lmcpos ]==0 );s ->lmc ->dist [lmcpos ]=length <ZOPFLI_MIN_MATCH ?0 :distance ;s ->lmc ->length [lmcpos ]=length <ZOPFLI_MIN_MATCH ?0 :length ;assert (!(s ->lmc ->length [lmcpos ]==1 &&s ->lmc ->dist [lmcpos ]==0 ));ZopfliSublenToCache (sublen ,lmcpos ,length ,s ->lmc );}}",
                "rust_signature": "pub fn store_in_longest_match_cache(\n    s: &mut ZopfliBlockState,\n    pos: usize,\n    limit: usize,\n    sublen: Option<&[u16]>,\n    distance: u16,\n    length: u16,\n) {\n    todo!(\"Function body not implemented. Placeholder for StoreInLongestMatchCache logic.\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)": {
                "signature": "int TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)",
                "description": "/*\nGets distance, length and sublen values from the cache if possible.\nReturns 1 if it got the values from the cache, 0 if not.\nUpdates the limit value to a smaller one if possible with more limited\ninformation from the cache.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)",
                        "type": "functions"
                    }
                },
                "full_text": "static int TryGetFromLongestMatchCache (ZopfliBlockState *s ,size_t pos ,size_t *limit ,unsigned short *sublen ,unsigned short *distance ,unsigned short *length ){/* The LMC cache starts at the beginning of the block rather than the\n       beginning of the whole array. */ size_t lmcpos =pos -s ->blockstart ;/* Length > 0 and dist 0 is invalid combination, which indicates on purpose\n       that this cache value is not filled in yet. */ unsigned char cache_available =s ->lmc &&(s ->lmc ->length [lmcpos ]==0 ||s ->lmc ->dist [lmcpos ]!=0 );unsigned char limit_ok_for_cache =cache_available &&(*limit ==ZOPFLI_MAX_MATCH ||s ->lmc ->length [lmcpos ]<=*limit ||(sublen &&ZopfliMaxCachedSublen (s ->lmc ,lmcpos ,s ->lmc ->length [lmcpos ])>=*limit ));if (s ->lmc &&limit_ok_for_cache &&cache_available ){if (!sublen ||s ->lmc ->length [lmcpos ]<=ZopfliMaxCachedSublen (s ->lmc ,lmcpos ,s ->lmc ->length [lmcpos ])){*length =s ->lmc ->length [lmcpos ];if (*length >*limit )*length =*limit ;if (sublen ){ZopfliCacheToSublen (s ->lmc ,lmcpos ,*length ,sublen );*distance =sublen [*length ];if (*limit ==ZOPFLI_MAX_MATCH &&*length >=ZOPFLI_MIN_MATCH ){assert (sublen [*length ]==s ->lmc ->dist [lmcpos ]);}}else {*distance =s ->lmc ->dist [lmcpos ];}return 1 ;}/* Can't use much of the cache, since the \"sublens\" need to be calculated,\n           but at  least we already know when to stop. */ *limit =s ->lmc ->length [lmcpos ];}return 0 ;}",
                "rust_signature": "fn try_get_from_longest_match_cache(\n    s: &ZopfliBlockState,\n    pos: usize,\n    limit: &mut usize,\n    sublen: Option<&mut [u16]>,\n    distance: &mut u16,\n    length: &mut u16,\n) -> i32 {\n    // The function body is not implemented.\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)": {
                "signature": "const unsigned char * GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)",
                "description": "/*\nFinds how long the match of scan and match is. Can be used to find how many\nbytes starting from scan, and from match, are equal. Returns the last byte\nafter scan, which is still equal to the correspondinb byte after match.\nscan is the position to compare\nmatch is the earlier position to compare.\nend is the last possible byte, beyond which to stop looking.\nsafe_end is a few (8) bytes before end, for comparing multiple bytes at once.\n*/",
                "dependencies": {},
                "full_text": "static const unsigned char *GetMatch (const unsigned char *scan ,const unsigned char *match ,const unsigned char *end ,const unsigned char *safe_end ){if (sizeof (size_t )==8 ){/* 8 checks at once per array bounds check (size_t is 64-bit). */ while (scan <safe_end &&*((size_t *)scan )==*((size_t *)match )){scan +=8 ;match +=8 ;}}else if (sizeof (unsigned int )==4 ){/* 4 checks at once per array bounds check (unsigned int is 32-bit). */ while (scan <safe_end &&*((unsigned int *)scan )==*((unsigned int *)match )){scan +=4 ;match +=4 ;}}else {/* do 8 checks at once per array bounds check. */ while (scan <safe_end &&*scan ==*match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match ){scan ++;match ++;}}/* The remaining few bytes. */ while (scan !=end &&*scan ==*match ){scan ++;match ++;}return scan ;}",
                "rust_signature": "pub fn get_match(scan: *const u8, match_: *const u8, end: *const u8, safe_end: *const u8) -> *const u8 {\n    // Function body intentionally left unimplemented\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "UpdateHashValue(ZopfliHash *, unsigned char)": {
                "signature": "void UpdateHashValue(ZopfliHash *, unsigned char)",
                "description": "/*\nUpdate the sliding hash value with the given byte. All calls to this function\nmust be made on consecutive input characters. Since the hash value exists out\nof multiple input bytes, a few warmups with this function are needed initially.\n*/",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::HASH_MASK": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::HASH_MASK",
                        "type": "defines"
                    },
                    "zopfli::HASH_SHIFT": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::HASH_SHIFT",
                        "type": "defines"
                    }
                },
                "full_text": "static void UpdateHashValue (ZopfliHash *h ,unsigned char c ){h ->val =(((h ->val )<<HASH_SHIFT )^(c ))&HASH_MASK ;}",
                "rust_signature": "fn update_hash_value(h: *mut ZopfliHash, c: u8) { unimplemented!() }",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                "signature": "void FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliResetHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliResetHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void FollowPath (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned short *path ,size_t pathsize ,ZopfliLZ77Store *store ,ZopfliHash *h ){size_t i ,j ,pos =0 ;size_t windowstart =instart >ZOPFLI_WINDOW_SIZE ?instart -ZOPFLI_WINDOW_SIZE :0 ;size_t total_length_test =0 ;if (instart ==inend )return ;ZopfliResetHash (ZOPFLI_WINDOW_SIZE ,h );ZopfliWarmupHash (in ,windowstart ,inend ,h );for (i =windowstart ;i <instart ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );}pos =instart ;for (i =0 ;i <pathsize ;i ++){unsigned short length =path [i ];unsigned short dummy_length ;unsigned short dist ;assert (pos <inend );ZopfliUpdateHash (in ,pos ,inend ,h );/* Add to output. */ if (length >=ZOPFLI_MIN_MATCH ){/* Get the distance by recalculating longest match. The found length\n            should match the length from the path. */ ZopfliFindLongestMatch (s ,h ,in ,pos ,inend ,length ,0 ,&dist ,&dummy_length );assert (!(dummy_length !=length &&length >2 &&dummy_length >2 ));ZopfliVerifyLenDist (in ,inend ,pos ,dist ,length );ZopfliStoreLitLenDist (length ,dist ,pos ,store );total_length_test +=length ;}else {length =1 ;ZopfliStoreLitLenDist (in [pos ],0 ,pos ,store );total_length_test ++;}assert (pos +length <=inend );for (j =1 ;j <length ;j ++){ZopfliUpdateHash (in ,pos +j ,inend ,h );}pos +=length ;}}",
                "rust_signature": "pub unsafe fn follow_path(\n    s: &mut ZopfliBlockState,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    path: &[u16],\n    store: &mut ZopfliLZ77Store,\n    h: &mut ZopfliHash,\n) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)": {
                "signature": "void TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)",
                "description": "/*\nCalculates the optimal path of lz77 lengths to use, from the calculated\nlength_array. The length_array must contain the optimal length to reach that\nbyte. The path will be filled with the lengths to use, so its data size will be\nthe amount of lz77 symbols.\n*/",
                "dependencies": {},
                "full_text": "static void TraceBackwards (size_t size ,const unsigned short *length_array ,unsigned short **path ,size_t *pathsize ){size_t index =size ;if (size ==0 )return ;for (;;){ZOPFLI_APPEND_DATA (length_array [index ],path ,pathsize );assert (length_array [index ]<=index );assert (length_array [index ]<=ZOPFLI_MAX_MATCH );assert (length_array [index ]!=0 );index -=length_array [index ];if (index ==0 )break ;}/* Mirror result. */ for (index =0 ;index <*pathsize /2 ;index ++){unsigned short temp =(*path )[index ];(*path )[index ]=(*path )[*pathsize -index -1 ];(*path )[*pathsize -index -1 ]=temp ;}}",
                "rust_signature": "pub fn trace_backwards(size: usize, length_array: &[u16], path: &mut *mut u16, pathsize: &mut usize) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "zopfli_min(size_t, size_t)": {
                "signature": "size_t zopfli_min(size_t, size_t)",
                "description": "",
                "dependencies": {},
                "full_text": "static size_t zopfli_min (size_t a ,size_t b ){return a <b ?a :b ;}",
                "rust_signature": "fn zopfli_min(a: usize, b: usize) -> usize { unimplemented!() }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "GetCostModelMinCost(CostModelFun *, void *)": {
                "signature": "double GetCostModelMinCost(CostModelFun *, void *)",
                "description": "/*\nFinds the minimum possible cost this cost model can return for valid length and\ndistance symbols.\n*/",
                "dependencies": {
                    "zopfli::CostModelFun": {
                        "return_type": "CostModelFun",
                        "qualified_name": "zopfli::CostModelFun",
                        "type": "typedefs"
                    }
                },
                "full_text": "static double GetCostModelMinCost (CostModelFun *costmodel ,void *costcontext ){double mincost ;int bestlength =0 ;/* length that has lowest cost in the cost model */ int bestdist =0 ;/* distance that has lowest cost in the cost model */ int i ;/*\n    Table of distances that have a different distance symbol in the deflate\n    specification. Each value is the first distance that has a new symbol. Only\n    different symbols affect the cost model so only these need to be checked.\n    See RFC 1951 section 3.2.5. Compressed blocks (length and distance codes).\n    */ static const int dsymbols [30 ]={1 ,2 ,3 ,4 ,5 ,7 ,9 ,13 ,17 ,25 ,33 ,49 ,65 ,97 ,129 ,193 ,257 ,385 ,513 ,769 ,1025 ,1537 ,2049 ,3073 ,4097 ,6145 ,8193 ,12289 ,16385 ,24577 };mincost =ZOPFLI_LARGE_FLOAT ;for (i =3 ;i <259 ;i ++){double c =costmodel (i ,1 ,costcontext );if (c <mincost ){bestlength =i ;mincost =c ;}}mincost =ZOPFLI_LARGE_FLOAT ;for (i =0 ;i <30 ;i ++){double c =costmodel (3 ,dsymbols [i ],costcontext );if (c <mincost ){bestdist =dsymbols [i ];mincost =c ;}}return costmodel (bestlength ,bestdist ,costcontext );}",
                "rust_signature": "fn get_cost_model_min_cost(costmodel: CostModelFun, costcontext: Option<*mut core::ffi::c_void>) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)": {
                "signature": "double GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)",
                "description": "/*\nPerforms the forward pass for \"squeeze\". Gets the most optimal length to reach\nevery byte from a previous byte, using cost calculations.\ns: the ZopfliBlockState\nin: the input data array\ninstart: where to start\ninend: where to stop (not inclusive)\ncostmodel: function to calculate the cost of some lit/len/dist pair.\ncostcontext: abstract context for the costmodel function\nlength_array: output array of size (inend - instart) which will receive the best\nlength to reach this byte from a previous byte.\nreturns the cost that was, according to the costmodel, needed to get to the end.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::CostModelFun": {
                        "return_type": "CostModelFun",
                        "qualified_name": "zopfli::CostModelFun",
                        "type": "typedefs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::GetCostModelMinCost(CostModelFun *, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetCostModelMinCost(CostModelFun *, void *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliResetHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliResetHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::zopfli_min(size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::zopfli_min(size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetBestLengths (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,CostModelFun *costmodel ,void *costcontext ,unsigned short *length_array ,ZopfliHash *h ,float *costs ){/* Best cost to get here so far. */ size_t blocksize =inend -instart ;size_t i =0 ,k ,kend ;unsigned short leng ;unsigned short dist ;unsigned short sublen [259 ];size_t windowstart =instart >ZOPFLI_WINDOW_SIZE ?instart -ZOPFLI_WINDOW_SIZE :0 ;double result ;double mincost =GetCostModelMinCost (costmodel ,costcontext );double mincostaddcostj ;if (instart ==inend )return 0 ;ZopfliResetHash (ZOPFLI_WINDOW_SIZE ,h );ZopfliWarmupHash (in ,windowstart ,inend ,h );for (i =windowstart ;i <instart ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );}for (i =1 ;i <blocksize +1 ;i ++)costs [i ]=ZOPFLI_LARGE_FLOAT ;costs [0 ]=0 ;/* Because it's the start. */ length_array [0 ]=0 ;for (i =instart ;i <inend ;i ++){size_t j =i -instart ;/* Index in the costs array and length_array. */ ZopfliUpdateHash (in ,i ,inend ,h );/* If we're in a long repetition of the same character and have more than\n        ZOPFLI_MAX_MATCH characters before and after our position. */ if (h ->same [i &ZOPFLI_WINDOW_MASK ]>ZOPFLI_MAX_MATCH *2 &&i >instart +ZOPFLI_MAX_MATCH +1 &&i +ZOPFLI_MAX_MATCH *2 +1 <inend &&h ->same [(i -ZOPFLI_MAX_MATCH )&ZOPFLI_WINDOW_MASK ]>ZOPFLI_MAX_MATCH ){double symbolcost =costmodel (ZOPFLI_MAX_MATCH ,1 ,costcontext );/* Set the length to reach each one to ZOPFLI_MAX_MATCH, and the cost to\n            the cost corresponding to that length. Doing this, we skip\n            ZOPFLI_MAX_MATCH values to avoid calling ZopfliFindLongestMatch. */ for (k =0 ;k <ZOPFLI_MAX_MATCH ;k ++){costs [j +ZOPFLI_MAX_MATCH ]=costs [j ]+symbolcost ;length_array [j +ZOPFLI_MAX_MATCH ]=ZOPFLI_MAX_MATCH ;i ++;j ++;ZopfliUpdateHash (in ,i ,inend ,h );}}ZopfliFindLongestMatch (s ,h ,in ,i ,inend ,ZOPFLI_MAX_MATCH ,sublen ,&dist ,&leng );/* Literal. */ if (i +1 <=inend ){double newCost =costmodel (in [i ],0 ,costcontext )+costs [j ];assert (newCost >=0 );if (newCost <costs [j +1 ]){costs [j +1 ]=newCost ;length_array [j +1 ]=1 ;}}/* Lengths. */ kend =zopfli_min (leng ,inend -i );mincostaddcostj =mincost +costs [j ];for (k =3 ;k <=kend ;k ++){double newCost ;/* Calling the cost model is expensive, avoid this if we are already at\n            the minimum possible cost that it can return. */ if (costs [j +k ]<=mincostaddcostj )continue ;newCost =costmodel (k ,sublen [k ],costcontext )+costs [j ];assert (newCost >=0 );if (newCost <costs [j +k ]){assert (k <=ZOPFLI_MAX_MATCH );costs [j +k ]=newCost ;length_array [j +k ]=k ;}}}assert (costs [blocksize ]>=0 );result =costs [blocksize ];return result ;}",
                "rust_signature": "pub fn get_best_lengths(\n    s: &mut ZopfliBlockState,\n    input: Option<&[u8]>,\n    instart: usize,\n    inend: usize,\n    costmodel: CostModelFun,\n    costcontext: Option<*mut core::ffi::c_void>,\n    length_array: Option<&mut [u16]>,\n    h: &mut ZopfliHash,\n    costs: Option<&mut [f32]>,\n) -> f64 {\n    // Best cost to get here so far.\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)": {
                "signature": "double LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)",
                "description": "/*\nDoes a single run for ZopfliLZ77Optimal. For good compression, repeated runs\nwith updated statistics should be performed.\ns: the block state\nin: the input data array\ninstart: where to start\ninend: where to stop (not inclusive)\npath: pointer to dynamically allocated memory to store the path\npathsize: pointer to the size of the dynamic path array\nlength_array: array of size (inend - instart) used to store lengths\ncostmodel: function to use as the cost model for this squeeze run\ncostcontext: abstract context for the costmodel function\nstore: place to output the LZ77 data\nreturns the cost that was, according to the costmodel, needed to get to the end.\nThis is not the actual cost.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::CostModelFun": {
                        "return_type": "CostModelFun",
                        "qualified_name": "zopfli::CostModelFun",
                        "type": "typedefs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)",
                        "type": "functions"
                    },
                    "zopfli::TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "static double LZ77OptimalRun (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned short **path ,size_t *pathsize ,unsigned short *length_array ,CostModelFun *costmodel ,void *costcontext ,ZopfliLZ77Store *store ,ZopfliHash *h ,float *costs ){double cost =GetBestLengths (s ,in ,instart ,inend ,costmodel ,costcontext ,length_array ,h ,costs );free (*path );*path =0 ;*pathsize =0 ;TraceBackwards (inend -instart ,length_array ,path ,pathsize );FollowPath (s ,in ,instart ,inend ,*path ,*pathsize ,store ,h );assert (cost <ZOPFLI_LARGE_FLOAT );return cost ;}",
                "rust_signature": "pub fn lz77_optimal_run(\n    s: &mut ZopfliBlockState,\n    input: Option<&[u8]>,\n    instart: usize,\n    inend: usize,\n    path: &mut Option<Box<[u16]>>,\n    pathsize: &mut usize,\n    length_array: Option<&mut [u16]>,\n    costmodel: CostModelFun,\n    costcontext: Option<*mut core::ffi::c_void>,\n    store: &mut ZopfliLZ77Store,\n    h: &mut ZopfliHash,\n    costs: Option<&mut [f32]>\n) -> f64 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                        "type": "functions"
                    },
                    "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddLZ77BlockAutoType (const ZopfliOptions *options ,int final ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t expected_data_size ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){double uncompressedcost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,0 );double fixedcost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,1 );double dyncost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,2 );/* Whether to perform the expensive calculation of creating an optimal block\n    with fixed huffman tree to check if smaller. Only do this for small blocks or\n    blocks which already are pretty good with fixed huffman tree. */ int expensivefixed =(lz77 ->size <1000 )||fixedcost <=dyncost *1.1 ;ZopfliLZ77Store fixedstore ;if (lstart ==lend ){/* Smallest empty block is represented by fixed block */ AddBits (final ,1 ,bp ,out ,outsize );AddBits (1 ,2 ,bp ,out ,outsize );/* btype 01 */ AddBits (0 ,7 ,bp ,out ,outsize );/* end symbol has code 0000000 */ return ;}ZopfliInitLZ77Store (lz77 ->data ,&fixedstore );if (expensivefixed ){/* Recalculate the LZ77 with ZopfliLZ77OptimalFixed */ size_t instart =lz77 ->pos [lstart ];size_t inend =instart +ZopfliLZ77GetByteRange (lz77 ,lstart ,lend );ZopfliBlockState s ;ZopfliInitBlockState (options ,instart ,inend ,1 ,&s );ZopfliLZ77OptimalFixed (&s ,lz77 ->data ,instart ,inend ,&fixedstore );fixedcost =ZopfliCalculateBlockSize (&fixedstore ,0 ,fixedstore .size ,1 );ZopfliCleanBlockState (&s );}if (uncompressedcost <fixedcost &&uncompressedcost <dyncost ){AddLZ77Block (options ,0 ,final ,lz77 ,lstart ,lend ,expected_data_size ,bp ,out ,outsize );}else if (fixedcost <dyncost ){if (expensivefixed ){AddLZ77Block (options ,1 ,final ,&fixedstore ,0 ,fixedstore .size ,expected_data_size ,bp ,out ,outsize );}else {AddLZ77Block (options ,1 ,final ,lz77 ,lstart ,lend ,expected_data_size ,bp ,out ,outsize );}}else {AddLZ77Block (options ,2 ,final ,lz77 ,lstart ,lend ,expected_data_size ,bp ,out ,outsize );}ZopfliCleanLZ77Store (&fixedstore );}",
                "rust_signature": "pub fn add_lz77_block_auto_type(\n    options: *const ZopfliOptions,\n    final_block: i32,\n    lz77: *const ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    bp: *mut u8,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "GetLengthScore(int, int)": {
                "signature": "int GetLengthScore(int, int)",
                "description": "/*\nGets a score of the length given the distance. Typically, the score of the\nlength is the length itself, but if the distance is very long, decrease the\nscore of the length a bit to make up for the fact that long distances use large\namounts of extra bits.\n\nThis is not an accurate score, it is a heuristic only for the greedy LZ77\nimplementation. More accurate cost models are employed later. Making this\nheuristic more accurate may hurt rather than improve compression.\n\nThe two direct uses of this heuristic are:\n-avoid using a length of 3 in combination with a long distance. This only has\nan effect if length == 3.\n-make a slightly better choice between the two options of the lazy matching.\n\nIndirectly, this affects:\n-the block split points if the default of block splitting first is used, in a\nrather unpredictable way\n-the first zopfli run, so it affects the chance of the first run being closer\nto the optimal output\n*/",
                "dependencies": {},
                "full_text": "static int GetLengthScore (int length ,int distance ){/*\n    At 1024, the distance uses 9+ extra bits and this seems to be the sweet spot\n    on tested files.\n    */ return distance >1024 ?length -1 :length ;}",
                "rust_signature": "pub fn get_length_score(length: i32, distance: i32) -> i32 {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "CalculateStatistics(SymbolStats *)": {
                "signature": "void CalculateStatistics(SymbolStats *)",
                "description": "/* Calculates the entropy of the statistics */",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateEntropy(const size_t *, size_t, double *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateEntropy(const size_t *, size_t, double *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void CalculateStatistics (SymbolStats *stats ){ZopfliCalculateEntropy (stats ->litlens ,ZOPFLI_NUM_LL ,stats ->ll_symbols );ZopfliCalculateEntropy (stats ->dists ,ZOPFLI_NUM_D ,stats ->d_symbols );}",
                "rust_signature": "fn calculate_statistics(stats: &mut SymbolStats) {\n    todo!(\"Implement the function logic\");\n}\n",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "GetStatistics(const ZopfliLZ77Store *, SymbolStats *)": {
                "signature": "void GetStatistics(const ZopfliLZ77Store *, SymbolStats *)",
                "description": "/* Appends the symbol statistics from the store. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::CalculateStatistics(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::CalculateStatistics(SymbolStats *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void GetStatistics (const ZopfliLZ77Store *store ,SymbolStats *stats ){size_t i ;for (i =0 ;i <store ->size ;i ++){if (store ->dists [i ]==0 ){stats ->litlens [store ->litlens [i ]]++;}else {stats ->litlens [ZopfliGetLengthSymbol (store ->litlens [i ])]++;stats ->dists [ZopfliGetDistSymbol (store ->dists [i ])]++;}}stats ->litlens [256 ]=1 ;/* End symbol. */ CalculateStatistics (stats );}",
                "rust_signature": "pub fn get_statistics(store: &ZopfliLZ77Store, stats: &mut SymbolStats) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ClearStatFreqs(SymbolStats *)": {
                "signature": "void ClearStatFreqs(SymbolStats *)",
                "description": "",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void ClearStatFreqs (SymbolStats *stats ){size_t i ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++)stats ->litlens [i ]=0 ;for (i =0 ;i <ZOPFLI_NUM_D ;i ++)stats ->dists [i ]=0 ;}",
                "rust_signature": "pub fn clear_stat_freqs(stats: &mut SymbolStats) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "Ran(RanState *)": {
                "signature": "unsigned int Ran(RanState *)",
                "description": "/* Get random number: \"Multiply-With-Carry\" generator of G. Marsaglia */",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    }
                },
                "full_text": "static unsigned int Ran (RanState *state ){state ->m_z =36969 *(state ->m_z &65535 )+(state ->m_z >>16 );state ->m_w =18000 *(state ->m_w &65535 )+(state ->m_w >>16 );return (state ->m_z <<16 )+state ->m_w ;/* 32-bit result. */ }",
                "rust_signature": "fn ran(state: &mut RanState) -> u32 {\n    // 更新state的m_z和m_w，并返回32位结果\n    // 原始C代码逻辑未实现，仅提供函数签名\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "RandomizeFreqs(RanState *, size_t *, int)": {
                "signature": "void RandomizeFreqs(RanState *, size_t *, int)",
                "description": "",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    },
                    "zopfli::Ran(RanState *)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::Ran(RanState *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void RandomizeFreqs (RanState *state ,size_t *freqs ,int n ){int i ;for (i =0 ;i <n ;i ++){if ((Ran (state )>>4 )%3 ==0 )freqs [i ]=freqs [Ran (state )%n ];}}",
                "rust_signature": "fn randomize_freqs(state: &mut RanState, freqs: &mut [usize], n: i32) {\n    // 原始C代码逻辑未实现，仅提供函数签名\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "RandomizeStatFreqs(RanState *, SymbolStats *)": {
                "signature": "void RandomizeStatFreqs(RanState *, SymbolStats *)",
                "description": "",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    },
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::RandomizeFreqs(RanState *, size_t *, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::RandomizeFreqs(RanState *, size_t *, int)",
                        "type": "functions"
                    }
                },
                "full_text": "static void RandomizeStatFreqs (RanState *state ,SymbolStats *stats ){RandomizeFreqs (state ,stats ->litlens ,ZOPFLI_NUM_LL );RandomizeFreqs (state ,stats ->dists ,ZOPFLI_NUM_D );stats ->litlens [256 ]=1 ;/* End symbol. */ }",
                "rust_signature": "pub fn randomize_stat_freqs(state: &mut RanState, stats: &mut SymbolStats) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "InitRanState(RanState *)": {
                "signature": "void InitRanState(RanState *)",
                "description": "",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    }
                },
                "full_text": "static void InitRanState (RanState *state ){state ->m_w =1 ;state ->m_z =2 ;}",
                "rust_signature": "fn init_ran_state(state: &mut RanState) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)": {
                "signature": "void AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)",
                "description": "/* Adds the bit lengths. */",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void AddWeighedStatFreqs (const SymbolStats *stats1 ,double w1 ,const SymbolStats *stats2 ,double w2 ,SymbolStats *result ){size_t i ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){result ->litlens [i ]=(size_t )(stats1 ->litlens [i ]*w1 +stats2 ->litlens [i ]*w2 );}for (i =0 ;i <ZOPFLI_NUM_D ;i ++){result ->dists [i ]=(size_t )(stats1 ->dists [i ]*w1 +stats2 ->dists [i ]*w2 );}result ->litlens [256 ]=1 ;/* End symbol. */ }",
                "rust_signature": "pub fn add_weighed_stat_freqs(stats1: &SymbolStats, w1: f64, stats2: &SymbolStats, w2: f64, result: &mut SymbolStats) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "CeilDiv(size_t, size_t)": {
                "signature": "size_t CeilDiv(size_t, size_t)",
                "description": "",
                "dependencies": {},
                "full_text": "static size_t CeilDiv (size_t a ,size_t b ){return (a +b -1 )/b ;}",
                "rust_signature": "pub fn ceil_div(a: usize, b: usize) -> usize {\n    // 原始C代码逻辑未实现，仅占位\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "CopyStats(SymbolStats *, SymbolStats *)": {
                "signature": "void CopyStats(SymbolStats *, SymbolStats *)",
                "description": "",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void CopyStats (SymbolStats *source ,SymbolStats *dest ){memcpy (dest ->litlens ,source ->litlens ,ZOPFLI_NUM_LL *sizeof (dest ->litlens [0 ]));memcpy (dest ->dists ,source ->dists ,ZOPFLI_NUM_D *sizeof (dest ->dists [0 ]));memcpy (dest ->ll_symbols ,source ->ll_symbols ,ZOPFLI_NUM_LL *sizeof (dest ->ll_symbols [0 ]));memcpy (dest ->d_symbols ,source ->d_symbols ,ZOPFLI_NUM_D *sizeof (dest ->d_symbols [0 ]));}",
                "rust_signature": "pub fn copy_stats(source: &SymbolStats, dest: &mut SymbolStats) {\n    todo!(\"Function implementation is not provided as per the requirements.\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "InitStats(SymbolStats *)": {
                "signature": "void InitStats(SymbolStats *)",
                "description": "/* Sets everything to 0. */",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void InitStats (SymbolStats *stats ){memset (stats ->litlens ,0 ,ZOPFLI_NUM_LL *sizeof (stats ->litlens [0 ]));memset (stats ->dists ,0 ,ZOPFLI_NUM_D *sizeof (stats ->dists [0 ]));memset (stats ->ll_symbols ,0 ,ZOPFLI_NUM_LL *sizeof (stats ->ll_symbols [0 ]));memset (stats ->d_symbols ,0 ,ZOPFLI_NUM_D *sizeof (stats ->d_symbols [0 ]));}",
                "rust_signature": "pub fn init_stats(stats: &mut SymbolStats) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)": {
                "signature": "int FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)",
                "description": "/*\nFinds next block to try to split, the largest of the available ones.\nThe largest is chosen to make sure that if only a limited amount of blocks is\nrequested, their sizes are spread evenly.\nlz77size: the size of the LL77 data, which is the size of the done array here.\ndone: array indicating which blocks starting at that position are no longer\nsplittable (splitting them increases rather than decreases cost).\nsplitpoints: the splitpoints found so far.\nnpoints: the amount of splitpoints found so far.\nlstart: output variable, giving start of block.\nlend: output variable, giving end of block.\nreturns 1 if a block was found, 0 if no block found (all are done).\n*/",
                "dependencies": {},
                "full_text": "static int FindLargestSplittableBlock (size_t lz77size ,const unsigned char *done ,const size_t *splitpoints ,size_t npoints ,size_t *lstart ,size_t *lend ){size_t longest =0 ;int found =0 ;size_t i ;for (i =0 ;i <=npoints ;i ++){size_t start =i ==0 ?0 :splitpoints [i -1 ];size_t end =i ==npoints ?lz77size -1 :splitpoints [i ];if (!done [start ]&&end -start >longest ){*lstart =start ;*lend =end ;found =1 ;longest =end -start ;}}return found ;}",
                "rust_signature": "pub unsafe fn find_largest_splittable_block(lz77size: usize, done: *const u8, splitpoints: *const usize, npoints: usize, lstart: *mut usize, lend: *mut usize) -> i32 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)": {
                "signature": "void PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)",
                "description": "/*\nPrints the block split points as decimal and hex values in the terminal.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "static void PrintBlockSplitPoints (const ZopfliLZ77Store *lz77 ,const size_t *lz77splitpoints ,size_t nlz77points ){size_t *splitpoints =0 ;size_t npoints =0 ;size_t i ;/* The input is given as lz77 indices, but we want to see the uncompressed\n    index values. */ size_t pos =0 ;if (nlz77points >0 ){for (i =0 ;i <lz77 ->size ;i ++){size_t length =lz77 ->dists [i ]==0 ?1 :lz77 ->litlens [i ];if (lz77splitpoints [npoints ]==i ){ZOPFLI_APPEND_DATA (pos ,&splitpoints ,&npoints );if (npoints ==nlz77points )break ;}pos +=length ;}}assert (npoints ==nlz77points );fprintf (stderr ,\"block split points: \" );for (i =0 ;i <npoints ;i ++){fprintf (stderr ,\"%d \" ,(int )splitpoints [i ]);}fprintf (stderr ,\"(hex:\" );for (i =0 ;i <npoints ;i ++){fprintf (stderr ,\" %x\" ,(int )splitpoints [i ]);}fprintf (stderr ,\")\\n\" );free (splitpoints );}",
                "rust_signature": "fn print_block_split_points(lz77: &ZopfliLZ77Store, lz77splitpoints: *const usize, nlz77points: usize) {\n    // Function body is intentionally left unimplemented.\n    todo!(\"Implement function logic\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "AddSorted(size_t, size_t **, size_t *)": {
                "signature": "void AddSorted(size_t, size_t **, size_t *)",
                "description": "",
                "dependencies": {},
                "full_text": "static void AddSorted (size_t value ,size_t **out ,size_t *outsize ){size_t i ;ZOPFLI_APPEND_DATA (value ,out ,outsize );for (i =0 ;i +1 <*outsize ;i ++){if ((*out )[i ]>value ){size_t j ;for (j =*outsize -1 ;j >i ;j --){(*out )[j ]=(*out )[j -1 ];}(*out )[i ]=value ;break ;}}}",
                "rust_signature": "unsafe fn add_sorted(value: usize, out: *mut *mut usize, outsize: *mut usize) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)": {
                "signature": "size_t FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)",
                "description": "/*\nFinds minimum of function f(i) where is is of type size_t, f(i) is of type\ndouble, i is in range start-end (excluding end).\nOutputs the minimum value in *smallest and returns the index of this value.\n*/",
                "dependencies": {
                    "zopfli::FindMinimumFun": {
                        "return_type": "FindMinimumFun",
                        "qualified_name": "zopfli::FindMinimumFun",
                        "type": "typedefs"
                    },
                    "zopfli::NUM": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::NUM",
                        "type": "defines"
                    }
                },
                "full_text": "static size_t FindMinimum (FindMinimumFun f ,void *context ,size_t start ,size_t end ,double *smallest ){if (end -start <1024 ){double best =ZOPFLI_LARGE_FLOAT ;size_t result =start ;size_t i ;for (i =start ;i <end ;i ++){double v =f (i ,context );if (v <best ){best =v ;result =i ;}}*smallest =best ;return result ;}else {/* Try to find minimum faster by recursively checking multiple points. */ #define NUM 9 /* Good value: 9. */ size_t i ;size_t p [NUM ];double vp [NUM ];size_t besti ;double best ;double lastbest =ZOPFLI_LARGE_FLOAT ;size_t pos =start ;for (;;){if (end -start <=NUM )break ;for (i =0 ;i <NUM ;i ++){p [i ]=start +(i +1 )*((end -start )/(NUM +1 ));vp [i ]=f (p [i ],context );}besti =0 ;best =vp [0 ];for (i =1 ;i <NUM ;i ++){if (vp [i ]<best ){best =vp [i ];besti =i ;}}if (best >lastbest )break ;start =besti ==0 ?start :p [besti -1 ];end =besti ==NUM -1 ?end :p [besti +1 ];pos =p [besti ];lastbest =best ;}*smallest =lastbest ;return pos ;#undef NUM }}",
                "rust_signature": "pub fn find_minimum(f: FindMinimumFun, context: *mut core::ffi::c_void, start: usize, end: usize, smallest: &mut f64) -> usize {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "single_test(const unsigned char *, int, int, int)": {
                "signature": "void single_test(const unsigned char *, int, int, int)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void single_test (const unsigned char *in ,int btype ,int blocksplitting ,int blocksplittingmax ){ZopfliOptions options ;// Configure options options .verbose =1 ;options .verbose_more =0 ;// Reduce internal verbose output options .numiterations =15 ;options .blocksplitting =blocksplitting ;options .blocksplittinglast =0 ;options .blocksplittingmax =blocksplittingmax ;unsigned char *out =0 ;size_t outsize =0 ;unsigned char bp =0 ;size_t insize =strlen (in );// Perform compression ZopfliDeflate (&options ,btype ,1 ,(const unsigned char *)in ,insize ,&bp ,&out ,&outsize );}",
                "rust_signature": "pub fn single_test(\n    input: *const u8,\n    btype: i32,\n    block_splitting: i32,\n    block_splitting_max: i32,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n    bp: *mut u8,\n    insize: usize,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "run_all_tests(const unsigned char *)": {
                "signature": "void run_all_tests(const unsigned char *)",
                "description": "",
                "dependencies": {
                    "zopfli::single_test(const unsigned char *, int, int, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::single_test(const unsigned char *, int, int, int)",
                        "type": "functions"
                    }
                },
                "full_text": "void run_all_tests (const unsigned char *in ){single_test (in ,2 ,1 ,15 );// Dynamic Huffman single_test (in ,1 ,1 ,15 );// Fixed Huffman single_test (in ,0 ,1 ,15 );// Uncompressed // Test with different block splitting settings single_test (in ,2 ,0 ,15 );// No block splitting single_test (in ,2 ,1 ,5 );// Limited splits single_test (in ,2 ,1 ,0 );// No splits single_test (in ,2 ,1 ,1 );// No splits single_test (in ,2 ,1 ,50 );// No splits single_test (in ,2 ,1 ,30 );// More splits allowed }",
                "rust_signature": "pub fn run_all_tests(input: *const u8) {\n    // Placeholder implementation\n    // Original C code calls single_test multiple times with different parameters\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "read_stdin_to_bytes(size_t *)": {
                "signature": "unsigned char * read_stdin_to_bytes(size_t *)",
                "description": "",
                "dependencies": {},
                "full_text": "unsigned char *read_stdin_to_bytes (size_t *out_size ){// Initial buffer size size_t buffer_size =1024 ;size_t total_read =0 ;// Allocate initial buffer unsigned char *buffer =malloc (buffer_size );if (buffer ==NULL ){fprintf (stderr ,\"Memory allocation failed\\n\" );return NULL ;}// Read stdin in chunks int ch ;while ((ch =getchar ())!=EOF ){// Resize buffer if needed if (total_read >=buffer_size ){buffer_size *=2 ;unsigned char *new_buffer =realloc (buffer ,buffer_size );if (new_buffer ==NULL ){fprintf (stderr ,\"Memory reallocation failed\\n\" );free (buffer );return NULL ;}buffer =new_buffer ;}// Store the character buffer [total_read ++]=(unsigned char )ch ;}// Set the output size *out_size =total_read ;return buffer ;}",
                "rust_signature": "fn read_stdin_to_bytes(out_size: &mut usize) -> Option<Vec<u8>> {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "main()": {
                "signature": "int main()",
                "description": "",
                "dependencies": {
                    "zopfli::read_stdin_to_bytes(size_t *)": {
                        "return_type": "unsigned char *",
                        "qualified_name": "zopfli::read_stdin_to_bytes(size_t *)",
                        "type": "functions"
                    },
                    "zopfli::run_all_tests(const unsigned char *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::run_all_tests(const unsigned char *)",
                        "type": "functions"
                    }
                },
                "full_text": "int main (){size_t bytes_size ;unsigned char *bytes =read_stdin_to_bytes (&bytes_size );if (bytes ==NULL ){fprintf (stderr ,\"Failed to read stdin\\n\" );return 1 ;}// Run tests run_all_tests (bytes );// Free allocated memory free (bytes );return 0 ;}",
                "rust_signature": "",
                "conversion_status": "success",
                "conversion_rounds": 4
            },
            "ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)": {
                "name": "ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)",
                "signature": "ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)",
                "value": "\n{                                                                                \nif (!((*size) & ((*size) - 1)))                                              \n{                                                                            \n/*double alloc size if it's a power of two*/                             \n(*data) = (*size) == 0 ? malloc(sizeof(**data))                          \n: realloc((*data), (*size) * 2 * sizeof(**data)); \nmemset((*data) + (*size), 0, (*size) * sizeof(**data));                  \n}                                                                            \n(*data)[(*size)] = (value);                                                  \n(*size)++;                                                                   \n}",
                "full_text": "#define ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)        \\\n    {                                                                                \\\n        if (!((*size) & ((*size) - 1)))                                              \\\n        {                                                                            \\\n            /*double alloc size if it's a power of two*/                             \\\n            (*data) = (*size) == 0 ? malloc(sizeof(**data))                          \\\n                                   : realloc((*data), (*size) * 2 * sizeof(**data)); \\\n            memset((*data) + (*size), 0, (*size) * sizeof(**data));                  \\\n        }                                                                            \\\n        (*data)[(*size)] = (value);                                                  \\\n        (*size)++;                                                                   \\\n    }",
                "original_type": "define",
                "rust_signature": "pub fn zopfli_append_data<T>(value: T, data: &mut Vec<T>) {\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            }
        },
        "fields": {}
    }
}