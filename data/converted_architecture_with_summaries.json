{
    "zopfli": {
        "description": "",
        "structs": {
            "ZopfliLZ77Store": {
                "signature": "ZopfliLZ77Store",
                "description": "/*\nStores lit/length and dist pairs for LZ77.\nParameter litlens: Contains the literal symbols or length values.\nParameter dists: Contains the distances. A value is 0 to indicate that there is\nno dist and the corresponding litlens value is a literal instead of a length.\nParameter size: The size of both the litlens and dists arrays.\nThe memory can best be managed by using ZopfliInitLZ77Store to initialize it,\nZopfliCleanLZ77Store to destroy it, and ZopfliStoreLitLenDist to append values.\n\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "unsigned short * litlens",
                        "description": ""
                    },
                    {
                        "signature": "unsigned short * dists",
                        "description": "/* Lit or len. */"
                    },
                    {
                        "signature": "size_t size",
                        "description": "/* If 0: indicates literal in corresponding litlens,\n         if > 0: length in corresponding litlens, this is the distance. */"
                    },
                    {
                        "signature": "const unsigned char * data",
                        "description": ""
                    },
                    {
                        "signature": "size_t * pos",
                        "description": "/* original data */"
                    },
                    {
                        "signature": "unsigned short * ll_symbol",
                        "description": "/* position in data where this LZ77 command begins */"
                    },
                    {
                        "signature": "unsigned short * d_symbol",
                        "description": ""
                    },
                    {
                        "signature": "size_t * ll_counts",
                        "description": "/* Cumulative histograms wrapping around per chunk. Each chunk has the amount\n    of distinct symbols as length, so using 1 value per LZ77 symbol, we have a\n    precise histogram at every N symbols, and the rest can be calculated by\n    looping through the actual symbols of this chunk. */"
                    },
                    {
                        "signature": "size_t * d_counts",
                        "description": ""
                    }
                ],
                "full_text": "struct ZopfliLZ77Store {unsigned short *litlens ;/* Lit or len. */ unsigned short *dists ;/* If 0: indicates literal in corresponding litlens,\n         if > 0: length in corresponding litlens, this is the distance. */ size_t size ;const unsigned char *data ;/* original data */ size_t *pos ;/* position in data where this LZ77 command begins */ unsigned short *ll_symbol ;unsigned short *d_symbol ;/* Cumulative histograms wrapping around per chunk. Each chunk has the amount\n    of distinct symbols as length, so using 1 value per LZ77 symbol, we have a\n    precise histogram at every N symbols, and the rest can be calculated by\n    looping through the actual symbols of this chunk. */ size_t *ll_counts ;size_t *d_counts ;}",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct ZopfliLZ77Store {\n    litlens: *mut u16, // Lit or len.\n    dists: *mut u16, // If 0: indicates literal in corresponding litlens,\n                     // if > 0: length in corresponding litlens, this is the distance.\n    size: usize,\n    data: *const u8, // Original data\n    pos: *mut usize, // Position in data where this LZ77 command begins\n    ll_symbol: *mut u16, // Cumulative histograms wrapping around per chunk.\n    d_symbol: *mut u16, // Each chunk has the amount of distinct symbols as length.\n    ll_counts: *mut usize, // Precise histogram at every N symbols.\n    d_counts: *mut usize // The rest can be calculated by looping through the actual symbols of this chunk.\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "SplitCostContext": {
                "signature": "SplitCostContext",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "const ZopfliLZ77Store * lz77",
                        "description": ""
                    },
                    {
                        "signature": "size_t start",
                        "description": ""
                    },
                    {
                        "signature": "size_t end",
                        "description": ""
                    }
                ],
                "full_text": "struct SplitCostContext {const ZopfliLZ77Store *lz77 ;size_t start ;size_t end ;}",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "typedefs"
                    }
                },
                "rust_signature": "#[derive(Debug, Clone)]\npub struct SplitCostContext {\n    pub lz77: *const ZopfliLZ77Store,\n    pub start: usize,\n    pub end: usize,\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "SymbolStats": {
                "signature": "SymbolStats",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "size_t[288] litlens",
                        "description": "/* The literal and length symbols. */"
                    },
                    {
                        "signature": "size_t[32] dists",
                        "description": "/* The 32 unique dist symbols, not the 32768 possible dists. */"
                    },
                    {
                        "signature": "double[288] ll_symbols",
                        "description": "/* Length of each lit/len symbol in bits. */"
                    },
                    {
                        "signature": "double[32] d_symbols",
                        "description": "/* Length of each dist symbol in bits. */"
                    }
                ],
                "full_text": "struct SymbolStats {/* The literal and length symbols. */ size_t litlens [ZOPFLI_NUM_LL ];/* The 32 unique dist symbols, not the 32768 possible dists. */ size_t dists [ZOPFLI_NUM_D ];/* Length of each lit/len symbol in bits. */ double ll_symbols [ZOPFLI_NUM_LL ];/* Length of each dist symbol in bits. */ double d_symbols [ZOPFLI_NUM_D ];}",
                "dependencies": {
                    "zopfli::ZOPFLI_NUM_LL": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::ZOPFLI_NUM_LL",
                        "type": "defines"
                    },
                    "zopfli::ZOPFLI_NUM_D": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::ZOPFLI_NUM_D",
                        "type": "defines"
                    }
                },
                "rust_signature": "pub struct SymbolStats {\n    /// The literal and length symbols.\n    pub litlens: [usize; ZOPFLI_NUM_LL],\n    /// The 32 unique dist symbols, not the 32768 possible dists.\n    pub dists: [usize; ZOPFLI_NUM_D],\n    /// Length of each lit/len symbol in bits.\n    pub ll_symbols: [f64; ZOPFLI_NUM_LL],\n    /// Length of each dist symbol in bits.\n    pub d_symbols: [f64; ZOPFLI_NUM_D],\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "RanState": {
                "signature": "RanState",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "unsigned int m_w",
                        "description": ""
                    },
                    {
                        "signature": "unsigned int m_z",
                        "description": ""
                    }
                ],
                "full_text": "struct RanState {unsigned int m_w ,m_z ;}",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct RanState {\n    m_w: u32,\n    m_z: u32,\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliHash": {
                "signature": "ZopfliHash",
                "description": "",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "int * head",
                        "description": ""
                    },
                    {
                        "signature": "unsigned short * prev",
                        "description": "/* Hash value to index of its most recent occurrence. */"
                    },
                    {
                        "signature": "int * hashval",
                        "description": "/* Index to index of prev. occurrence of same hash. */"
                    },
                    {
                        "signature": "int val",
                        "description": "/* Index to hash value at this index. */"
                    },
                    {
                        "signature": "int * head2",
                        "description": "/* Fields with similar purpose as the above hash, but for the second hash with\n    a value that is calculated differently.  */"
                    },
                    {
                        "signature": "unsigned short * prev2",
                        "description": "/* Hash value to index of its most recent occurrence. */"
                    },
                    {
                        "signature": "int * hashval2",
                        "description": "/* Index to index of prev. occurrence of same hash. */"
                    },
                    {
                        "signature": "int val2",
                        "description": "/* Index to hash value at this index. */"
                    },
                    {
                        "signature": "unsigned short * same",
                        "description": "/* Current hash value. */"
                    }
                ],
                "full_text": "struct ZopfliHash {int *head ;/* Hash value to index of its most recent occurrence. */ unsigned short *prev ;/* Index to index of prev. occurrence of same hash. */ int *hashval ;/* Index to hash value at this index. */ int val ;/* Current hash value. */ /* Fields with similar purpose as the above hash, but for the second hash with\n    a value that is calculated differently.  */ int *head2 ;/* Hash value to index of its most recent occurrence. */ unsigned short *prev2 ;/* Index to index of prev. occurrence of same hash. */ int *hashval2 ;/* Index to hash value at this index. */ int val2 ;/* Current hash value. */ unsigned short *same ;/* Amount of repetitions of same byte after this .*/ }",
                "dependencies": {},
                "rust_signature": "/// Represents a hash structure with fields for tracking hash values and occurrences.\n#[repr(C)]\n#[derive(Debug, Clone)]\npub struct ZopfliHash {\n    /// Hash value to index of its most recent occurrence.\n    pub head: *mut i32,\n    /// Index to index of previous occurrence of the same hash.\n    pub prev: *mut u16,\n    /// Index to hash value at this index.\n    pub hashval: *mut i32,\n    /// Current hash value.\n    pub val: i32,\n    /// Hash value to index of its most recent occurrence for the second hash.\n    pub head2: *mut i32,\n    /// Index to index of previous occurrence of the same hash for the second hash.\n    pub prev2: *mut u16,\n    /// Index to hash value at this index for the second hash.\n    pub hashval2: *mut i32,\n    /// Current hash value for the second hash.\n    pub val2: i32,\n    /// Amount of repetitions of the same byte after this.\n    pub same: *mut u16,\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "Node": {
                "signature": "Node",
                "description": "/*\nNodes forming chains. Also used to represent leaves.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "size_t weight",
                        "description": ""
                    },
                    {
                        "signature": "Node * tail",
                        "description": "/* Total weight (symbol count) of this chain. */"
                    },
                    {
                        "signature": "int count",
                        "description": "/* Previous node(s) of this chain, or 0 if none. */"
                    }
                ],
                "full_text": "struct Node {size_t weight ;/* Total weight (symbol count) of this chain. */ Node *tail ;/* Previous node(s) of this chain, or 0 if none. */ int count ;/* Leaf symbol index, or number of leaves before this chain. */ }",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct Node {\n    weight: usize, // Total weight (symbol count) of this chain.\n    tail: Option<Box<Node>>, // Previous node(s) of this chain, or None if none.\n    count: i32 // Leaf symbol index, or number of leaves before this chain.\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "NodePool": {
                "signature": "NodePool",
                "description": "/*\nMemory pool for nodes.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "Node * next",
                        "description": ""
                    }
                ],
                "full_text": "struct NodePool {Node *next ;/* Pointer to a free node in the pool. */ }",
                "dependencies": {
                    "zopfli::Node": {
                        "qualified_name": "zopfli::Node",
                        "type": "typedefs"
                    }
                },
                "rust_signature": "struct NodePool {\n    next: *mut Node, // Pointer to a free node in the pool. May be null.\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliLongestMatchCache": {
                "signature": "ZopfliLongestMatchCache",
                "description": "/*\nCache used by ZopfliFindLongestMatch to remember previously found length/dist\nvalues.\nThis is needed because the squeeze runs will ask these values multiple times for\nthe same position.\nUses large amounts of memory, since it has to remember the distance belonging\nto every possible shorter-than-the-best length (the so called \"sublen\" array).\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "unsigned short * length",
                        "description": ""
                    },
                    {
                        "signature": "unsigned short * dist",
                        "description": ""
                    },
                    {
                        "signature": "unsigned char * sublen",
                        "description": ""
                    }
                ],
                "full_text": "struct ZopfliLongestMatchCache {unsigned short *length ;unsigned short *dist ;unsigned char *sublen ;}",
                "dependencies": {},
                "rust_signature": "#[derive(Debug, Clone)]\nstruct ZopfliLongestMatchCache {\n    length: *mut u16, // Represents a raw pointer to unsigned short\n    dist: *mut u16,   // Represents a raw pointer to unsigned short\n    sublen: *mut u8   // Represents a raw pointer to unsigned char\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "ZopfliOptions": {
                "signature": "ZopfliOptions",
                "description": "/*\nOptions used throughout the program.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "int verbose",
                        "description": "/* Whether to print output */"
                    },
                    {
                        "signature": "int verbose_more",
                        "description": "/* Whether to print more detailed output */"
                    },
                    {
                        "signature": "int numiterations",
                        "description": "/*\n    Maximum amount of times to rerun forward and backward pass to optimize LZ77\n    compression cost. Good values: 10, 15 for small files, 5 for files over\n    several MB in size or it will be too slow.\n    */"
                    },
                    {
                        "signature": "int blocksplitting",
                        "description": "/*\n    If true, splits the data in multiple deflate blocks with optimal choice\n    for the block boundaries. Block splitting gives better compression. Default:\n    true (1).\n    */"
                    },
                    {
                        "signature": "int blocksplittinglast",
                        "description": "/*\n    No longer used, left for compatibility.\n    */"
                    },
                    {
                        "signature": "int blocksplittingmax",
                        "description": "/*\n    Maximum amount of blocks to split into (0 for unlimited, but this can give\n    extreme results that hurt compression on some files). Default value: 15.\n    */"
                    }
                ],
                "full_text": "struct ZopfliOptions {/* Whether to print output */ int verbose ;/* Whether to print more detailed output */ int verbose_more ;/*\n    Maximum amount of times to rerun forward and backward pass to optimize LZ77\n    compression cost. Good values: 10, 15 for small files, 5 for files over\n    several MB in size or it will be too slow.\n    */ int numiterations ;/*\n    If true, splits the data in multiple deflate blocks with optimal choice\n    for the block boundaries. Block splitting gives better compression. Default:\n    true (1).\n    */ int blocksplitting ;/*\n    No longer used, left for compatibility.\n    */ int blocksplittinglast ;/*\n    Maximum amount of blocks to split into (0 for unlimited, but this can give\n    extreme results that hurt compression on some files). Default value: 15.\n    */ int blocksplittingmax ;}",
                "dependencies": {},
                "rust_signature": "/// Options for Zopfli compression\n#[derive(Debug, Clone)]\npub struct ZopfliOptions {\n    /// Whether to print output\n    pub verbose: i32,\n    /// Whether to print more detailed output\n    pub verbose_more: i32,\n    /// Maximum amount of times to rerun forward and backward pass to optimize LZ77 compression cost.\n    /// Good values: 10, 15 for small files, 5 for files over several MB in size or it will be too slow.\n    pub num_iterations: i32,\n    /// If true, splits the data in multiple deflate blocks with optimal choice for the block boundaries.\n    /// Block splitting gives better compression. Default: true (1).\n    pub block_splitting: i32,\n    /// No longer used, left for compatibility.\n    pub block_splitting_last: i32,\n    /// Maximum amount of blocks to split into (0 for unlimited, but this can give extreme results\n    /// that hurt compression on some files). Default value: 15.\n    pub block_splitting_max: i32,\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliBlockState": {
                "signature": "ZopfliBlockState",
                "description": "/*\nSome state information for compressing a block.\nThis is currently a bit under-used (with mainly only the longest match cache),\nbut is kept for easy future expansion.\n*/",
                "file": "zopfli.h",
                "fields": [
                    {
                        "signature": "const ZopfliOptions * options",
                        "description": ""
                    },
                    {
                        "signature": "ZopfliLongestMatchCache * lmc",
                        "description": "/* Cache for length/distance pairs found so far. */"
                    },
                    {
                        "signature": "size_t blockstart",
                        "description": "/* The start (inclusive) and end (not inclusive) of the current block. */"
                    },
                    {
                        "signature": "size_t blockend",
                        "description": ""
                    }
                ],
                "full_text": "struct ZopfliBlockState {const ZopfliOptions *options ;/* Cache for length/distance pairs found so far. */ ZopfliLongestMatchCache *lmc ;/* The start (inclusive) and end (not inclusive) of the current block. */ size_t blockstart ;size_t blockend ;}",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "typedefs"
                    },
                    "zopfli::ZopfliLongestMatchCache": {
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "typedefs"
                    }
                },
                "rust_signature": "/// Represents the state of a Zopfli block.\n#[derive(Debug, Clone)]\npub struct ZopfliBlockState {\n    /// Options for Zopfli compression (immutable pointer).\n    pub options: *const ZopfliOptions,\n    /// Cache for length/distance pairs found so far (mutable pointer).\n    pub lmc: *mut ZopfliLongestMatchCache,\n    /// The start (inclusive) of the current block.\n    pub blockstart: usize,\n    /// The end (not inclusive) of the current block.\n    pub blockend: usize,\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            }
        },
        "defines": {
            "HASH_MASK": {
                "name": "HASH_MASK",
                "signature": "HASH_MASK",
                "value": "32767",
                "full_text": "#define HASH_MASK 32767",
                "rust_signature": "const HASH_MASK: u32 = 32767;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "HASH_SHIFT": {
                "name": "HASH_SHIFT",
                "signature": "HASH_SHIFT",
                "value": "5",
                "full_text": "#define HASH_SHIFT 5",
                "rust_signature": "const HASH_SHIFT: usize = 5;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "NUM": {
                "name": "NUM",
                "signature": "NUM",
                "value": "9 /* Good value: 9. */",
                "full_text": "#define NUM 9 /* Good value: 9. */",
                "rust_signature": "pub const NUM: i32 = 9; // Good value: 9.",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_SLICE_H_": {
                "name": "ZOPFLI_SLICE_H_",
                "signature": "ZOPFLI_SLICE_H_",
                "value": "",
                "full_text": "#define ZOPFLI_SLICE_H_",
                "rust_signature": "// Rust不需要头文件保护宏，直接忽略",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_NUM_LL": {
                "name": "ZOPFLI_NUM_LL",
                "signature": "ZOPFLI_NUM_LL",
                "value": "288",
                "full_text": "#define ZOPFLI_NUM_LL 288",
                "rust_signature": "const ZOPFLI_NUM_LL: usize = 288;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_NUM_D": {
                "name": "ZOPFLI_NUM_D",
                "signature": "ZOPFLI_NUM_D",
                "value": "32",
                "full_text": "#define ZOPFLI_NUM_D 32",
                "rust_signature": "pub const ZOPFLI_NUM_D: usize = 32;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_CACHE_LENGTH": {
                "name": "ZOPFLI_CACHE_LENGTH",
                "signature": "ZOPFLI_CACHE_LENGTH",
                "value": "8",
                "full_text": "#define ZOPFLI_CACHE_LENGTH 8",
                "rust_signature": "const ZOPFLI_CACHE_LENGTH: usize = 8;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MIN_MATCH": {
                "name": "ZOPFLI_MIN_MATCH",
                "signature": "ZOPFLI_MIN_MATCH",
                "value": "3",
                "full_text": "#define ZOPFLI_MIN_MATCH 3",
                "rust_signature": "pub const ZOPFLI_MIN_MATCH: usize = 3;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MAX_MATCH": {
                "name": "ZOPFLI_MAX_MATCH",
                "signature": "ZOPFLI_MAX_MATCH",
                "value": "258",
                "full_text": "#define ZOPFLI_MAX_MATCH 258",
                "rust_signature": "const ZOPFLI_MAX_MATCH: usize = 258;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MAX_CHAIN_HITS": {
                "name": "ZOPFLI_MAX_CHAIN_HITS",
                "signature": "ZOPFLI_MAX_CHAIN_HITS",
                "value": "8192",
                "full_text": "#define ZOPFLI_MAX_CHAIN_HITS 8192",
                "rust_signature": "pub const ZOPFLI_MAX_CHAIN_HITS: usize = 8192;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_WINDOW_SIZE": {
                "name": "ZOPFLI_WINDOW_SIZE",
                "signature": "ZOPFLI_WINDOW_SIZE",
                "value": "32768",
                "full_text": "#define ZOPFLI_WINDOW_SIZE 32768",
                "rust_signature": "const ZOPFLI_WINDOW_SIZE: usize = 32768;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_WINDOW_MASK": {
                "name": "ZOPFLI_WINDOW_MASK",
                "signature": "ZOPFLI_WINDOW_MASK",
                "value": "(ZOPFLI_WINDOW_SIZE - 1)",
                "full_text": "#define ZOPFLI_WINDOW_MASK (ZOPFLI_WINDOW_SIZE - 1)",
                "rust_signature": "const ZOPFLI_WINDOW_MASK: usize = ZOPFLI_WINDOW_SIZE - 1;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_LARGE_FLOAT": {
                "name": "ZOPFLI_LARGE_FLOAT",
                "signature": "ZOPFLI_LARGE_FLOAT",
                "value": "1e30",
                "full_text": "#define ZOPFLI_LARGE_FLOAT 1e30",
                "rust_signature": "const ZOPFLI_LARGE_FLOAT: f64 = 1e30;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZOPFLI_MASTER_BLOCK_SIZE": {
                "name": "ZOPFLI_MASTER_BLOCK_SIZE",
                "signature": "ZOPFLI_MASTER_BLOCK_SIZE",
                "value": "1000000",
                "full_text": "#define ZOPFLI_MASTER_BLOCK_SIZE 1000000",
                "rust_signature": "pub const ZOPFLI_MASTER_BLOCK_SIZE: usize = 1_000_000;",
                "conversion_status": "success",
                "conversion_rounds": 1
            }
        },
        "typedefs": {
            "typedef double FindMinimumFun (size_t i ,void *context )": {
                "name": "FindMinimumFun",
                "signature": "typedef double FindMinimumFun (size_t i ,void *context )",
                "description": "/*\nThe \"f\" for the FindMinimum function below.\ni: the current parameter of f(i)\ncontext: for your implementation\n\nInstance: `SplitCost` using `SplitCostContext` as context\n*/",
                "full_text": "typedef double FindMinimumFun (size_t i ,void *context )",
                "dependencies": {},
                "rust_signature": "type FindMinimumFun = unsafe extern \"C\" fn(i: usize, context: *mut core::ffi::c_void) -> f64;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "typedef double CostModelFun (unsigned litlen ,unsigned dist ,void *context )": {
                "name": "CostModelFun",
                "signature": "typedef double CostModelFun (unsigned litlen ,unsigned dist ,void *context )",
                "description": "/*\nFunction that calculates a cost based on a model for the given LZ77 symbol.\nlitlen: means literal symbol if dist is 0, length otherwise.\n\nInstance: `GetCostFixed` using NULL as context\nInstance: `GetCostStat` using `SymbolStats` as context\n*/",
                "full_text": "typedef double CostModelFun (unsigned litlen ,unsigned dist ,void *context )",
                "dependencies": {},
                "rust_signature": "type CostModelFun = unsafe extern \"C\" fn(litlen: u32, dist: u32, context: *mut core::ffi::c_void) -> f64;",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "typedef struct Node Node ": {
                "name": "Node",
                "signature": "typedef struct Node Node ",
                "description": "",
                "full_text": "typedef struct Node Node ",
                "dependencies": {},
                "rust_signature": "struct Node;",
                "conversion_status": "success",
                "conversion_rounds": 1
            }
        },
        "functions": {
            "ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)": {
                "signature": "int ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)",
                "description": "/*\nOutputs minimum-redundancy length-limited code bitlengths for symbols with the\ngiven counts. The bitlengths are limited by maxbits.\n\nThe output is tailored for DEFLATE: symbols that never occur, get a bit length\nof 0, and if only a single symbol occurs at least once, its bitlength will be 1,\nand not 0 as would theoretically be needed for a single symbol.\n\nfrequencies: The amount of occurrences of each symbol.\nn: The amount of symbols.\nmaxbits: Maximum bit length, inclusive.\nbitlengths: Output, the bitlengths for the symbol prefix codes.\nreturn: 0 for OK, non-0 for error.\n*/",
                "dependencies": {
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    },
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::LeafComparator(const void *, const void *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::LeafComparator(const void *, const void *)",
                        "type": "functions"
                    },
                    "zopfli::InitLists(NodePool *, const Node *, int, Node *(*)[2])": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitLists(NodePool *, const Node *, int, Node *(*)[2])",
                        "type": "functions"
                    },
                    "zopfli::BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)",
                        "type": "functions"
                    },
                    "zopfli::BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)",
                        "type": "functions"
                    },
                    "zopfli::ExtractBitLengths(Node *, Node *, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ExtractBitLengths(Node *, Node *, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "int ZopfliLengthLimitedCodeLengths (const size_t *frequencies ,int n ,int maxbits ,unsigned *bitlengths ){NodePool pool ;int i ;int numsymbols =0 ;/* Amount of symbols with frequency > 0. */ int numBoundaryPMRuns ;Node *nodes ;/* Array of lists of chains. Each list requires only two lookahead chains at\n    a time, so each list is a array of two Node*'s. */ Node *(*lists )[2 ];/* One leaf per symbol. Only numsymbols leaves will be used. */ Node *leaves =(Node *)malloc (n *sizeof (*leaves ));/* Initialize all bitlengths at 0. */ for (i =0 ;i <n ;i ++){bitlengths [i ]=0 ;}/* Count used symbols and place them in the leaves. */ for (i =0 ;i <n ;i ++){if (frequencies [i ]){leaves [numsymbols ].weight =frequencies [i ];leaves [numsymbols ].count =i ;/* Index of symbol this leaf represents. */ numsymbols ++;}}/* Check special cases and error conditions. */ if ((1 <<maxbits )<numsymbols ){free (leaves );return 1 ;/* Error, too few maxbits to represent symbols. */ }if (numsymbols ==0 ){free (leaves );return 0 ;/* No symbols at all. OK. */ }if (numsymbols ==1 ){bitlengths [leaves [0 ].count ]=1 ;free (leaves );return 0 ;/* Only one symbol, give it bitlength 1, not 0. OK. */ }if (numsymbols ==2 ){bitlengths [leaves [0 ].count ]++;bitlengths [leaves [1 ].count ]++;free (leaves );return 0 ;}/* Sort the leaves from lightest to heaviest. Add count into the same\n    variable for stable sorting. */ for (i =0 ;i <numsymbols ;i ++){if (leaves [i ].weight >=((size_t )1 <<(sizeof (leaves [0 ].weight )*CHAR_BIT -9 ))){free (leaves );return 1 ;/* Error, we need 9 bits for the count. */ }leaves [i ].weight =(leaves [i ].weight <<9 )|leaves [i ].count ;}qsort (leaves ,numsymbols ,sizeof (Node ),LeafComparator );for (i =0 ;i <numsymbols ;i ++){leaves [i ].weight >>=9 ;}if (numsymbols -1 <maxbits ){maxbits =numsymbols -1 ;}/* Initialize node memory pool. */ nodes =(Node *)malloc (maxbits *2 *numsymbols *sizeof (Node ));pool .next =nodes ;lists =(Node *(*)[2 ])malloc (maxbits *sizeof (*lists ));InitLists (&pool ,leaves ,maxbits ,lists );/* In the last list, 2 * numsymbols - 2 active chains need to be created. Two\n    are already created in the initialization. Each BoundaryPM run creates one. */ numBoundaryPMRuns =2 *numsymbols -4 ;for (i =0 ;i <numBoundaryPMRuns -1 ;i ++){BoundaryPM (lists ,leaves ,numsymbols ,&pool ,maxbits -1 );}BoundaryPMFinal (lists ,leaves ,numsymbols ,&pool ,maxbits -1 );ExtractBitLengths (lists [maxbits -1 ][1 ],leaves ,bitlengths );free (lists );free (leaves );free (nodes );return 0 ;/* OK. */ }",
                "rust_signature": "fn zopfli_length_limited_code_lengths(frequencies: *const usize, n: i32, maxbits: i32, bitlengths: *mut u32) -> i32 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliLengthLimitedCodeLengths",
                    "main_purpose": "生成长度受限的哈夫曼编码位长度分布，用于数据压缩。",
                    "detailed_logic": "函数首先初始化位长度数组为0，并通过遍历频率数组筛选出有效符号，将其存储在叶子节点数组中。接着检查特殊情况，例如符号数量是否超出最大位数限制或是否只有一个或两个符号。然后对叶子节点进行权重排序以确保稳定性。根据符号数量和最大位数初始化节点池和链表结构，并通过多次调用BoundaryPM和BoundaryPMFinal构建哈夫曼树的边界路径。最后，调用ExtractBitLengths提取位长度分布并存储到输出数组中。",
                    "error_handling": "函数检查以下错误条件：1) 如果符号数量超过最大位数限制，返回错误码1；2) 如果没有符号，返回0；3) 如果权重超出允许范围，返回错误码1。函数还在每次分配内存后检查是否成功，并在错误情况下释放已分配的资源。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                "signature": "void ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                "description": "/*\nCalculates the bitlengths for the Huffman tree, based on the counts of each\nsymbol.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliLengthLimitedCodeLengths(const size_t *, int, int, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCalculateBitLengths (const size_t *count ,size_t n ,int maxbits ,unsigned *bitlengths ){int error =ZopfliLengthLimitedCodeLengths (count ,n ,maxbits ,bitlengths );(void )error ;assert (!error );}",
                "rust_signature": "fn zopfli_calculate_bit_lengths(count: *const usize, n: usize, maxbits: i32, bitlengths: *mut u32) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliCalculateBitLengths",
                    "main_purpose": "计算哈夫曼编码的位长度分布，用于数据压缩，同时确保生成的位长度符合指定的最大位数限制。",
                    "detailed_logic": "函数调用ZopfliLengthLimitedCodeLengths来计算输入频率数组对应的哈夫曼编码位长度分布。传入的参数包括频率数组、数组大小、最大位数限制以及用于存储结果的位长度数组。调用完成后，函数通过断言确保没有发生错误。",
                    "error_handling": "函数通过断言检查ZopfliLengthLimitedCodeLengths的返回值是否为错误（非零）。如果发生错误，程序会终止运行。没有显式的错误处理逻辑，所有错误处理依赖于断言。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)": {
                "signature": "void ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)",
                "description": "/*\nConverts a series of Huffman tree bitlengths, to the bit values of the symbols.\n*/",
                "dependencies": {},
                "full_text": "void ZopfliLengthsToSymbols (const unsigned *lengths ,size_t n ,unsigned maxbits ,unsigned *symbols ){size_t *bl_count =(size_t *)malloc (sizeof (size_t )*(maxbits +1 ));size_t *next_code =(size_t *)malloc (sizeof (size_t )*(maxbits +1 ));unsigned bits ,i ;unsigned code ;for (i =0 ;i <n ;i ++){symbols [i ]=0 ;}/* 1) Count the number of codes for each code length. Let bl_count[N] be the\n    number of codes of length N, N >= 1. */ for (bits =0 ;bits <=maxbits ;bits ++){bl_count [bits ]=0 ;}for (i =0 ;i <n ;i ++){assert (lengths [i ]<=maxbits );bl_count [lengths [i ]]++;}/* 2) Find the numerical value of the smallest code for each code length. */ code =0 ;bl_count [0 ]=0 ;for (bits =1 ;bits <=maxbits ;bits ++){code =(code +bl_count [bits -1 ])<<1 ;next_code [bits ]=code ;}/* 3) Assign numerical values to all codes, using consecutive values for all\n    codes of the same length with the base values determined at step 2. */ for (i =0 ;i <n ;i ++){unsigned len =lengths [i ];if (len !=0 ){symbols [i ]=next_code [len ];next_code [len ]++;}}free (bl_count );free (next_code );}",
                "rust_signature": "pub fn zopfli_lengths_to_symbols(lengths: &[u32], n: usize, maxbits: u32, symbols: &mut [u32]) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliLengthsToSymbols",
                    "main_purpose": "将给定的代码长度数组转换为对应的符号数组，用于生成哈夫曼编码表。",
                    "detailed_logic": "函数执行以下步骤：\n1. 初始化符号数组，将所有元素设置为0。\n2. 统计每种代码长度的数量，存储在bl_count数组中。\n   - 遍历输入的代码长度数组，确保每个长度值不超过maxbits。\n   - 对每个长度值进行计数。\n3. 计算每种代码长度的最小编码值，存储在next_code数组中。\n   - 从长度1开始，逐步计算每种长度的最小编码值。\n   - 使用前一个长度的编码值累加并左移一位。\n4. 为每个代码长度分配具体的编码值。\n   - 遍历输入的代码长度数组。\n   - 如果长度值不为0，则从next_code数组中获取当前编码值，并递增该值。\n5. 释放动态分配的内存bl_count和next_code。",
                    "error_handling": "函数使用assert检查输入的代码长度是否不超过maxbits。如果断言失败，程序会终止运行。除此之外，没有其他显式的错误处理机制。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)": {
                "signature": "void ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)",
                "description": "/* Gets the histogram of lit/len and dist symbols in the given range, using the\ncumulative histograms, so faster than adding one by one for large range. Does\nnot add the one end symbol of value 256. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77GetHistogram (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t *ll_counts ,size_t *d_counts ){size_t i ;if (lstart +ZOPFLI_NUM_LL *3 >lend ){memset (ll_counts ,0 ,sizeof (*ll_counts )*ZOPFLI_NUM_LL );memset (d_counts ,0 ,sizeof (*d_counts )*ZOPFLI_NUM_D );for (i =lstart ;i <lend ;i ++){ll_counts [lz77 ->ll_symbol [i ]]++;if (lz77 ->dists [i ]!=0 )d_counts [lz77 ->d_symbol [i ]]++;}}else {/* Subtract the cumulative histograms at the end and the start to get the\n        histogram for this range. */ ZopfliLZ77GetHistogramAt (lz77 ,lend -1 ,ll_counts ,d_counts );if (lstart >0 ){size_t ll_counts2 [ZOPFLI_NUM_LL ];size_t d_counts2 [ZOPFLI_NUM_D ];ZopfliLZ77GetHistogramAt (lz77 ,lstart -1 ,ll_counts2 ,d_counts2 );for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){ll_counts [i ]-=ll_counts2 [i ];}for (i =0 ;i <ZOPFLI_NUM_D ;i ++){d_counts [i ]-=d_counts2 [i ];}}}}",
                "rust_signature": "fn zopfli_lz77_get_histogram(\n    lz77: *const ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    ll_counts: *mut usize,\n    d_counts: *mut usize\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliLZ77GetHistogram",
                    "main_purpose": "计算给定范围内的LZ77符号和距离的直方图，用于压缩算法的统计分析。",
                    "detailed_logic": "函数首先检查范围长度是否足够小（通过条件 lstart + ZOPFLI_NUM_LL * 3 > lend）。如果范围较小，直接遍历范围内的符号和距离数组，逐一累加到直方图中。否则，调用 ZopfliLZ77GetHistogramAt 函数获取范围末尾的累积直方图，并通过减去范围起始位置的累积直方图来计算当前范围的直方图。",
                    "error_handling": "函数未显式处理错误情况，但假设输入参数有效。未检查指针是否为 NULL，也未验证范围是否在有效范围内。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "提供 LZ77 符号和距离的存储结构。函数直接访问 ll_symbol 和 d_symbol 数组以累加符号和距离的计数。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/* Gets the amount of raw bytes that this range of LZ77 symbols spans. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "size_t ZopfliLZ77GetByteRange (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){size_t l =lend -1 ;if (lstart ==lend )return 0 ;return lz77 ->pos [l ]+((lz77 ->dists [l ]==0 )?1 :lz77 ->litlens [l ])-lz77 ->pos [lstart ];}",
                "rust_signature": "fn zopfli_lz77_get_byte_range(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize) -> usize {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "zopfli_lz77_get_byte_range",
                    "main_purpose": "计算LZ77压缩存储中，从索引lstart到lend范围内的字节跨度。",
                    "detailed_logic": "函数首先检查lstart是否等于lend，如果相等则直接返回0，表示范围为空。否则，计算lend对应的最后一个索引l = lend - 1。然后，根据lz77->dists[l]的值判断：如果为0，表示当前是一个字面值，跨度增加1；否则，跨度增加lz77->litlens[l]的值。最后，返回从lz77->pos[l]加上上述跨度减去lz77->pos[lstart]的结果。",
                    "error_handling": "函数没有显式的错误处理机制，但通过检查lstart是否等于lend避免了无效范围的计算。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                "signature": "double ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                "description": "/*\nCalculates block size in bits.\nlitlens: lz77 lit/lengths\ndists: ll77 distances\nlstart: start of block\nlend: end of block (not inclusive)\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::GetFixedTree(unsigned int *, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::GetFixedTree(unsigned int *, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "double ZopfliCalculateBlockSize (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,int btype ){unsigned ll_lengths [ZOPFLI_NUM_LL ];unsigned d_lengths [ZOPFLI_NUM_D ];double result =3 ;/* bfinal and btype bits */ if (btype ==0 ){size_t length =ZopfliLZ77GetByteRange (lz77 ,lstart ,lend );size_t rem =length %65535 ;size_t blocks =length /65535 +(rem ?1 :0 );/* An uncompressed block must actually be split into multiple blocks if it's\n           larger than 65535 bytes long. Eeach block header is 5 bytes: 3 bits,\n           padding, LEN and NLEN (potential less padding for first one ignored). */ return blocks *5 *8 +length *8 ;}if (btype ==1 ){GetFixedTree (ll_lengths ,d_lengths );result +=CalculateBlockSymbolSize (ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}else {result +=GetDynamicLengths (lz77 ,lstart ,lend ,ll_lengths ,d_lengths );}return result ;}",
                "rust_signature": "fn zopfli_calculate_block_size(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize, btype: i32) -> f64 {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliCalculateBlockSize",
                    "main_purpose": "计算给定LZ77块的压缩大小（以位为单位），根据块类型（未压缩、固定哈夫曼编码或动态哈夫曼编码）选择不同的计算方法。",
                    "detailed_logic": "函数首先初始化两个数组ll_lengths和d_lengths，用于存储字母/长度和距离的哈夫曼编码长度信息。然后根据块类型btype执行不同的逻辑：\n1. 如果btype为0（未压缩块），调用ZopfliLZ77GetByteRange计算块的字节长度，并根据长度计算需要的块数（每个块最大65535字节）。每个块的头部需要5字节（40位），加上数据本身的位数，返回总大小。\n2. 如果btype为1（固定哈夫曼编码块），调用GetFixedTree初始化固定哈夫曼编码树的长度信息，然后调用CalculateBlockSymbolSize计算块的符号大小，并将其加到结果中。\n3. 如果btype为2（动态哈夫曼编码块），调用GetDynamicLengths计算动态哈夫曼编码的长度分布，并将返回值加到结果中。\n最后，返回计算的总大小。",
                    "error_handling": "函数假设输入参数有效，没有显式的错误检查机制。如果依赖函数返回无效值，可能导致未定义行为。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "作为函数的输入参数，提供LZ77压缩存储的数据和元信息。函数通过此结构访问压缩数据范围和相关信息。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                "signature": "unsigned int ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                "description": "/*\nReturns the length up to which could be stored in the cache.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    }
                },
                "full_text": "unsigned ZopfliMaxCachedSublen (const ZopfliLongestMatchCache *lmc ,size_t pos ,size_t length ){unsigned char *cache ;cache =&lmc ->sublen [ZOPFLI_CACHE_LENGTH *pos *3 ];(void )length ;if (cache [1 ]==0 &&cache [2 ]==0 )return 0 ;/* No sublen cached. */ return cache [(ZOPFLI_CACHE_LENGTH -1 )*3 ]+3 ;}",
                "rust_signature": "fn zopfli_max_cached_sublen(lmc: &ZopfliLongestMatchCache, pos: usize, length: usize) -> u32 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "zopfli_max_cached_sublen",
                    "main_purpose": "计算并返回缓存的最长子长度值，用于优化压缩算法中的匹配查找。",
                    "detailed_logic": "函数通过访问ZopfliLongestMatchCache结构体中的sublen字段，计算指定位置的最长子长度值。首先，根据输入参数pos计算出缓存数组的起始位置。然后检查缓存的第二和第三字节是否为0，如果是，则表示没有缓存的子长度，直接返回0。否则，返回缓存数组最后一个子长度值加3。",
                    "error_handling": "函数没有显式的错误处理逻辑，但通过检查缓存的第二和第三字节是否为0来判断是否存在有效的缓存数据。如果缓存无效，返回0。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)": {
                "signature": "void ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)",
                "description": "/* Stores sublen array in the cache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    },
                    "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliSublenToCache (const unsigned short *sublen ,size_t pos ,size_t length ,ZopfliLongestMatchCache *lmc ){size_t i ;size_t j =0 ;unsigned bestlength =0 ;unsigned char *cache ;cache =&lmc ->sublen [ZOPFLI_CACHE_LENGTH *pos *3 ];if (length <3 )return ;for (i =3 ;i <=length ;i ++){if (i ==length ||sublen [i ]!=sublen [i +1 ]){cache [j *3 ]=i -3 ;cache [j *3 +1 ]=sublen [i ]%256 ;cache [j *3 +2 ]=(sublen [i ]>>8 )%256 ;bestlength =i ;j ++;if (j >=ZOPFLI_CACHE_LENGTH )break ;}}if (j <ZOPFLI_CACHE_LENGTH ){assert (bestlength ==length );cache [(ZOPFLI_CACHE_LENGTH -1 )*3 ]=bestlength -3 ;}else {assert (bestlength <=length );}assert (bestlength ==ZopfliMaxCachedSublen (lmc ,pos ,length ));}",
                "rust_signature": "fn zopfli_sublen_to_cache(sublen: &[u16], pos: usize, length: usize, lmc: &mut ZopfliLongestMatchCache) {\n    // Function body is unimplemented as per instructions\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliSublenToCache",
                    "main_purpose": "将子长度数组转换为缓存格式，用于优化压缩算法中的匹配查找。",
                    "detailed_logic": "函数首先检查输入的长度是否小于3，如果是则直接返回。然后初始化缓存指针，指向当前位置的缓存区域。接着遍历子长度数组，从长度3开始，记录每个子长度的值及其对应的索引差值到缓存中。当遇到子长度值变化或达到输入长度时，将当前子长度值及其索引差值存入缓存，并更新最佳长度值。如果缓存已满则停止记录，否则在缓存末尾补充最佳长度值。最后，函数通过断言验证最佳长度值是否与计算的最长缓存子长度值一致。",
                    "error_handling": "函数通过断言确保最佳长度值与计算的最长缓存子长度值一致。如果输入长度小于3，函数直接返回，不进行任何操作。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)": {
                "signature": "void ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)",
                "description": "/* Extracts sublen array from the cache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    },
                    "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCacheToSublen (const ZopfliLongestMatchCache *lmc ,size_t pos ,size_t length ,unsigned short *sublen ){size_t i ,j ;unsigned maxlength =ZopfliMaxCachedSublen (lmc ,pos ,length );unsigned prevlength =0 ;unsigned char *cache ;if (length <3 )return ;cache =&lmc ->sublen [ZOPFLI_CACHE_LENGTH *pos *3 ];for (j =0 ;j <ZOPFLI_CACHE_LENGTH ;j ++){unsigned length =cache [j *3 ]+3 ;unsigned dist =cache [j *3 +1 ]+256 *cache [j *3 +2 ];for (i =prevlength ;i <=length ;i ++){sublen [i ]=dist ;}if (length ==maxlength )break ;prevlength =length +1 ;}}",
                "rust_signature": "fn zopfli_cache_to_sublen(lmc: &ZopfliLongestMatchCache, pos: usize, length: usize, sublen: &mut [u16]) {\n    // Placeholder implementation\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliCacheToSublen",
                    "main_purpose": "将缓存中的匹配长度和距离信息转换为子长度数组，用于优化压缩算法中的匹配查找。",
                    "detailed_logic": "函数首先检查输入的length是否小于3，如果是则直接返回，因为小于3的长度没有意义。接着调用ZopfliMaxCachedSublen函数获取当前位置的最大缓存子长度值。然后通过指针计算定位到缓存的子长度数组。函数遍历缓存的匹配信息（每个匹配由长度和距离组成），并将这些信息填充到sublen数组中。对于每个匹配长度，函数从上一次的长度（prevlength）到当前匹配长度（length）之间的所有位置填充对应的距离值。如果当前匹配长度等于最大缓存子长度值，则终止循环。",
                    "error_handling": "函数检查输入的length是否小于3，如果是则直接返回，不进行任何处理。除此之外，没有其他显式的错误处理机制。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                "signature": "void ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                "description": "/*\nFinds the longest match (length and corresponding distance) for LZ77\ncompression.\nEven when not using \"sublen\", it can be more efficient to provide an array,\nbecause only then the caching is used.\narray: the data\npos: position in the data to find the match for\nsize: size of the data\nlimit: limit length to maximum this value (default should be 258). This allows\nfinding a shorter dist for that length (= less extra bits). Must be\nin the range [ZOPFLI_MIN_MATCH, ZOPFLI_MAX_MATCH].\nsublen: output array of 259 elements, or null. Has, for each length, the\nsmallest distance required to reach this length. Only 256 of its 259 values\nare used, the first 3 are ignored (the shortest length is 3. It is purely\nfor convenience that the array is made 3 longer).\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)": {
                        "return_type": "const unsigned char *",
                        "qualified_name": "zopfli::GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)",
                        "type": "functions"
                    },
                    "zopfli::StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliFindLongestMatch (ZopfliBlockState *s ,const ZopfliHash *h ,const unsigned char *array ,size_t pos ,size_t size ,size_t limit ,unsigned short *sublen ,unsigned short *distance ,unsigned short *length ){unsigned short hpos =pos &ZOPFLI_WINDOW_MASK ,p ,pp ;unsigned short bestdist =0 ;unsigned short bestlength =1 ;const unsigned char *scan ;const unsigned char *match ;const unsigned char *arrayend ;const unsigned char *arrayend_safe ;int chain_counter =ZOPFLI_MAX_CHAIN_HITS ;/* For quitting early. */ unsigned dist =0 ;/* Not unsigned short on purpose. */ int *hhead =h ->head ;unsigned short *hprev =h ->prev ;int *hhashval =h ->hashval ;int hval =h ->val ;if (TryGetFromLongestMatchCache (s ,pos ,&limit ,sublen ,distance ,length )){assert (pos +*length <=size );return ;}assert (limit <=ZOPFLI_MAX_MATCH );assert (limit >=ZOPFLI_MIN_MATCH );assert (pos <size );if (size -pos <ZOPFLI_MIN_MATCH ){/* The rest of the code assumes there are at least ZOPFLI_MIN_MATCH bytes to\n           try. */ *length =0 ;*distance =0 ;return ;}if (pos +limit >size ){limit =size -pos ;}arrayend =&array [pos ]+limit ;arrayend_safe =arrayend -8 ;assert (hval <65536 );pp =hhead [hval ];/* During the whole loop, p == hprev[pp]. */ p =hprev [pp ];assert (pp ==hpos );dist =p <pp ?pp -p :((ZOPFLI_WINDOW_SIZE -p )+pp );/* Go through all distances. */ while (dist <ZOPFLI_WINDOW_SIZE ){unsigned short currentlength =0 ;assert (p <ZOPFLI_WINDOW_SIZE );assert (p ==hprev [pp ]);assert (hhashval [p ]==hval );if (dist >0 ){assert (pos <size );assert (dist <=pos );scan =&array [pos ];match =&array [pos -dist ];/* Testing the byte at position bestlength first, goes slightly faster. */ if (pos +bestlength >=size ||*(scan +bestlength )==*(match +bestlength )){unsigned short same0 =h ->same [pos &ZOPFLI_WINDOW_MASK ];if (same0 >2 &&*scan ==*match ){unsigned short same1 =h ->same [(pos -dist )&ZOPFLI_WINDOW_MASK ];unsigned short same =same0 <same1 ?same0 :same1 ;if (same >limit )same =limit ;scan +=same ;match +=same ;}scan =GetMatch (scan ,match ,arrayend ,arrayend_safe );currentlength =scan -&array [pos ];/* The found length. */ }if (currentlength >bestlength ){if (sublen ){unsigned short j ;for (j =bestlength +1 ;j <=currentlength ;j ++){sublen [j ]=dist ;}}bestdist =dist ;bestlength =currentlength ;if (currentlength >=limit )break ;}}/* Switch to the other hash once this will be more efficient. */ if (hhead !=h ->head2 &&bestlength >=h ->same [hpos ]&&h ->val2 ==h ->hashval2 [p ]){/* Now use the hash that encodes the length and first byte. */ hhead =h ->head2 ;hprev =h ->prev2 ;hhashval =h ->hashval2 ;hval =h ->val2 ;}pp =p ;p =hprev [p ];if (p ==pp )break ;/* Uninited prev value. */ dist +=p <pp ?pp -p :((ZOPFLI_WINDOW_SIZE -p )+pp );chain_counter --;if (chain_counter <=0 )break ;}StoreInLongestMatchCache (s ,pos ,limit ,sublen ,bestdist ,bestlength );assert (bestlength <=limit );*distance =bestdist ;*length =bestlength ;assert (pos +*length <=size );}",
                "rust_signature": "pub fn zopfli_find_longest_match(\n    s: *mut ZopfliBlockState,\n    h: *const ZopfliHash,\n    array: Option<&[u8]>,\n    pos: usize,\n    size: usize,\n    limit: usize,\n    sublen: Option<&mut [u16]>,\n    distance: &mut u16,\n    length: &mut u16,\n) {\n    // This function involves complex pointer manipulations and low-level operations.\n    // The body of the function is not implemented here.\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliFindLongestMatch",
                    "main_purpose": "在给定的输入数据中，从当前位置开始查找最长的匹配字符串，并返回匹配的长度和距离，用于优化压缩算法。",
                    "detailed_logic": "函数首先检查是否可以从缓存中获取最长匹配信息，如果可以则直接返回结果。否则，函数初始化相关变量并开始匹配查找。通过哈希表定位可能的匹配位置，然后逐字节比较当前位置和匹配位置的内容，记录最长匹配的长度和距离。如果找到的匹配长度超过当前最佳匹配，则更新最佳匹配信息。函数还会根据匹配情况切换到备用哈希表以提高效率。最终，函数将匹配结果存储到缓存中，并返回最佳匹配的长度和距离。",
                    "error_handling": "函数通过assert语句检查输入参数的有效性，例如确保匹配限制在合理范围内、当前位置不超过输入数据大小等。如果输入数据不足以进行匹配（小于最小匹配长度），函数直接返回长度和距离为0。",
                    "dependencies": {
                        "zopfli::ZopfliBlockState": {
                            "signature": "pub struct ZopfliBlockState",
                            "usage": "作为函数的输入参数，提供当前块的状态信息，包括压缩选项和缓存指针等。"
                        },
                        "zopfli::ZopfliHash": {
                            "signature": "pub struct ZopfliHash",
                            "usage": "作为函数的输入参数，提供哈希表结构，用于快速查找可能的匹配位置。包含两个哈希表和相关的辅助信息。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)": {
                "signature": "void ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)",
                "description": "/*\nVerifies if length and dist are indeed valid, only used for assertion.\n*/",
                "dependencies": {},
                "full_text": "void ZopfliVerifyLenDist (const unsigned char *data ,size_t datasize ,size_t pos ,unsigned short dist ,unsigned short length ){/* TODO(lode): make this only run in a debug compile, it's for assert only. */ size_t i ;assert (pos +length <=datasize );for (i =0 ;i <length ;i ++){if (data [pos -dist +i ]!=data [pos +i ]){assert (data [pos -dist +i ]==data [pos +i ]);break ;}}}",
                "rust_signature": "pub fn zopfli_verify_len_dist(data: Option<&[u8]>, datasize: usize, pos: usize, dist: u16, length: u16) {\n    // TODO(lode): make this only run in a debug compile, it's for assert only.\n    // Original C code performs assertions and memory access checks.\n    // In Rust, this function is left unimplemented for now.\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliVerifyLenDist",
                    "main_purpose": "验证给定数据块中指定位置的长度和距离是否符合预期，确保数据的重复部分在给定距离和长度范围内是相同的。",
                    "detailed_logic": "函数首先通过断言检查输入参数是否有效，确保 pos + length 不会超出数据块的大小。然后通过循环逐字节比较数据块中 pos 到 pos + length 范围内的内容与 pos - dist 到 pos - dist + length 范围内的内容。如果发现不匹配的字节，触发断言以确保数据一致性。",
                    "error_handling": "函数使用 assert 进行错误检查。如果 pos + length 超出数据块大小或 pos - dist + i 与 pos + i 的数据不一致，程序会触发断言并终止运行。该函数没有提供运行时错误处理机制，仅用于调试目的。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                "signature": "void ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                "description": "/*\nPrepopulates hash:\nFills in the initial values in the hash, before ZopfliUpdateHash can be used\ncorrectly.\n*/",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliWarmupHash (const unsigned char *array ,size_t pos ,size_t end ,ZopfliHash *h ){UpdateHashValue (h ,array [pos +0 ]);if (pos +1 <end )UpdateHashValue (h ,array [pos +1 ]);}",
                "rust_signature": "pub fn zopfli_warmup_hash(array: *const u8, pos: usize, end: usize, h: *mut ZopfliHash) {\n    // Placeholder for the function body. Original C code calls UpdateHashValue.\n    // Unsafe is required because raw pointers are used to match the original C semantics.\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliWarmupHash",
                    "main_purpose": "初始化哈希结构的当前哈希值字段，基于输入数组的指定位置的一个或两个字节更新哈希值。",
                    "detailed_logic": "函数接收一个字节数组指针、起始位置、结束位置以及一个哈希结构指针。首先调用UpdateHashValue函数，使用数组中pos位置的字节更新哈希值。如果pos + 1小于end，则进一步调用UpdateHashValue函数，使用数组中pos + 1位置的字节更新哈希值。这样可以确保哈希结构的当前哈希值字段被初始化为基于输入数组的前两个字节的值。",
                    "error_handling": "函数未显式进行错误检查或处理。假定输入参数有效，例如数组指针非空且pos和end的范围合法。",
                    "dependencies": {
                        "zopfli::ZopfliHash": {
                            "signature": "pub struct ZopfliHash",
                            "usage": "作为函数的输入参数，用于存储和更新哈希值。函数通过UpdateHashValue操作其val字段以更新当前哈希值。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                "signature": "void ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                "description": "/*\nAppends the length and distance to the LZ77 arrays of the ZopfliLZ77Store.\ncontext must be a ZopfliLZ77Store*.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliStoreLitLenDist (unsigned short length ,unsigned short dist ,size_t pos ,ZopfliLZ77Store *store ){size_t i ;/* Needed for using ZOPFLI_APPEND_DATA multiple times. */ size_t origsize =store ->size ;size_t llstart =ZOPFLI_NUM_LL *(origsize /ZOPFLI_NUM_LL );size_t dstart =ZOPFLI_NUM_D *(origsize /ZOPFLI_NUM_D );/* Everytime the index wraps around, a new cumulative histogram is made: we're\n    keeping one histogram value per LZ77 symbol rather than a full histogram for\n    each to save memory. */ if (origsize %ZOPFLI_NUM_LL ==0 ){size_t llsize =origsize ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){ZOPFLI_APPEND_DATA (origsize ==0 ?0 :store ->ll_counts [origsize -ZOPFLI_NUM_LL +i ],&store ->ll_counts ,&llsize );}}if (origsize %ZOPFLI_NUM_D ==0 ){size_t dsize =origsize ;for (i =0 ;i <ZOPFLI_NUM_D ;i ++){ZOPFLI_APPEND_DATA (origsize ==0 ?0 :store ->d_counts [origsize -ZOPFLI_NUM_D +i ],&store ->d_counts ,&dsize );}}ZOPFLI_APPEND_DATA (length ,&store ->litlens ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (dist ,&store ->dists ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (pos ,&store ->pos ,&store ->size );assert (length <259 );if (dist ==0 ){store ->size =origsize ;ZOPFLI_APPEND_DATA (length ,&store ->ll_symbol ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (0 ,&store ->d_symbol ,&store ->size );store ->ll_counts [llstart +length ]++;}else {store ->size =origsize ;ZOPFLI_APPEND_DATA (ZopfliGetLengthSymbol (length ),&store ->ll_symbol ,&store ->size );store ->size =origsize ;ZOPFLI_APPEND_DATA (ZopfliGetDistSymbol (dist ),&store ->d_symbol ,&store ->size );store ->ll_counts [llstart +ZopfliGetLengthSymbol (length )]++;store ->d_counts [dstart +ZopfliGetDistSymbol (dist )]++;}}",
                "rust_signature": "fn zopfli_store_lit_len_dist(length: u16, dist: u16, pos: usize, store: &mut ZopfliLZ77Store) {\n    // Placeholder implementation\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliStoreLitLenDist",
                    "main_purpose": "将给定的长度、距离和位置信息存储到ZopfliLZ77Store结构中，同时更新相关的符号和直方图数据，用于数据压缩算法。",
                    "detailed_logic": "1. 初始化变量origsize为当前存储的大小，并计算llstart和dstart，用于定位直方图的起始位置。2. 如果当前存储大小是ZOPFLI_NUM_LL的倍数，则更新ll_counts直方图，保留每个LZ77符号的累积直方图值。3. 如果当前存储大小是ZOPFLI_NUM_D的倍数，则更新d_counts直方图，类似于ll_counts的处理。4. 将length、dist和pos依次追加到litlens、dists和pos数组中，同时更新store的大小。5. 如果dist为0（表示literal），将length追加到ll_symbol数组，并将对应的ll_counts值递增。6. 如果dist不为0（表示长度-距离对），通过调用ZopfliGetLengthSymbol和ZopfliGetDistSymbol计算符号值，并分别追加到ll_symbol和d_symbol数组，同时更新ll_counts和d_counts直方图。",
                    "error_handling": "函数使用assert确保length小于259，避免越界错误。未对其他输入参数进行显式错误检查。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "作为存储结构，函数通过修改其字段（如litlens、dists、pos、ll_symbol、d_symbol、ll_counts、d_counts）来保存输入数据和更新直方图信息。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                "signature": "void ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                "description": "/*\nUpdates the hash values based on the current position in the array. All calls\nto this must be made for consecutive bytes.\n*/",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::UpdateHashValue(ZopfliHash *, unsigned char)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliUpdateHash (const unsigned char *array ,size_t pos ,size_t end ,ZopfliHash *h ){unsigned short hpos =pos &ZOPFLI_WINDOW_MASK ;size_t amount =0 ;UpdateHashValue (h ,pos +ZOPFLI_MIN_MATCH <=end ?array [pos +ZOPFLI_MIN_MATCH -1 ]:0 );h ->hashval [hpos ]=h ->val ;if (h ->head [h ->val ]!=-1 &&h ->hashval [h ->head [h ->val ]]==h ->val ){h ->prev [hpos ]=h ->head [h ->val ];}else h ->prev [hpos ]=hpos ;h ->head [h ->val ]=hpos ;/* Update \"same\". */ if (h ->same [(pos -1 )&ZOPFLI_WINDOW_MASK ]>1 ){amount =h ->same [(pos -1 )&ZOPFLI_WINDOW_MASK ]-1 ;}while (pos +amount +1 <end &&array [pos ]==array [pos +amount +1 ]&&amount <(unsigned short )(-1 )){amount ++;}h ->same [hpos ]=amount ;h ->val2 =((h ->same [hpos ]-ZOPFLI_MIN_MATCH )&255 )^h ->val ;h ->hashval2 [hpos ]=h ->val2 ;if (h ->head2 [h ->val2 ]!=-1 &&h ->hashval2 [h ->head2 [h ->val2 ]]==h ->val2 ){h ->prev2 [hpos ]=h ->head2 [h ->val2 ];}else h ->prev2 [hpos ]=hpos ;h ->head2 [h ->val2 ]=hpos ;}",
                "rust_signature": "pub fn zopfli_update_hash(array: &[u8], pos: usize, end: usize, h: &mut ZopfliHash) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliUpdateHash",
                    "main_purpose": "更新哈希结构ZopfliHash的状态，包括主哈希值和辅助哈希值，以及记录重复字节的数量。",
                    "detailed_logic": "函数首先计算当前位置在滑动窗口中的索引hpos。然后调用UpdateHashValue更新当前的哈希值h->val。接着更新主哈希表head和prev：如果当前哈希值在head中已有记录且对应的hashval匹配，则将prev[hpos]设置为head[h->val]，否则将其设置为自身索引hpos。随后更新head[h->val]为当前索引hpos。接着计算当前字节与后续字节的重复数量amount，并更新same[hpos]为amount。然后计算辅助哈希值val2，更新辅助哈希表head2和prev2，逻辑与主哈希表类似。",
                    "error_handling": "函数未显式处理错误情况，假定输入参数均有效，且数组访问不会越界。",
                    "dependencies": {
                        "zopfli::ZopfliHash": {
                            "signature": "pub struct ZopfliHash",
                            "usage": "作为函数的输入参数，用于存储和更新哈希值、重复字节计数以及相关索引。函数直接操作其字段，包括head, prev, hashval, val, head2, prev2, hashval2, val2, 和same。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliResetHash(size_t, ZopfliHash *)": {
                "signature": "void ZopfliResetHash(size_t, ZopfliHash *)",
                "description": "/* Resets all fields of ZopfliHash. */",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliResetHash (size_t window_size ,ZopfliHash *h ){size_t i ;h ->val =0 ;for (i =0 ;i <65536 ;i ++){h ->head [i ]=-1 ;/* -1 indicates no head so far. */ }for (i =0 ;i <window_size ;i ++){h ->prev [i ]=i ;/* If prev[j] == j, then prev[j] is uninitialized. */ h ->hashval [i ]=-1 ;}for (i =0 ;i <window_size ;i ++){h ->same [i ]=0 ;}h ->val2 =0 ;for (i =0 ;i <65536 ;i ++){h ->head2 [i ]=-1 ;}for (i =0 ;i <window_size ;i ++){h ->prev2 [i ]=i ;h ->hashval2 [i ]=-1 ;}}",
                "rust_signature": "pub fn zopfli_reset_hash(window_size: usize, h: &mut ZopfliHash) {\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "ZopfliResetHash",
                    "main_purpose": "重置ZopfliHash结构的所有字段，将其初始化为默认状态，以便后续使用。",
                    "detailed_logic": "函数通过以下步骤重置ZopfliHash结构：\n1. 将字段 `val` 和 `val2` 初始化为0。\n2. 遍历 `head` 和 `head2` 数组，将所有元素设置为-1，表示没有头部索引。\n3. 遍历 `prev` 和 `prev2` 数组，将所有元素设置为其自身索引值，表示未初始化。\n4. 遍历 `hashval` 和 `hashval2` 数组，将所有元素设置为-1，表示没有哈希值。\n5. 遍历 `same` 数组，将所有元素设置为0，表示没有重复字节。",
                    "error_handling": "该函数没有显式的错误检查或处理机制，假定传入的 `ZopfliHash` 结构和 `window_size` 参数有效。",
                    "dependencies": {
                        "zopfli::ZopfliHash": {
                            "signature": "pub struct ZopfliHash",
                            "usage": "函数直接操作 `ZopfliHash` 结构的字段，包括 `head`, `prev`, `hashval`, `val`, `head2`, `prev2`, `hashval2`, `val2`, 和 `same`，对其进行初始化。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliCleanHash(ZopfliHash *)": {
                "signature": "void ZopfliCleanHash(ZopfliHash *)",
                "description": "/* Frees ZopfliHash memory. */",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliCleanHash (ZopfliHash *h ){free (h ->head );free (h ->prev );free (h ->hashval );free (h ->head2 );free (h ->prev2 );free (h ->hashval2 );free (h ->same );}",
                "rust_signature": "pub fn zopfli_clean_hash(h: &mut ZopfliHash) {\n    todo!(\"Function implementation is not provided. Memory management logic needs to be handled appropriately.\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "zopfli_clean_hash",
                    "main_purpose": "释放ZopfliHash结构中所有动态分配的内存，以避免内存泄漏。",
                    "detailed_logic": "函数依次调用free函数释放ZopfliHash结构中的动态分配内存，包括head、prev、hashval、head2、prev2、hashval2和same字段。这些字段均为指针类型，指向动态分配的内存块。函数没有执行任何其他操作，也没有返回值。",
                    "error_handling": "函数未进行任何错误检查或处理。如果传入的指针为NULL，free函数会安全地忽略操作，因此不会导致崩溃。但函数未检查ZopfliHash结构本身是否为NULL，可能导致未定义行为。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)": {
                "signature": "void ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)",
                "description": "/*\nDoes the same as ZopfliLZ77Optimal, but optimized for the fixed tree of the\ndeflate standard.\nThe fixed tree never gives the best compression. But this gives the best\npossible LZ77 encoding possible with the fixed tree.\nThis does not create or output any fixed tree, only LZ77 data optimized for\nusing with a fixed tree.\nIf instart is larger than 0, it uses values before instart as starting\ndictionary.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)",
                        "type": "functions"
                    },
                    "zopfli::GetCostFixed(unsigned int, unsigned int, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetCostFixed(unsigned int, unsigned int, void *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanHash(ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanHash(ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77OptimalFixed (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,ZopfliLZ77Store *store ){/* Dist to get to here with smallest cost. */ size_t blocksize =inend -instart ;unsigned short *length_array =(unsigned short *)malloc (sizeof (unsigned short )*(blocksize +1 ));unsigned short *path =0 ;size_t pathsize =0 ;ZopfliHash hash ;ZopfliHash *h =&hash ;float *costs =(float *)malloc (sizeof (float )*(blocksize +1 ));if (!costs )exit (-1 );/* Allocation failed. */ if (!length_array )exit (-1 );/* Allocation failed. */ ZopfliAllocHash (ZOPFLI_WINDOW_SIZE ,h );s ->blockstart =instart ;s ->blockend =inend ;/* Shortest path for fixed tree This one should give the shortest possible\n    result for fixed tree, no repeated runs are needed since the tree is known. */ LZ77OptimalRun (s ,in ,instart ,inend ,&path ,&pathsize ,length_array ,GetCostFixed ,0 ,store ,h ,costs );free (length_array );free (path );free (costs );ZopfliCleanHash (h );}",
                "rust_signature": "pub fn zopfli_lz77_optimal_fixed(\n    s: *mut ZopfliBlockState,\n    in_data: *const u8,\n    instart: usize,\n    inend: usize,\n    store: *mut ZopfliLZ77Store,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliLZ77OptimalFixed",
                    "main_purpose": "优化LZ77压缩过程，使用固定哈夫曼树计算最优路径并存储压缩结果。",
                    "detailed_logic": "函数首先计算输入数据块的大小，并为存储路径、长度数组和成本数组分配内存。然后初始化哈希结构以支持压缩过程。接着调用LZ77OptimalRun函数，通过计算最优路径和成本模型来优化压缩结果，并将结果存储到提供的store中。最后释放动态分配的内存并清理哈希结构。",
                    "error_handling": "函数检查动态内存分配是否成功，如果分配失败则调用exit(-1)终止程序。未对其他可能的错误情况进行处理。",
                    "dependencies": {
                        "zopfli::ZopfliBlockState": {
                            "signature": "pub struct ZopfliBlockState",
                            "usage": "传递当前块的状态，包括块的起始和结束位置，以及压缩选项和缓存。用于LZ77OptimalRun函数的压缩优化过程。"
                        },
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "pub struct ZopfliLZ77Store",
                            "usage": "用于存储压缩结果，包括字面长度、距离和其他相关信息。由LZ77OptimalRun函数填充。"
                        },
                        "zopfli::ZopfliHash": {
                            "signature": "pub struct ZopfliHash",
                            "usage": "用于存储哈希值和索引，支持LZ77压缩过程的快速查找和匹配。由ZopfliAllocHash初始化并由ZopfliCleanHash释放。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliAllocHash(size_t, ZopfliHash *)": {
                "signature": "void ZopfliAllocHash(size_t, ZopfliHash *)",
                "description": "/* Allocates ZopfliHash memory. */",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliAllocHash (size_t window_size ,ZopfliHash *h ){h ->head =(int *)malloc (sizeof (*h ->head )*65536 );h ->prev =(unsigned short *)malloc (sizeof (*h ->prev )*window_size );h ->hashval =(int *)malloc (sizeof (*h ->hashval )*window_size );h ->same =(unsigned short *)malloc (sizeof (*h ->same )*window_size );h ->head2 =(int *)malloc (sizeof (*h ->head2 )*65536 );h ->prev2 =(unsigned short *)malloc (sizeof (*h ->prev2 )*window_size );h ->hashval2 =(int *)malloc (sizeof (*h ->hashval2 )*window_size );}",
                "rust_signature": "pub fn zopfli_alloc_hash(window_size: usize, h: &mut ZopfliHash) {\n    todo!(\"Memory allocation logic is not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "zopfli_alloc_hash",
                    "main_purpose": "为ZopfliHash结构的多个字段分配内存，以支持哈希值和索引的存储与操作。",
                    "detailed_logic": "函数接收一个窗口大小参数和一个ZopfliHash结构的可变引用。它依次为ZopfliHash结构中的head、prev、hashval、same、head2、prev2和hashval2字段分配内存。head和head2分配了65536个整数大小的内存块，用于存储哈希值到最近出现索引的映射。prev、prev2、hashval和hashval2根据window_size参数分配内存，用于存储索引之间的关系和哈希值。same字段也根据window_size分配内存，用于存储重复字节的计数。",
                    "error_handling": "函数未包含任何显式的错误检查或处理机制。如果malloc分配失败，返回的指针将为NULL，但函数未对此进行检查或处理，可能导致后续操作出现未定义行为。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliCleanBlockState(ZopfliBlockState *)": {
                "signature": "void ZopfliCleanBlockState(ZopfliBlockState *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCleanCache(ZopfliLongestMatchCache *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanCache(ZopfliLongestMatchCache *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCleanBlockState (ZopfliBlockState *s ){if (s ->lmc ){ZopfliCleanCache (s ->lmc );free (s ->lmc );}}",
                "rust_signature": "pub fn zopfli_clean_block_state(s: &mut ZopfliBlockState) {\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliCleanBlockState",
                    "main_purpose": "释放ZopfliBlockState结构体中的动态内存，以避免内存泄漏。",
                    "detailed_logic": "函数检查ZopfliBlockState结构体的lmc字段是否为非空指针。如果是非空指针，则调用ZopfliCleanCache函数释放与lmc相关的动态内存，随后调用free函数释放lmc指针本身的内存。",
                    "error_handling": "函数未显式处理错误，例如lmc字段为空或free函数失败的情况。假设调用者确保传入的结构体和其字段有效。",
                    "dependencies": {
                        "zopfli::ZopfliBlockState": {
                            "signature": "pub struct ZopfliBlockState",
                            "usage": "函数通过访问ZopfliBlockState结构体的lmc字段来检查是否需要释放内存。lmc字段是一个可变指针，指向动态分配的ZopfliLongestMatchCache结构体。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliCleanCache(ZopfliLongestMatchCache *)": {
                "signature": "void ZopfliCleanCache(ZopfliLongestMatchCache *)",
                "description": "/* Frees up the memory of the ZopfliLongestMatchCache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliCleanCache (ZopfliLongestMatchCache *lmc ){free (lmc ->length );free (lmc ->dist );free (lmc ->sublen );}",
                "rust_signature": "fn zopfli_clean_cache(lmc: *mut ZopfliLongestMatchCache) {\n    // Placeholder implementation\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "zopfli_clean_cache",
                    "main_purpose": "释放与ZopfliLongestMatchCache结构体相关的动态内存，以避免内存泄漏。",
                    "detailed_logic": "函数接收一个指向ZopfliLongestMatchCache结构体的指针，并依次释放该结构体中的三个动态分配的成员：length、dist和sublen。每个成员通过调用free函数释放内存，确保不再占用系统资源。",
                    "error_handling": "该函数没有显式的错误处理机制。如果传入的指针为NULL或指向的成员未正确分配内存，可能会导致未定义行为。此外，函数未检查释放内存后的指针是否需要置为NULL以避免悬空指针问题。",
                    "dependencies": {
                        "zopfli::ZopfliLongestMatchCache": {
                            "signature": "struct ZopfliLongestMatchCache { length: *mut u16, dist: *mut u16, sublen: *mut u8 }",
                            "usage": "函数通过访问ZopfliLongestMatchCache结构体的三个成员（length、dist、sublen），调用free函数释放这些成员指向的动态内存。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                "signature": "void ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitCache(size_t, ZopfliLongestMatchCache *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitCache(size_t, ZopfliLongestMatchCache *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliInitBlockState (const ZopfliOptions *options ,size_t blockstart ,size_t blockend ,int add_lmc ,ZopfliBlockState *s ){s ->options =options ;s ->blockstart =blockstart ;s ->blockend =blockend ;if (add_lmc ){s ->lmc =(ZopfliLongestMatchCache *)malloc (sizeof (ZopfliLongestMatchCache ));ZopfliInitCache (blockend -blockstart ,s ->lmc );}else {s ->lmc =0 ;}}",
                "rust_signature": "pub fn zopfli_init_block_state(\n    options: *const ZopfliOptions,\n    blockstart: usize,\n    blockend: usize,\n    add_lmc: i32,\n    s: *mut ZopfliBlockState,\n) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliInitBlockState",
                    "main_purpose": "初始化ZopfliBlockState结构体，用于表示一个压缩块的状态，并根据参数决定是否分配和初始化最长匹配缓存。",
                    "detailed_logic": "函数接收压缩选项、块的起始和结束位置、是否添加最长匹配缓存的标志，以及一个指向ZopfliBlockState结构体的指针。首先将压缩选项、块起始位置和结束位置赋值给结构体的对应字段。如果add_lmc为非零值，则分配内存用于最长匹配缓存，并调用ZopfliInitCache函数初始化该缓存；否则，将lmc字段设置为NULL。",
                    "error_handling": "函数未显式处理内存分配失败的情况。如果malloc返回NULL，可能会导致后续操作出现未定义行为。",
                    "dependencies": {
                        "zopfli::ZopfliOptions": {
                            "signature": "pub struct ZopfliOptions",
                            "usage": "作为输入参数传递给函数，并直接赋值给ZopfliBlockState结构体的options字段，用于存储压缩选项。"
                        },
                        "zopfli::ZopfliBlockState": {
                            "signature": "pub struct ZopfliBlockState",
                            "usage": "函数的主要操作对象。通过指针修改其字段，包括options、blockstart、blockend和lmc，以初始化块状态。"
                        },
                        "zopfli::ZopfliLongestMatchCache": {
                            "signature": "struct ZopfliLongestMatchCache",
                            "usage": "在add_lmc为非零时分配内存并初始化，用于存储压缩算法的最长匹配缓存数据。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliInitCache(size_t, ZopfliLongestMatchCache *)": {
                "signature": "void ZopfliInitCache(size_t, ZopfliLongestMatchCache *)",
                "description": "/* Initializes the ZopfliLongestMatchCache. */",
                "dependencies": {
                    "zopfli::ZopfliLongestMatchCache": {
                        "return_type": "ZopfliLongestMatchCache",
                        "qualified_name": "zopfli::ZopfliLongestMatchCache",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliInitCache (size_t blocksize ,ZopfliLongestMatchCache *lmc ){size_t i ;lmc ->length =(unsigned short *)malloc (sizeof (unsigned short )*blocksize );lmc ->dist =(unsigned short *)malloc (sizeof (unsigned short )*blocksize );/* Rather large amount of memory. */ lmc ->sublen =(unsigned char *)malloc (ZOPFLI_CACHE_LENGTH *3 *blocksize );if (lmc ->sublen ==NULL ){fprintf (stderr ,\"Error: Out of memory. Tried allocating %lu bytes of memory.\\n\" ,(unsigned long )ZOPFLI_CACHE_LENGTH *3 *blocksize );exit (EXIT_FAILURE );}/* length > 0 and dist 0 is invalid combination, which indicates on purpose\n    that this cache value is not filled in yet. */ for (i =0 ;i <blocksize ;i ++)lmc ->length [i ]=1 ;for (i =0 ;i <blocksize ;i ++)lmc ->dist [i ]=0 ;for (i =0 ;i <ZOPFLI_CACHE_LENGTH *blocksize *3 ;i ++)lmc ->sublen [i ]=0 ;}",
                "rust_signature": "fn zopfli_init_cache(blocksize: usize, lmc: &mut ZopfliLongestMatchCache) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliInitCache",
                    "main_purpose": "初始化ZopfliLongestMatchCache结构体的成员变量，为压缩算法的缓存分配内存并设置初始值。",
                    "detailed_logic": "函数接收一个块大小和一个ZopfliLongestMatchCache结构体指针。首先为结构体的三个成员变量（length, dist, sublen）分配内存，分配的大小基于块大小和预定义的常量ZOPFLI_CACHE_LENGTH。然后，初始化length数组的所有元素为1，dist数组的所有元素为0，sublen数组的所有元素为0。通过这些初始化，确保缓存中的值在后续使用前具有明确的初始状态。",
                    "error_handling": "函数检查sublen分配内存是否成功。如果分配失败，打印错误信息到标准错误流，显示尝试分配的内存大小，并调用exit(EXIT_FAILURE)终止程序。对于length和dist的内存分配，函数未显式检查分配是否成功。",
                    "dependencies": {
                        "zopfli::ZopfliLongestMatchCache": {
                            "signature": "struct ZopfliLongestMatchCache { length: *mut u16, dist: *mut u16, sublen: *mut u8 }",
                            "usage": "函数通过指针访问ZopfliLongestMatchCache结构体的成员变量，为它们分配内存并初始化值。length和dist分别存储匹配长度和距离的缓存，sublen存储子匹配长度的缓存。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                "signature": "void ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliCleanLZ77Store (ZopfliLZ77Store *store ){free (store ->litlens );free (store ->dists );free (store ->pos );free (store ->ll_symbol );free (store ->d_symbol );free (store ->ll_counts );free (store ->d_counts );}",
                "rust_signature": "fn zopfli_clean_lz77_store(store: &mut ZopfliLZ77Store) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "zopfli_clean_lz77_store",
                    "main_purpose": "释放ZopfliLZ77Store结构体中动态分配的内存，确保资源得以正确清理。",
                    "detailed_logic": "函数依次调用free函数释放ZopfliLZ77Store结构体中的各个动态分配的指针成员，包括litlens、dists、pos、ll_symbol、d_symbol、ll_counts和d_counts。这些指针指向动态分配的内存块，释放它们可以避免内存泄漏。函数没有进行任何其他操作或逻辑处理。",
                    "error_handling": "函数没有显式的错误检查或处理机制。假设传入的指针成员已经正确初始化并指向有效的动态分配内存。如果传入的指针为NULL，free函数会安全地忽略该操作。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                "signature": "void ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "void ZopfliInitLZ77Store (const unsigned char *data ,ZopfliLZ77Store *store ){store ->size =0 ;store ->litlens =0 ;store ->dists =0 ;store ->pos =0 ;store ->data =data ;store ->ll_symbol =0 ;store ->d_symbol =0 ;store ->ll_counts =0 ;store ->d_counts =0 ;}",
                "rust_signature": "fn zopfli_init_lz77_store(data: *const u8, store: *mut ZopfliLZ77Store) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "zopfli_init_lz77_store",
                    "main_purpose": "初始化一个ZopfliLZ77Store结构体，将其所有字段设置为默认值或初始状态。",
                    "detailed_logic": "函数接收一个指向原始数据的指针和一个指向ZopfliLZ77Store结构体的指针。它将结构体的各个字段设置为初始值：size设置为0，litlens设置为NULL，dists设置为NULL，pos设置为NULL，data设置为传入的data指针，ll_symbol设置为NULL，d_symbol设置为NULL，ll_counts设置为NULL，d_counts设置为NULL。这些初始值表示结构体尚未存储任何LZ77编码数据。",
                    "error_handling": "该函数没有任何错误检查或处理机制，假定传入的指针均有效。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "函数直接操作传入的ZopfliLZ77Store结构体指针，将其字段设置为初始值。data字段被设置为传入的data指针，其余字段均设置为NULL或0。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "double ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nCalculates block size in bits, automatically using the best btype.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                        "type": "functions"
                    }
                },
                "full_text": "double ZopfliCalculateBlockSizeAutoType (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){double uncompressedcost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,0 );/* Don't do the expensive fixed cost calculation for larger blocks that are\n       unlikely to use it. */ double fixedcost =(lz77 ->size >1000 )?uncompressedcost :ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,1 );double dyncost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,2 );return (uncompressedcost <fixedcost &&uncompressedcost <dyncost )?uncompressedcost :(fixedcost <dyncost ?fixedcost :dyncost );}",
                "rust_signature": "fn zopfli_calculate_block_size_auto_type(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliCalculateBlockSizeAutoType",
                    "main_purpose": "根据未压缩、固定哈夫曼编码和动态哈夫曼编码三种块类型，计算LZ77块的最小压缩大小。",
                    "detailed_logic": "函数首先计算未压缩块的压缩成本（uncompressedcost）。接着，判断LZ77块的大小是否大于1000。如果大于1000，则直接将未压缩成本作为固定哈夫曼编码的成本（fixedcost），以避免对大块进行昂贵的固定成本计算；否则，计算固定哈夫曼编码的成本。然后，计算动态哈夫曼编码的成本（dyncost）。最后，比较三种成本，返回最小值作为结果。",
                    "error_handling": "函数本身没有显式的错误处理逻辑，但依赖函数ZopfliCalculateBlockSize可能会处理错误情况。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "函数通过访问lz77.size字段判断LZ77块的大小是否大于1000，从而决定是否跳过固定哈夫曼编码的成本计算。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                "signature": "void ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                "description": "/*\nDoes LZ77 using an algorithm similar to gzip, with lazy matching, rather than\nwith the slow but better \"squeeze\" implementation.\nThe result is placed in the ZopfliLZ77Store.\nIf instart is larger than 0, it uses values before instart as starting\ndictionary.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliResetHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliResetHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::GetLengthScore(int, int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::GetLengthScore(int, int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77Greedy (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,ZopfliLZ77Store *store ,ZopfliHash *h ){size_t i =0 ,j ;unsigned short leng ;unsigned short dist ;int lengthscore ;size_t windowstart =instart >ZOPFLI_WINDOW_SIZE ?instart -ZOPFLI_WINDOW_SIZE :0 ;unsigned short dummysublen [259 ];/* Lazy matching. */ unsigned prev_length =0 ;unsigned prev_match =0 ;int prevlengthscore ;int match_available =0 ;if (instart ==inend )return ;ZopfliResetHash (ZOPFLI_WINDOW_SIZE ,h );ZopfliWarmupHash (in ,windowstart ,inend ,h );for (i =windowstart ;i <instart ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );}for (i =instart ;i <inend ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );ZopfliFindLongestMatch (s ,h ,in ,i ,inend ,ZOPFLI_MAX_MATCH ,dummysublen ,&dist ,&leng );lengthscore =GetLengthScore (leng ,dist );/* Lazy matching. */ prevlengthscore =GetLengthScore (prev_length ,prev_match );if (match_available ){match_available =0 ;if (lengthscore >prevlengthscore +1 ){ZopfliStoreLitLenDist (in [i -1 ],0 ,i -1 ,store );if (lengthscore >=ZOPFLI_MIN_MATCH &&leng <ZOPFLI_MAX_MATCH ){match_available =1 ;prev_length =leng ;prev_match =dist ;continue ;}}else {/* Add previous to output. */ leng =prev_length ;dist =prev_match ;lengthscore =prevlengthscore ;/* Add to output. */ ZopfliVerifyLenDist (in ,inend ,i -1 ,dist ,leng );ZopfliStoreLitLenDist (leng ,dist ,i -1 ,store );for (j =2 ;j <leng ;j ++){assert (i <inend );i ++;ZopfliUpdateHash (in ,i ,inend ,h );}continue ;}}else if (lengthscore >=ZOPFLI_MIN_MATCH &&leng <ZOPFLI_MAX_MATCH ){match_available =1 ;prev_length =leng ;prev_match =dist ;continue ;}/* End of lazy matching. */ /* Add to output. */ if (lengthscore >=ZOPFLI_MIN_MATCH ){ZopfliVerifyLenDist (in ,inend ,i ,dist ,leng );ZopfliStoreLitLenDist (leng ,dist ,i ,store );}else {leng =1 ;ZopfliStoreLitLenDist (in [i ],0 ,i ,store );}for (j =1 ;j <leng ;j ++){assert (i <inend );i ++;ZopfliUpdateHash (in ,i ,inend ,h );}}}",
                "rust_signature": "pub fn zopfli_lz77_greedy(\n    s: &mut ZopfliBlockState,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    store: &mut ZopfliLZ77Store,\n    h: &mut ZopfliHash,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliLZ77Greedy",
                    "main_purpose": "实现一种贪婪的LZ77压缩算法，通过查找输入数据中的最长匹配字符串并存储长度和距离信息来优化压缩。",
                    "detailed_logic": "函数首先初始化哈希结构并预热哈希值，然后逐字节扫描输入数据，更新哈希状态并查找最长匹配。使用懒匹配策略决定是否存储当前匹配或延迟处理。对于每个匹配，验证其长度和距离是否有效，并将匹配信息存储到LZ77存储结构中。未找到匹配时，将当前字节作为文字存储。函数通过循环和条件分支实现懒匹配逻辑，并在必要时跳过多字节以避免冗余计算。",
                    "error_handling": "函数通过条件检查确保输入范围有效（instart < inend），否则直接返回。使用断言（assert）验证循环中的索引是否在范围内，并在存储匹配信息前验证长度和距离的有效性。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliCalculateEntropy(const size_t *, size_t, double *)": {
                "signature": "void ZopfliCalculateEntropy(const size_t *, size_t, double *)",
                "description": "/*\nCalculates the entropy of each symbol, based on the counts of each symbol. The\nresult is similar to the result of ZopfliCalculateBitLengths, but with the\nactual theoritical bit lengths according to the entropy. Since the resulting\nvalues are fractional, they cannot be used to encode the tree specified by\nDEFLATE.\n*/",
                "dependencies": {},
                "full_text": "void ZopfliCalculateEntropy (const size_t *count ,size_t n ,double *bitlengths ){static const double kInvLog2 =1.4426950408889 ;/* 1.0 / log(2.0) */ unsigned sum =0 ;unsigned i ;double log2sum ;for (i =0 ;i <n ;++i ){sum +=count [i ];}log2sum =(sum ==0 ?log (n ):log (sum ))*kInvLog2 ;for (i =0 ;i <n ;++i ){/* When the count of the symbol is 0, but its cost is requested anyway, it\n        means the symbol will appear at least once anyway, so give it the cost as if\n        its count is 1.*/ if (count [i ]==0 )bitlengths [i ]=log2sum ;else bitlengths [i ]=log2sum -log (count [i ])*kInvLog2 ;/* Depending on compiler and architecture, the above subtraction of two\n        floating point numbers may give a negative result very close to zero\n        instead of zero (e.g. -5.973954e-17 with gcc 4.1.2 on Ubuntu 11.4). Clamp\n        it to zero. These floating point imprecisions do not affect the cost model\n        significantly so this is ok. */ if (bitlengths [i ]<0 &&bitlengths [i ]>-1e-5 )bitlengths [i ]=0 ;assert (bitlengths [i ]>=0 );}}",
                "rust_signature": "fn zopfli_calculate_entropy(count: &[usize], n: usize, bitlengths: &mut [f64]) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliCalculateEntropy",
                    "main_purpose": "计算每个符号的熵值（以比特为单位），用于压缩算法中的成本模型。",
                    "detailed_logic": "函数接收一个符号计数数组 `count`，其长度为 `n`，并计算每个符号的熵值，存储在 `bitlengths` 数组中。具体步骤如下：1. 计算符号计数数组的总和 `sum`。2. 根据 `sum` 的值计算对数基2的总和 `log2sum`，如果 `sum` 为0，则使用 `log(n)` 代替。3. 遍历符号计数数组 `count`，对于每个符号：   a. 如果符号计数为0，则将其熵值设置为 `log2sum`，表示该符号至少会出现一次。   b. 如果符号计数非0，则根据公式 `log2sum - log(count[i]) * kInvLog2` 计算熵值。   c. 如果计算结果接近于零但为负数（例如浮点误差导致的值在 -1e-5 到 0 之间），将其钳制为0。4. 使用断言确保所有计算结果均为非负值。",
                    "error_handling": "函数通过断言确保所有熵值计算结果为非负数。如果出现浮点误差导致的负值（接近零），会将其钳制为零以避免错误。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                "signature": "void ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CeilDiv(size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CeilDiv(size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliCopyLZ77Store (const ZopfliLZ77Store *source ,ZopfliLZ77Store *dest ){size_t i ;size_t llsize =ZOPFLI_NUM_LL *CeilDiv (source ->size ,ZOPFLI_NUM_LL );size_t dsize =ZOPFLI_NUM_D *CeilDiv (source ->size ,ZOPFLI_NUM_D );ZopfliCleanLZ77Store (dest );ZopfliInitLZ77Store (source ->data ,dest );dest ->litlens =(unsigned short *)malloc (sizeof (*dest ->litlens )*source ->size );dest ->dists =(unsigned short *)malloc (sizeof (*dest ->dists )*source ->size );dest ->pos =(size_t *)malloc (sizeof (*dest ->pos )*source ->size );dest ->ll_symbol =(unsigned short *)malloc (sizeof (*dest ->ll_symbol )*source ->size );dest ->d_symbol =(unsigned short *)malloc (sizeof (*dest ->d_symbol )*source ->size );dest ->ll_counts =(size_t *)malloc (sizeof (*dest ->ll_counts )*llsize );dest ->d_counts =(size_t *)malloc (sizeof (*dest ->d_counts )*dsize );/* Allocation failed. */ if (!dest ->litlens ||!dest ->dists )exit (-1 );if (!dest ->pos )exit (-1 );if (!dest ->ll_symbol ||!dest ->d_symbol )exit (-1 );if (!dest ->ll_counts ||!dest ->d_counts )exit (-1 );dest ->size =source ->size ;for (i =0 ;i <source ->size ;i ++){dest ->litlens [i ]=source ->litlens [i ];dest ->dists [i ]=source ->dists [i ];dest ->pos [i ]=source ->pos [i ];dest ->ll_symbol [i ]=source ->ll_symbol [i ];dest ->d_symbol [i ]=source ->d_symbol [i ];}for (i =0 ;i <llsize ;i ++){dest ->ll_counts [i ]=source ->ll_counts [i ];}for (i =0 ;i <dsize ;i ++){dest ->d_counts [i ]=source ->d_counts [i ];}}",
                "rust_signature": "fn zopfli_copy_lz77_store(source: &ZopfliLZ77Store, dest: &mut ZopfliLZ77Store) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliCopyLZ77Store",
                    "main_purpose": "复制一个ZopfliLZ77Store结构体的内容到另一个结构体，包括动态分配内存并复制所有字段数据。",
                    "detailed_logic": "函数首先清理目标结构体的现有内容，并初始化目标结构体的基本字段。接着，根据源结构体的大小动态分配内存，用于存储源结构体的各个字段数据。然后逐一复制源结构体的字段数据到目标结构体，包括litlens、dists、pos、ll_symbol、d_symbol、ll_counts和d_counts。最后更新目标结构体的size字段以匹配源结构体。",
                    "error_handling": "函数检查每次动态内存分配是否成功。如果任何分配失败，函数会立即调用exit(-1)终止程序运行。",
                    "dependencies": {
                        "zopfli::CeilDiv(size_t, size_t)": {
                            "signature": "pub fn ceil_div(a: usize, b: usize) -> usize",
                            "usage": "用于计算ll_counts和d_counts数组的大小，通过向上取整的方式确保分配足够的空间以存储数据。"
                        },
                        "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                            "signature": "fn zopfli_clean_lz77_store(store: &mut ZopfliLZ77Store)",
                            "usage": "在函数开始时调用，用于清理目标结构体dest的现有内容，释放其动态分配的内存。"
                        },
                        "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                            "signature": "fn zopfli_init_lz77_store(data: *const u8, store: *mut ZopfliLZ77Store)",
                            "usage": "在清理目标结构体后调用，用于初始化目标结构体dest的基本字段，使其处于默认状态并准备接受数据。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)": {
                "signature": "void ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)",
                "description": "/*\nCalculates lit/len and dist pairs for given data.\nIf instart is larger than 0, it uses values before instart as starting\ndictionary.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    },
                    "zopfli::InitRanState(RanState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitRanState(RanState *)",
                        "type": "functions"
                    },
                    "zopfli::InitStats(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitStats(SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::GetStatistics(const ZopfliLZ77Store *, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::GetStatistics(const ZopfliLZ77Store *, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)",
                        "type": "functions"
                    },
                    "zopfli::GetCostStat(unsigned int, unsigned int, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetCostStat(unsigned int, unsigned int, void *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCopyLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::CopyStats(SymbolStats *, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::CopyStats(SymbolStats *, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ClearStatFreqs(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ClearStatFreqs(SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateStatistics(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::CalculateStatistics(SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::RandomizeStatFreqs(RanState *, SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::RandomizeStatFreqs(RanState *, SymbolStats *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanHash(ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanHash(ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliLZ77Optimal (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,int numiterations ,ZopfliLZ77Store *store ){/* Dist to get to here with smallest cost. */ size_t blocksize =inend -instart ;unsigned short *length_array =(unsigned short *)malloc (sizeof (unsigned short )*(blocksize +1 ));unsigned short *path =0 ;size_t pathsize =0 ;ZopfliLZ77Store currentstore ;ZopfliHash hash ;ZopfliHash *h =&hash ;SymbolStats stats ,beststats ,laststats ;int i ;float *costs =(float *)malloc (sizeof (float )*(blocksize +1 ));double cost ;double bestcost =ZOPFLI_LARGE_FLOAT ;double lastcost =0 ;/* Try randomizing the costs a bit once the size stabilizes. */ RanState ran_state ;int lastrandomstep =-1 ;if (!costs )exit (-1 );/* Allocation failed. */ if (!length_array )exit (-1 );/* Allocation failed. */ InitRanState (&ran_state );InitStats (&stats );ZopfliInitLZ77Store (in ,&currentstore );ZopfliAllocHash (ZOPFLI_WINDOW_SIZE ,h );/* Do regular deflate, then loop multiple shortest path runs, each time using\n    the statistics of the previous run. */ /* Initial run. */ ZopfliLZ77Greedy (s ,in ,instart ,inend ,&currentstore ,h );GetStatistics (&currentstore ,&stats );/* Repeat statistics with each time the cost model from the previous stat\n    run. */ for (i =0 ;i <numiterations ;i ++){ZopfliCleanLZ77Store (&currentstore );ZopfliInitLZ77Store (in ,&currentstore );LZ77OptimalRun (s ,in ,instart ,inend ,&path ,&pathsize ,length_array ,GetCostStat ,(void *)&stats ,&currentstore ,h ,costs );cost =ZopfliCalculateBlockSize (&currentstore ,0 ,currentstore .size ,2 );if (s ->options ->verbose_more ||(s ->options ->verbose &&cost <bestcost )){fprintf (stderr ,\"Iteration %d: %d bit\\n\" ,i ,(int )cost );}if (cost <bestcost ){/* Copy to the output store. */ ZopfliCopyLZ77Store (&currentstore ,store );CopyStats (&stats ,&beststats );bestcost =cost ;}CopyStats (&stats ,&laststats );ClearStatFreqs (&stats );GetStatistics (&currentstore ,&stats );if (lastrandomstep !=-1 ){/* This makes it converge slower but better. Do it only once the\n            randomness kicks in so that if the user does few iterations, it gives a\n            better result sooner. */ AddWeighedStatFreqs (&stats ,1.0 ,&laststats ,0.5 ,&stats );CalculateStatistics (&stats );}if (i >5 &&cost ==lastcost ){CopyStats (&beststats ,&stats );RandomizeStatFreqs (&ran_state ,&stats );CalculateStatistics (&stats );lastrandomstep =i ;}lastcost =cost ;}free (length_array );free (path );free (costs );ZopfliCleanLZ77Store (&currentstore );ZopfliCleanHash (h );}",
                "rust_signature": "pub fn zopfli_lz77_optimal(\n    s: &mut ZopfliBlockState,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    num_iterations: i32,\n    store: &mut ZopfliLZ77Store,\n) {\n    // Placeholder for the function body. Original C code contains complex logic.\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliLZ77Optimal",
                    "main_purpose": "优化LZ77压缩过程，通过多次迭代和统计模型的调整，找到最优的压缩路径和成本模型。",
                    "detailed_logic": "函数首先初始化所需的状态和数据结构，包括随机状态、符号统计、LZ77存储和哈希表。然后执行一次贪婪的LZ77压缩以生成初始统计数据。接着，函数进入一个迭代循环，每次迭代中使用前一次的统计数据作为成本模型，调用LZ77OptimalRun函数计算最优路径和压缩结果。如果当前迭代的压缩成本低于之前的最佳成本，则更新最佳结果。函数还会在特定条件下随机化统计数据以避免局部最优解。最后，释放所有动态分配的内存并清理状态。",
                    "error_handling": "函数在内存分配失败时立即退出（调用exit(-1)）。此外，函数通过比较当前和上一次迭代的压缩成本来判断是否需要随机化统计数据，以避免陷入局部最优解。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)": {
                "signature": "void ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)",
                "description": "/*\nDoes blocksplitting on LZ77 data.\nThe output splitpoints are indices in the LZ77 data.\nmaxblocks: set a limit to the amount of blocks. Set to 0 to mean no limit.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::SplitCostContext": {
                        "return_type": "SplitCostContext",
                        "qualified_name": "zopfli::SplitCostContext",
                        "type": "structs"
                    },
                    "zopfli::FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)",
                        "type": "functions"
                    },
                    "zopfli::SplitCost(size_t, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::SplitCost(size_t, void *)",
                        "type": "functions"
                    },
                    "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::AddSorted(size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddSorted(size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliBlockSplitLZ77 (const ZopfliOptions *options ,const ZopfliLZ77Store *lz77 ,size_t maxblocks ,size_t **splitpoints ,size_t *npoints ){size_t lstart ,lend ;size_t i ;size_t llpos =0 ;size_t numblocks =1 ;unsigned char *done ;double splitcost ,origcost ;if (lz77 ->size <10 )return ;/* This code fails on tiny files. */ done =(unsigned char *)malloc (lz77 ->size );if (!done )exit (-1 );/* Allocation failed. */ for (i =0 ;i <lz77 ->size ;i ++)done [i ]=0 ;lstart =0 ;lend =lz77 ->size ;for (;;){SplitCostContext c ;if (maxblocks >0 &&numblocks >=maxblocks ){break ;}c .lz77 =lz77 ;c .start =lstart ;c .end =lend ;assert (lstart <lend );llpos =FindMinimum (SplitCost ,&c ,lstart +1 ,lend ,&splitcost );assert (llpos >lstart );assert (llpos <lend );origcost =EstimateCost (lz77 ,lstart ,lend );if (splitcost >origcost ||llpos ==lstart +1 ||llpos ==lend ){done [lstart ]=1 ;}else {AddSorted (llpos ,splitpoints ,npoints );numblocks ++;}if (!FindLargestSplittableBlock (lz77 ->size ,done ,*splitpoints ,*npoints ,&lstart ,&lend )){break ;/* No further split will probably reduce compression. */ }if (lend -lstart <10 ){break ;}}if (options ->verbose ){PrintBlockSplitPoints (lz77 ,*splitpoints ,*npoints );}free (done );}",
                "rust_signature": "pub fn zopfli_block_split_lz77(\n    options: *const ZopfliOptions, \n    lz77: *const ZopfliLZ77Store, \n    maxblocks: usize, \n    splitpoints: *mut *mut usize, \n    npoints: *mut usize\n) {\n    unsafe {\n        // Function body not implemented\n        todo!(\"Function body not implemented\");\n    }\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliBlockSplitLZ77",
                    "main_purpose": "将LZ77压缩数据分割为多个块，以优化压缩成本，同时限制块的数量。",
                    "detailed_logic": "函数首先检查输入的LZ77数据大小是否足够小，如果小于10则直接返回。然后分配一个标记数组用于跟踪已处理的块。函数通过循环不断尝试分割当前块，计算分割点的压缩成本，并与原始块的压缩成本进行比较。如果分割成本更低且分割点有效，则将分割点添加到结果数组中，并更新块的数量。每次分割后，函数会寻找未处理的最大可分割块，并继续尝试分割，直到无法进一步分割或达到最大块数限制。最后，如果启用了verbose选项，函数会打印分割点信息，并释放分配的内存。",
                    "error_handling": "函数检查LZ77数据大小是否小于10并提前返回。分配内存时检查是否成功，如果失败则调用exit(-1)终止程序。函数通过断言确保分割点的有效性（例如分割点必须在当前块范围内）。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)": {
                "signature": "void ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)",
                "description": "/*\nDoes blocksplitting on uncompressed data.\nThe output splitpoints are indices in the uncompressed bytes.\n\noptions: general program options.\nin: uncompressed input data\ninstart: where to start splitting\ninend: where to end splitting (not inclusive)\nmaxblocks: maximum amount of blocks to split into, or 0 for no limit\nsplitpoints: dynamic array to put the resulting split point coordinates into.\nThe coordinates are indices in the input array.\nnpoints: pointer to amount of splitpoints, for the dynamic array. The amount of\nblocks is the amount of splitpoitns + 1.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAllocHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77Greedy(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanHash(ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanHash(ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliBlockSplit (const ZopfliOptions *options ,const unsigned char *in ,size_t instart ,size_t inend ,size_t maxblocks ,size_t **splitpoints ,size_t *npoints ){size_t pos =0 ;size_t i ;ZopfliBlockState s ;size_t *lz77splitpoints =0 ;size_t nlz77points =0 ;ZopfliLZ77Store store ;ZopfliHash hash ;ZopfliHash *h =&hash ;ZopfliInitLZ77Store (in ,&store );ZopfliInitBlockState (options ,instart ,inend ,0 ,&s );ZopfliAllocHash (ZOPFLI_WINDOW_SIZE ,h );*npoints =0 ;*splitpoints =0 ;/* Unintuitively, Using a simple LZ77 method here instead of ZopfliLZ77Optimal\n    results in better blocks. */ ZopfliLZ77Greedy (&s ,in ,instart ,inend ,&store ,h );ZopfliBlockSplitLZ77 (options ,&store ,maxblocks ,&lz77splitpoints ,&nlz77points );/* Convert LZ77 positions to positions in the uncompressed input. */ pos =instart ;if (nlz77points >0 ){for (i =0 ;i <store .size ;i ++){size_t length =store .dists [i ]==0 ?1 :store .litlens [i ];if (lz77splitpoints [*npoints ]==i ){ZOPFLI_APPEND_DATA (pos ,splitpoints ,npoints );if (*npoints ==nlz77points )break ;}pos +=length ;}}assert (*npoints ==nlz77points );free (lz77splitpoints );ZopfliCleanBlockState (&s );ZopfliCleanLZ77Store (&store );ZopfliCleanHash (h );}",
                "rust_signature": "pub fn zopfli_block_split(\n    options: &ZopfliOptions,\n    in_data: *const u8,\n    instart: usize,\n    inend: usize,\n    maxblocks: usize,\n    splitpoints: &mut *mut usize,\n    npoints: &mut usize,\n) {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliBlockSplit",
                    "main_purpose": "将输入数据分割为多个压缩块，以优化压缩效率，同时限制块的数量。",
                    "detailed_logic": "函数首先初始化LZ77存储结构和块状态，并为哈希结构分配内存。然后使用贪婪的LZ77算法对输入数据进行压缩，并将结果存储在LZ77存储结构中。接着调用块分割函数，将LZ77压缩数据分割为多个块，并将分割点转换为未压缩输入数据中的位置。最后，函数释放所有动态分配的内存并清理状态。",
                    "error_handling": "函数通过assert语句验证分割点数量是否与预期一致。如果分配内存失败或输入参数无效，可能会导致未定义行为，但函数本身未显式处理这些错误。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                "signature": "void ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliAppendLZ77Store (const ZopfliLZ77Store *store ,ZopfliLZ77Store *target ){size_t i ;for (i =0 ;i <store ->size ;i ++){ZopfliStoreLitLenDist (store ->litlens [i ],store ->dists [i ],store ->pos [i ],target );}}",
                "rust_signature": "fn zopfli_append_lz77_store(store: &ZopfliLZ77Store, target: &mut ZopfliLZ77Store) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "zopfli_append_lz77_store",
                    "main_purpose": "将一个ZopfliLZ77Store中的所有LZ77命令（字面值/长度和距离对）追加到另一个ZopfliLZ77Store中。",
                    "detailed_logic": "函数遍历源ZopfliLZ77Store中的所有LZ77命令（通过其size字段确定命令数量）。对于每个命令，调用ZopfliStoreLitLenDist函数，将字面值/长度、距离和位置追加到目标ZopfliLZ77Store中。",
                    "error_handling": "函数本身没有显式的错误检查或处理机制，假定输入的store和target指针有效，并且ZopfliStoreLitLenDist函数能够正确处理输入数据。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store { litlens: *mut u16, dists: *mut u16, size: usize, data: *const u8, pos: *mut usize, ll_symbol: *mut u16, d_symbol: *mut u16, ll_counts: *mut usize, d_counts: *mut usize }",
                            "usage": "源store提供LZ77命令的字面值/长度、距离和位置数据，目标store用于存储追加后的LZ77命令。函数依赖store的size字段确定命令数量，依赖litlens、dists和pos数组存储每个命令的具体数据。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nDeflate a part, to allow ZopfliDeflate() to use multiple master blocks if\nneeded.\nIt is possible to call this function multiple times in a row, shifting\ninstart and inend to next bytes of the data. If instart is larger than 0, then\nprevious bytes are used as the initial dictionary for LZ77.\nThis function will usually output multiple deflate blocks. If final is 1, then\nthe final bit will be set on the last block.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliBlockSplit(const ZopfliOptions *, const unsigned char *, size_t, size_t, size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77Optimal(ZopfliBlockState *, const unsigned char *, size_t, size_t, int, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliAppendLZ77Store(const ZopfliLZ77Store *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliBlockSplitLZ77(const ZopfliOptions *, const ZopfliLZ77Store *, size_t, size_t **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliDeflatePart (const ZopfliOptions *options ,int btype ,int final ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t i ;/* byte coordinates rather than lz77 index */ size_t *splitpoints_uncompressed =0 ;size_t npoints =0 ;size_t *splitpoints =0 ;double totalcost =0 ;ZopfliLZ77Store lz77 ;/* If btype=2 is specified, it tries all block types. If a lesser btype is\n    given, then however it forces that one. Neither of the lesser types needs\n    block splitting as they have no dynamic huffman trees. */ if (btype ==0 ){AddNonCompressedBlock (options ,final ,in ,instart ,inend ,bp ,out ,outsize );return ;}else if (btype ==1 ){ZopfliLZ77Store store ;ZopfliBlockState s ;ZopfliInitLZ77Store (in ,&store );ZopfliInitBlockState (options ,instart ,inend ,1 ,&s );ZopfliLZ77OptimalFixed (&s ,in ,instart ,inend ,&store );AddLZ77Block (options ,btype ,final ,&store ,0 ,store .size ,0 ,bp ,out ,outsize );ZopfliCleanBlockState (&s );ZopfliCleanLZ77Store (&store );return ;}if (options ->blocksplitting ){ZopfliBlockSplit (options ,in ,instart ,inend ,options ->blocksplittingmax ,&splitpoints_uncompressed ,&npoints );splitpoints =(size_t *)malloc (sizeof (*splitpoints )*npoints );}ZopfliInitLZ77Store (in ,&lz77 );for (i =0 ;i <=npoints ;i ++){size_t start =i ==0 ?instart :splitpoints_uncompressed [i -1 ];size_t end =i ==npoints ?inend :splitpoints_uncompressed [i ];ZopfliBlockState s ;ZopfliLZ77Store store ;ZopfliInitLZ77Store (in ,&store );ZopfliInitBlockState (options ,start ,end ,1 ,&s );ZopfliLZ77Optimal (&s ,in ,start ,end ,options ->numiterations ,&store );totalcost +=ZopfliCalculateBlockSizeAutoType (&store ,0 ,store .size );ZopfliAppendLZ77Store (&store ,&lz77 );if (i <npoints )splitpoints [i ]=lz77 .size ;ZopfliCleanBlockState (&s );ZopfliCleanLZ77Store (&store );}/* Second block splitting attempt */ if (options ->blocksplitting &&npoints >1 ){size_t *splitpoints2 =0 ;size_t npoints2 =0 ;double totalcost2 =0 ;ZopfliBlockSplitLZ77 (options ,&lz77 ,options ->blocksplittingmax ,&splitpoints2 ,&npoints2 );for (i =0 ;i <=npoints2 ;i ++){size_t start =i ==0 ?0 :splitpoints2 [i -1 ];size_t end =i ==npoints2 ?lz77 .size :splitpoints2 [i ];totalcost2 +=ZopfliCalculateBlockSizeAutoType (&lz77 ,start ,end );}if (totalcost2 <totalcost ){free (splitpoints );splitpoints =splitpoints2 ;npoints =npoints2 ;}else {free (splitpoints2 );}}for (i =0 ;i <=npoints ;i ++){size_t start =i ==0 ?0 :splitpoints [i -1 ];size_t end =i ==npoints ?lz77 .size :splitpoints [i ];AddLZ77BlockAutoType (options ,i ==npoints &&final ,&lz77 ,start ,end ,0 ,bp ,out ,outsize );}ZopfliCleanLZ77Store (&lz77 );free (splitpoints );free (splitpoints_uncompressed );}",
                "rust_signature": "pub fn zopfli_deflate_part(\n    options: &ZopfliOptions,\n    btype: i32,\n    final_block: i32,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    bp: &mut u8,\n    out: &mut Vec<u8>,\n    outsize: &mut usize,\n) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nCompresses according to the deflate specification and append the compressed\nresult to the output.\nThis function will usually output multiple deflate blocks. If final is 1, then\nthe final bit will be set on the last block.\n\noptions: global program options\nbtype: the deflate block type. Use 2 for best compression.\n-0: non compressed blocks (00)\n-1: blocks with fixed tree (01)\n-2: blocks with dynamic tree (10)\nfinal: whether this is the last section of the input, sets the final bit to the\nlast deflate block.\nin: the input bytes\ninsize: number of input bytes\nbp: bit pointer for the output array. This must initially be 0, and for\nconsecutive calls must be reused (it can have values from 0-7). This is\nbecause deflate appends blocks as bit-based data, rather than on byte\nboundaries.\nout: pointer to the dynamic output array to which the result is appended. Must\nbe freed after use.\noutsize: pointer to the dynamic output array size.\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliDeflatePart(const ZopfliOptions *, int, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void ZopfliDeflate (const ZopfliOptions *options ,int btype ,int final ,const unsigned char *in ,size_t insize ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t offset =*outsize ;size_t i =0 ;do {int masterfinal =(i +ZOPFLI_MASTER_BLOCK_SIZE >=insize );int final2 =final &&masterfinal ;size_t size =masterfinal ?insize -i :ZOPFLI_MASTER_BLOCK_SIZE ;ZopfliDeflatePart (options ,btype ,final2 ,in ,i ,i +size ,bp ,out ,outsize );i +=size ;}while (i <insize );if (options ->verbose ){fprintf (stderr ,\"Original Size: %lu, Deflate: %lu, Compression: %.2f%%\\n\" ,(unsigned long )insize ,(unsigned long )(*outsize -offset ),100.0 *(double )(insize -(*outsize -offset ))/(double )insize );}}",
                "rust_signature": "pub fn zopfli_deflate(\n    options: *const ZopfliOptions,\n    btype: i32,\n    final_block: i32,\n    input: *const u8,\n    insize: usize,\n    bp: *mut u8,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 3
            },
            "ZopfliGetLengthSymbol(int)": {
                "signature": "int ZopfliGetLengthSymbol(int)",
                "description": "/*\nGets the symbol for the given length, cfr. the DEFLATE spec.\nReturns the symbol in the range [257-285] (inclusive)\n*/",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthSymbol (int l ){static const int table [259 ]={0 ,0 ,0 ,257 ,258 ,259 ,260 ,261 ,262 ,263 ,264 ,265 ,265 ,266 ,266 ,267 ,267 ,268 ,268 ,269 ,269 ,269 ,269 ,270 ,270 ,270 ,270 ,271 ,271 ,271 ,271 ,272 ,272 ,272 ,272 ,273 ,273 ,273 ,273 ,273 ,273 ,273 ,273 ,274 ,274 ,274 ,274 ,274 ,274 ,274 ,274 ,275 ,275 ,275 ,275 ,275 ,275 ,275 ,275 ,276 ,276 ,276 ,276 ,276 ,276 ,276 ,276 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,277 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,278 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,279 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,280 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,281 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,282 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,283 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,284 ,285 };return table [l ];}",
                "rust_signature": "fn zopfli_get_length_symbol(l: usize) -> i32 {\n    todo!(\"Function implementation is not provided.\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "zopfli_get_length_symbol",
                    "main_purpose": "根据输入的长度值 l 返回对应的符号值，用于压缩算法中的长度符号映射。",
                    "detailed_logic": "函数通过一个静态的查找表（table）将输入的长度值 l 映射到一个符号值。输入 l 的范围是 0 到 258（包括 258），超出此范围的值未处理。查找表是一个长度为 259 的数组，其中每个索引位置存储了对应的符号值。函数直接返回 table[l] 的值。",
                    "error_handling": "函数没有显式的错误处理机制。如果输入 l 超出范围（例如大于 258），可能会导致未定义行为（数组越界访问）。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliGetDistSymbol(int)": {
                "signature": "int ZopfliGetDistSymbol(int)",
                "description": "/* Gets the symbol for the given dist, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistSymbol (int dist ){if (dist <5 ){return dist -1 ;}else {int l =(31 ^__builtin_clz (dist -1 ));/* log2(dist - 1) */ int r =((dist -1 )>>(l -1 ))&1 ;return l *2 +r ;}}",
                "rust_signature": "pub fn zopfli_get_dist_symbol(dist: i32) -> i32 {\n    // Placeholder implementation\n    todo!(\"Implement the function logic\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliGetDistSymbol",
                    "main_purpose": "根据输入的距离值计算并返回对应的距离符号，用于数据压缩算法中的距离编码。",
                    "detailed_logic": "函数首先检查输入距离值是否小于5。如果是，则直接返回距离值减1作为结果。否则，函数通过以下步骤计算距离符号：1. 使用内置函数__builtin_clz计算距离值减1的前导零位数，并通过位运算得到其二进制对数值l。2. 通过右移和按位与操作提取距离值减1的特定位r。3. 最终返回l乘以2加上r作为距离符号。",
                    "error_handling": "函数没有显式的错误检查或处理机制，假设输入参数dist始终为有效的正整数。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "AbsDiff(size_t, size_t)": {
                "signature": "size_t AbsDiff(size_t, size_t)",
                "description": "",
                "dependencies": {},
                "full_text": "static size_t AbsDiff (size_t x ,size_t y ){if (x >y )return x -y ;else return y -x ;}",
                "rust_signature": "fn abs_diff(x: usize, y: usize) -> usize {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "AbsDiff",
                    "main_purpose": "计算两个无符号整数之间的绝对差值。",
                    "detailed_logic": "函数接收两个无符号整数x和y作为输入参数。首先比较x和y的大小，如果x大于y，则返回x减去y的结果；否则返回y减去x的结果。这种逻辑确保返回值始终为非负数，即绝对差值。",
                    "error_handling": "函数不包含任何错误检查或处理机制，因为输入参数是无符号整数，且减法操作不会导致溢出或其他异常情况。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "OptimizeHuffmanForRle(int, size_t *)": {
                "signature": "void OptimizeHuffmanForRle(int, size_t *)",
                "description": "/*\nChanges the population counts in a way that the consequent Huffman tree\ncompression, especially its rle-part, will be more likely to compress this data\nmore efficiently. length contains the size of the histogram.\n*/",
                "dependencies": {
                    "zopfli::AbsDiff(size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::AbsDiff(size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "void OptimizeHuffmanForRle (int length ,size_t *counts ){int i ,k ,stride ;size_t symbol ,sum ,limit ;int *good_for_rle ;/* 1) We don't want to touch the trailing zeros. We may break the\n    rules of the format by adding more data in the distance codes. */ for (;length >=0 ;--length ){if (length ==0 ){return ;}if (counts [length -1 ]!=0 ){/* Now counts[0..length - 1] does not have trailing zeros. */ break ;}}/* 2) Let's mark all population counts that already can be encoded\n    with an rle code.*/ good_for_rle =(int *)malloc ((unsigned )length *sizeof (int ));for (i =0 ;i <length ;++i )good_for_rle [i ]=0 ;/* Let's not spoil any of the existing good rle codes.\n    Mark any seq of 0's that is longer than 5 as a good_for_rle.\n    Mark any seq of non-0's that is longer than 7 as a good_for_rle.*/ symbol =counts [0 ];stride =0 ;for (i =0 ;i <length +1 ;++i ){if (i ==length ||counts [i ]!=symbol ){if ((symbol ==0 &&stride >=5 )||(symbol !=0 &&stride >=7 )){for (k =0 ;k <stride ;++k ){good_for_rle [i -k -1 ]=1 ;}}stride =1 ;if (i !=length ){symbol =counts [i ];}}else {++stride ;}}/* 3) Let's replace those population counts that lead to more rle codes. */ stride =0 ;limit =counts [0 ];sum =0 ;for (i =0 ;i <length +1 ;++i ){if (i ==length ||good_for_rle [i ]/* Heuristic for selecting the stride ranges to collapse. */ ||AbsDiff (counts [i ],limit )>=4 ){if (stride >=4 ||(stride >=3 &&sum ==0 )){/* The stride must end, collapse what we have, if we have enough (4). */ int count =(sum +stride /2 )/stride ;if (count <1 )count =1 ;if (sum ==0 ){/* Don't make an all zeros stride to be upgraded to ones. */ count =0 ;}for (k =0 ;k <stride ;++k ){/* We don't want to change value at counts[i],\n                    that is already belonging to the next stride. Thus - 1. */ counts [i -k -1 ]=count ;}}stride =0 ;sum =0 ;if (i <length -3 ){/* All interesting strides have a count of at least 4,\n                at least when non-zeros. */ limit =(counts [i ]+counts [i +1 ]+counts [i +2 ]+counts [i +3 ]+2 )/4 ;}else if (i <length ){limit =counts [i ];}else {limit =0 ;}}++stride ;if (i !=length ){sum +=counts [i ];}}free (good_for_rle );}",
                "rust_signature": "fn optimize_huffman_for_rle(length: i32, counts: &mut Vec<usize>) {\n    // Placeholder for the function body\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "OptimizeHuffmanForRle",
                    "main_purpose": "优化霍夫曼编码的计数数组，通过检测重复模式并调整计数值以提高运行长度编码（RLE）的效率。",
                    "detailed_logic": "函数分为三个主要步骤：\n1. 去除计数数组末尾的零值：通过从数组末尾向前遍历，找到最后一个非零值的位置，确保后续处理不影响尾部的零值。\n2. 标记适合RLE的计数值：分配一个辅助数组`good_for_rle`，标记数组中连续的零值（长度>=5）或连续的非零值（长度>=7）为适合RLE的区域。\n3. 调整计数值以优化RLE：根据标记的区域，计算适合RLE的计数值，并替换原数组中的值。使用启发式方法检测连续区域，并根据区域的总和和长度计算新的计数值。",
                    "error_handling": "函数通过检查`length`是否为零来避免无效输入。分配内存时使用`malloc`，但未检查分配是否成功，可能导致潜在的内存分配失败问题。最后通过`free`释放分配的内存，避免内存泄漏。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliGetDistSymbolExtraBits(int)": {
                "signature": "int ZopfliGetDistSymbolExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given distance symbol. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistSymbolExtraBits (int s ){static const int table [30 ]={0 ,0 ,0 ,0 ,1 ,1 ,2 ,2 ,3 ,3 ,4 ,4 ,5 ,5 ,6 ,6 ,7 ,7 ,8 ,8 ,9 ,9 ,10 ,10 ,11 ,11 ,12 ,12 ,13 ,13 };return table [s ];}",
                "rust_signature": "fn zopfli_get_dist_symbol_extra_bits(s: usize) -> i32 {\n    todo!(\"Implement logic\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliGetDistSymbolExtraBits",
                    "main_purpose": "根据输入的索引值s，返回对应的额外位数（extra bits），用于Zopfli压缩算法中的距离符号编码。",
                    "detailed_logic": "函数定义了一个静态的常量数组table，其中包含30个整数值，表示不同索引对应的额外位数。函数通过直接使用输入参数s作为索引，从table数组中查找并返回对应的值。由于table是静态的，查找操作的时间复杂度为O(1)。",
                    "error_handling": "函数未包含任何错误检查机制。假定输入参数s始终在有效范围（0到29）内。如果输入超出范围，可能会导致未定义行为（如数组越界访问）。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliGetLengthSymbolExtraBits(int)": {
                "signature": "int ZopfliGetLengthSymbolExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given length symbol. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthSymbolExtraBits (int s ){static const int table [29 ]={0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,1 ,1 ,1 ,2 ,2 ,2 ,2 ,3 ,3 ,3 ,3 ,4 ,4 ,4 ,4 ,5 ,5 ,5 ,5 ,0 };return table [s -257 ];}",
                "rust_signature": "fn zopfli_get_length_symbol_extra_bits(s: i32) -> i32 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 4,
                "function_summary": {
                    "function_name": "ZopfliGetLengthSymbolExtraBits",
                    "main_purpose": "根据输入的符号值计算与长度符号相关的额外位数，用于压缩算法中的符号处理。",
                    "detailed_logic": "函数定义了一个静态常量表，其中包含长度符号对应的额外位数。输入参数's'表示符号值，函数通过从表中查找对应的值来返回额外位数。具体地，符号值减去257后作为索引访问表中的值，并返回该值。",
                    "error_handling": "函数没有显式的错误检查机制，假设输入参数's'始终在有效范围内（257到285）。如果输入超出范围，可能导致未定义行为或访问越界。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nSame as CalculateBlockSymbolSize, but for block size smaller than histogram\nsize.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbolExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbolExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateBlockSymbolSizeSmall (const unsigned *ll_lengths ,const unsigned *d_lengths ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){size_t result =0 ;size_t i ;for (i =lstart ;i <lend ;i ++){assert (i <lz77 ->size );assert (lz77 ->litlens [i ]<259 );if (lz77 ->dists [i ]==0 ){result +=ll_lengths [lz77 ->litlens [i ]];}else {int ll_symbol =ZopfliGetLengthSymbol (lz77 ->litlens [i ]);int d_symbol =ZopfliGetDistSymbol (lz77 ->dists [i ]);result +=ll_lengths [ll_symbol ];result +=d_lengths [d_symbol ];result +=ZopfliGetLengthSymbolExtraBits (ll_symbol );result +=ZopfliGetDistSymbolExtraBits (d_symbol );}}result +=ll_lengths [256 ];/*end symbol*/ return result ;}",
                "rust_signature": "pub fn calculate_block_symbol_size_small(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize\n) -> usize {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "CalculateBlockSymbolSizeSmall",
                    "main_purpose": "计算给定范围内的LZ77块的符号大小，用于压缩算法中的熵编码。",
                    "detailed_logic": "函数遍历指定范围 [lstart, lend) 内的 LZ77 数据块。对于每个块，如果是字面值（dists[i] == 0），则直接从 ll_lengths 中获取对应的符号长度并累加到结果中。如果是长度/距离对，则通过调用 ZopfliGetLengthSymbol 和 ZopfliGetDistSymbol 获取长度和距离的符号值，分别从 ll_lengths 和 d_lengths 中获取符号长度并累加。同时，调用 ZopfliGetLengthSymbolExtraBits 和 ZopfliGetDistSymbolExtraBits 获取额外的位数并累加到结果中。最后，函数还将结束符号（值为 256）的长度累加到结果中。",
                    "error_handling": "函数通过 assert 检查输入范围的有效性（i < lz77->size）以及 litlens 的值是否小于 259。如果断言失败，程序会终止运行。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nSame as CalculateBlockSymbolSize, but with the histogram provided by the caller.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbolExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbolExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbolExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateBlockSymbolSizeGivenCounts (const size_t *ll_counts ,const size_t *d_counts ,const unsigned *ll_lengths ,const unsigned *d_lengths ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){size_t result =0 ;size_t i ;if (lstart +ZOPFLI_NUM_LL *3 >lend ){return CalculateBlockSymbolSizeSmall (ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}else {for (i =0 ;i <256 ;i ++){result +=ll_lengths [i ]*ll_counts [i ];}for (i =257 ;i <286 ;i ++){result +=ll_lengths [i ]*ll_counts [i ];result +=ZopfliGetLengthSymbolExtraBits (i )*ll_counts [i ];}for (i =0 ;i <30 ;i ++){result +=d_lengths [i ]*d_counts [i ];result +=ZopfliGetDistSymbolExtraBits (i )*d_counts [i ];}result +=ll_lengths [256 ];/*end symbol*/ return result ;}}",
                "rust_signature": "pub fn calculate_block_symbol_size_given_counts(\n    ll_counts: &[usize],\n    d_counts: &[usize],\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize\n) -> usize {\n    // Placeholder implementation\n    0usize\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "CalculateBlockSymbolSizeGivenCounts",
                    "main_purpose": "计算给定LZ77块范围内的符号大小，用于压缩算法中的熵编码。",
                    "detailed_logic": "函数根据提供的符号计数和符号长度，计算LZ77块的符号大小。首先检查块范围是否较小（通过lstart + ZOPFLI_NUM_LL * 3 > lend判断），如果是，则调用CalculateBlockSymbolSizeSmall处理小范围块。否则，函数逐步累加符号的大小：1) 遍历前256个符号（字节值），将其计数与长度相乘并累加到结果中；2) 对于257到285的符号（长度符号），累加符号长度与计数的乘积，同时加上符号的额外位数与计数的乘积；3) 对于0到29的符号（距离符号），累加符号长度与计数的乘积，同时加上符号的额外位数与计数的乘积；4) 最后，累加结束符号（256）的长度到结果中。最终返回计算的总符号大小。",
                    "error_handling": "函数未显式处理错误，但通过检查lstart + ZOPFLI_NUM_LL * 3 > lend条件，确保小范围块调用专用函数处理。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "作为输入参数传递给函数，但在此函数中未直接使用其字段。主要用于提供上下文信息和符号计数。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "LeafComparator(const void *, const void *)": {
                "signature": "int LeafComparator(const void *, const void *)",
                "description": "/*\nComparator for sorting the leaves. Has the function signature for qsort.\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    }
                },
                "full_text": "static int LeafComparator (const void *a ,const void *b ){return ((const Node *)a )->weight -((const Node *)b )->weight ;}",
                "rust_signature": "fn leaf_comparator(a: *const core::ffi::c_void, b: *const core::ffi::c_void) -> i32 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "LeafComparator",
                    "main_purpose": "比较两个Node结构体的weight字段，用于排序操作。",
                    "detailed_logic": "函数接收两个指向void类型的指针a和b，分别将它们强制转换为指向Node结构体的指针。然后，访问这两个Node结构体的weight字段，计算它们的差值并返回结果。返回值为正、负或零，分别表示a的weight大于、少于或等于b的weight。",
                    "error_handling": "函数假定输入指针a和b均为有效的Node结构体指针，没有进行空指针检查或类型验证，因此调用者需确保输入的正确性。",
                    "dependencies": {
                        "zopfli::Node": {
                            "signature": "struct Node { weight: usize, tail: Option<Box<Node>>, count: i32 }",
                            "usage": "函数通过解引用输入指针，将其转换为Node结构体指针，并访问其weight字段以进行比较。tail和count字段未被使用。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ExtractBitLengths(Node *, Node *, unsigned int *)": {
                "signature": "void ExtractBitLengths(Node *, Node *, unsigned int *)",
                "description": "/*\nConverts result of boundary package-merge to the bitlengths. The result in the\nlast chain of the last list contains the amount of active leaves in each list.\nchain: Chain to extract the bit length from (last chain from last list).\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    }
                },
                "full_text": "static void ExtractBitLengths (Node *chain ,Node *leaves ,unsigned *bitlengths ){int counts [16 ]={0 };unsigned end =16 ;unsigned ptr =15 ;unsigned value =1 ;Node *node ;int val ;for (node =chain ;node ;node =node ->tail ){counts [--end ]=node ->count ;}val =counts [15 ];while (ptr >=end ){for (;val >counts [ptr -1 ];val --){bitlengths [leaves [val -1 ].count ]=value ;}ptr --;value ++;}}",
                "rust_signature": "unsafe fn extract_bit_lengths(chain: *mut Node, leaves: *mut Node, bitlengths: *mut u32) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ExtractBitLengths",
                    "main_purpose": "计算哈夫曼编码的位长度分布，并将结果存储在bitlengths数组中。该函数通过遍历链表结构（chain）和叶子节点（leaves），根据权重分布生成位长度。",
                    "detailed_logic": "1. 初始化一个长度为16的counts数组，用于存储权重分布。2. 遍历链表chain，将每个节点的权重（count）从尾部开始填充到counts数组中。3. 使用val变量记录counts数组的最后一个值（权重）。4. 通过while循环和嵌套的for循环，逐步计算每个权重对应的位长度：   - 如果当前权重val大于counts数组中的前一个权重值，则将对应的位长度存储到bitlengths数组中。   - 每次处理完一个权重后，递减val，并更新ptr指针以继续处理下一个权重。   - 每次完成一个权重的处理后，位长度值（value）递增。",
                    "error_handling": "该函数没有显式的错误检查机制。假设输入的链表chain和数组leaves、bitlengths均有效，并且counts数组的大小足够容纳所有权重。",
                    "dependencies": {
                        "zopfli::Node": {
                            "signature": "struct Node { weight: usize, tail: Option<Box<Node>>, count: i32 }",
                            "usage": "通过链表结构（Node）遍历权重分布。使用Node的count字段获取权重值，并通过tail字段访问链表的下一个节点。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "InitNode(size_t, int, Node *, Node *)": {
                "signature": "void InitNode(size_t, int, Node *, Node *)",
                "description": "/*\nInitializes a chain node with the given values and marks it as in use.\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    }
                },
                "full_text": "static void InitNode (size_t weight ,int count ,Node *tail ,Node *node ){node ->weight =weight ;node ->count =count ;node ->tail =tail ;}",
                "rust_signature": "fn init_node(weight: usize, count: i32, tail: Option<Box<Node>>, node: &mut Node) { unimplemented!() }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "InitNode",
                    "main_purpose": "初始化一个Node结构体实例，将其成员变量设置为指定的值。",
                    "detailed_logic": "函数接收四个参数：weight、count、tail和node。它将weight赋值给node的weight成员，将count赋值给node的count成员，将tail赋值给node的tail成员。整个过程是直接的赋值操作，没有复杂的逻辑或条件判断。",
                    "error_handling": "该函数没有任何错误检查或处理机制，假定所有输入参数都是有效的。",
                    "dependencies": {
                        "zopfli::Node": {
                            "signature": "struct Node { weight: usize, tail: Option<Box<Node>>, count: i32 }",
                            "usage": "函数通过引用修改Node实例的成员变量，包括weight、count和tail。tail是一个Option<Box<Node>>类型，用于表示链表的前一个节点或无节点的情况。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "InitLists(NodePool *, const Node *, int, Node *(*)[2])": {
                "signature": "void InitLists(NodePool *, const Node *, int, Node *(*)[2])",
                "description": "/*\nInitializes each list with as lookahead chains the two leaves with lowest\nweights.\n*/",
                "dependencies": {
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    },
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::InitNode(size_t, int, Node *, Node *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitNode(size_t, int, Node *, Node *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void InitLists (NodePool *pool ,const Node *leaves ,int maxbits ,Node *(*lists )[2 ]){int i ;Node *node0 =pool ->next ++;Node *node1 =pool ->next ++;InitNode (leaves [0 ].weight ,1 ,0 ,node0 );InitNode (leaves [1 ].weight ,2 ,0 ,node1 );for (i =0 ;i <maxbits ;i ++){lists [i ][0 ]=node0 ;lists [i ][1 ]=node1 ;}}",
                "rust_signature": "fn init_lists(pool: *mut NodePool, leaves: *const Node, maxbits: i32, lists: *mut [*mut Node; 2]) { unsafe { todo!() } }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "InitLists",
                    "main_purpose": "初始化一个二维数组，其中每个元素指向两个新创建的Node实例，并将这些实例的属性设置为指定的值。",
                    "detailed_logic": "函数首先从NodePool中分配两个新的Node实例（node0和node1）。接着调用InitNode函数初始化这两个Node实例的属性，分别使用leaves数组中的第一个和第二个元素的weight值以及固定的count和tail值。然后，函数通过循环将二维数组lists的每一行的两个元素分别设置为node0和node1的指针，循环次数由maxbits决定。",
                    "error_handling": "函数没有显式的错误检查或处理机制，假设所有输入参数均有效且NodePool中有足够的空间分配两个新的Node实例。",
                    "dependencies": {
                        "zopfli::NodePool": {
                            "signature": "struct NodePool { next: *mut Node }",
                            "usage": "用于分配两个新的Node实例。通过pool->next指针获取当前可用的Node，并将其指针递增以指向下一个可用Node。"
                        },
                        "zopfli::Node": {
                            "signature": "struct Node { weight: usize, tail: Option<Box<Node>>, count: i32 }",
                            "usage": "表示节点数据结构。函数通过InitNode设置其属性，并将其指针存储到二维数组lists中。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)": {
                "signature": "void BoundaryPMFinal(Node *(*)[2], Node *, int, NodePool *, int)",
                "description": "",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    }
                },
                "full_text": "static void BoundaryPMFinal (Node *(*lists )[2 ],Node *leaves ,int numsymbols ,NodePool *pool ,int index ){int lastcount =lists [index ][1 ]->count ;/* Count of last chain of list. */ size_t sum =lists [index -1 ][0 ]->weight +lists [index -1 ][1 ]->weight ;if (lastcount <numsymbols &&sum >leaves [lastcount ].weight ){Node *newchain =pool ->next ;Node *oldchain =lists [index ][1 ]->tail ;lists [index ][1 ]=newchain ;newchain ->count =lastcount +1 ;newchain ->tail =oldchain ;}else {lists [index ][1 ]->tail =lists [index -1 ][1 ];}}",
                "rust_signature": "fn boundary_pm_final(lists: *mut [[*mut Node; 2]], leaves: *const Node, numsymbols: i32, pool: *mut NodePool, index: usize) { unsafe { todo!() } }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "BoundaryPMFinal",
                    "main_purpose": "更新链表节点以构建哈夫曼树的边界路径，确保权重和计数满足特定条件。",
                    "detailed_logic": "函数首先获取当前链表的最后一个节点的计数值（lastcount）和前一个链表的两个节点的权重总和（sum）。然后比较lastcount是否小于numsymbols，以及sum是否大于leaves数组中索引为lastcount的节点的权重。如果满足条件，则从NodePool中获取一个新的节点（newchain），更新当前链表的最后一个节点为newchain，并设置其计数值为lastcount + 1，同时将其尾部指向原来的链表尾部（oldchain）。否则，将当前链表的尾部指向前一个链表的尾部。",
                    "error_handling": "函数未显式处理错误情况，但依赖项（NodePool和Node）可能会导致潜在问题，例如NodePool的next指针为空或访问越界的leaves数组。",
                    "dependencies": {
                        "zopfli::Node": {
                            "signature": "struct Node { weight: usize, tail: Option<Box<Node>>, count: i32 }",
                            "usage": "用于表示链表节点，函数通过访问Node的weight、count和tail字段来进行权重和计数的比较以及链表的更新操作。"
                        },
                        "zopfli::NodePool": {
                            "signature": "struct NodePool { next: *mut Node }",
                            "usage": "用于提供新的链表节点，函数通过访问NodePool的next字段获取一个新的Node实例以更新链表结构。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)": {
                "signature": "void BoundaryPM(Node *(*)[2], Node *, int, NodePool *, int)",
                "description": "/*\nPerforms a Boundary Package-Merge step. Puts a new chain in the given list. The\nnew chain is, depending on the weights, a leaf or a combination of two chains\nfrom the previous list.\nlists: The lists of chains.\nmaxbits: Number of lists.\nleaves: The leaves, one per symbol.\nnumsymbols: Number of leaves.\npool: the node memory pool.\nindex: The index of the list in which a new chain or leaf is required.\n*/",
                "dependencies": {
                    "zopfli::Node": {
                        "return_type": "Node",
                        "qualified_name": "zopfli::Node",
                        "type": "structs"
                    },
                    "zopfli::NodePool": {
                        "return_type": "NodePool",
                        "qualified_name": "zopfli::NodePool",
                        "type": "structs"
                    },
                    "zopfli::InitNode(size_t, int, Node *, Node *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::InitNode(size_t, int, Node *, Node *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void BoundaryPM (Node *(*lists )[2 ],Node *leaves ,int numsymbols ,NodePool *pool ,int index ){Node *newchain ;Node *oldchain ;int lastcount =lists [index ][1 ]->count ;/* Count of last chain of list. */ if (index ==0 &&lastcount >=numsymbols )return ;newchain =pool ->next ++;oldchain =lists [index ][1 ];/* These are set up before the recursive calls below, so that there is a list\n    pointing to the new node, to let the garbage collection know it's in use. */ lists [index ][0 ]=oldchain ;lists [index ][1 ]=newchain ;if (index ==0 ){/* New leaf node in list 0. */ InitNode (leaves [lastcount ].weight ,lastcount +1 ,0 ,newchain );}else {size_t sum =lists [index -1 ][0 ]->weight +lists [index -1 ][1 ]->weight ;if (lastcount <numsymbols &&sum >leaves [lastcount ].weight ){/* New leaf inserted in list, so count is incremented. */ InitNode (leaves [lastcount ].weight ,lastcount +1 ,oldchain ->tail ,newchain );}else {InitNode (sum ,lastcount ,lists [index -1 ][1 ],newchain );/* Two lookahead chains of previous list used up, create new ones. */ BoundaryPM (lists ,leaves ,numsymbols ,pool ,index -1 );BoundaryPM (lists ,leaves ,numsymbols ,pool ,index -1 );}}}",
                "rust_signature": "fn boundary_pm(lists: *mut [*mut Node; 2], leaves: *const Node, numsymbols: i32, pool: &mut NodePool, index: usize) {\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "BoundaryPM",
                    "main_purpose": "构建节点链表并递归处理节点权重和计数，以支持符号编码的边界处理。",
                    "detailed_logic": "函数通过递归方式构建节点链表并更新权重和计数。首先检查是否满足终止条件（index为0且最后一个链表节点的计数大于或等于numsymbols），如果满足则直接返回。否则，创建一个新的节点并更新当前链表的指针。根据index的值执行不同的逻辑：\n1. 如果index为0，创建一个新的叶节点并初始化其权重和计数。\n2. 如果index大于0，计算前一个链表的两个节点权重之和，并与当前叶节点的权重进行比较。如果满足条件（最后计数小于numsymbols且权重和大于当前叶节点权重），则插入新的叶节点并递归处理；否则，使用前一个链表的两个节点创建新的节点，并递归调用BoundaryPM两次以处理前一个链表的节点。",
                    "error_handling": "函数通过检查index是否为0以及最后一个链表节点的计数是否大于或等于numsymbols来决定是否提前返回，避免不必要的递归操作。除此之外，没有显式的错误处理逻辑。",
                    "dependencies": {
                        "zopfli::Node": {
                            "signature": "struct Node { weight: usize, tail: Option<Box<Node>>, count: i32 }",
                            "usage": "表示链表中的节点结构体。函数通过访问Node的成员变量（如weight和count）来计算权重和更新计数，并通过tail指针链接节点形成链表。"
                        },
                        "zopfli::NodePool": {
                            "signature": "struct NodePool { next: *mut Node }",
                            "usage": "用于分配新的节点。函数通过访问NodePool的next指针获取下一个可用节点，并更新next指针以指向下一个空闲节点。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nAdds bits, like AddBits, but the order is inverted. The deflate specification\nuses both orders in one standard.\n*/",
                "dependencies": {},
                "full_text": "static void AddHuffmanBits (unsigned symbol ,unsigned length ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){/* TODO(lode): make more efficient (add more bits at once). */ unsigned i ;for (i =0 ;i <length ;i ++){unsigned bit =(symbol >>(length -i -1 ))&1 ;if (*bp ==0 )ZOPFLI_APPEND_DATA (0 ,out ,outsize );(*out )[*outsize -1 ]|=bit <<*bp ;*bp =(*bp +1 )&7 ;}}",
                "rust_signature": "fn add_huffman_bits(symbol: u32, length: u32, bp: &mut u8, out: &mut Vec<u8>, outsize: &mut usize) { todo!(\"Original C function logic not implemented\"); }",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "AddHuffmanBits",
                    "main_purpose": "将指定的符号和长度编码为霍夫曼位，并将其逐位追加到输出缓冲区中。",
                    "detailed_logic": "函数接收一个符号（symbol）和其对应的位长度（length），将符号逐位提取并写入到输出缓冲区（out）。具体步骤如下：\n1. 遍历符号的每一位，从最高有效位到最低有效位（通过循环从0到length-1）。\n2. 提取当前位（bit），通过右移操作和按位与操作获取符号的第i位。\n3. 如果当前字节指针（bp）为0，则调用ZOPFLI_APPEND_DATA向输出缓冲区添加一个新字节（初始化为0）。\n4. 将提取的位（bit）写入到当前字节的指定位置（通过位移和按位或操作）。\n5. 更新字节指针（bp），使其指向下一个位位置。如果bp达到8（一个字节的位数），则重置为0。",
                    "error_handling": "函数未显式处理错误情况，例如输入参数的有效性或内存分配失败等。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                "description": "",
                "dependencies": {},
                "full_text": "static void AddBits (unsigned symbol ,unsigned length ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){/* TODO(lode): make more efficient (add more bits at once). */ unsigned i ;for (i =0 ;i <length ;i ++){unsigned bit =(symbol >>i )&1 ;if (*bp ==0 )ZOPFLI_APPEND_DATA (0 ,out ,outsize );(*out )[*outsize -1 ]|=bit <<*bp ;*bp =(*bp +1 )&7 ;}}",
                "rust_signature": "pub fn add_bits(symbol: u32, length: u32, bp: &mut u8, out: &mut Vec<u8>, outsize: &mut usize) {\n    // TODO: make more efficient (add more bits at once).\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "AddBits",
                    "main_purpose": "将指定数量的位从符号中提取并追加到输出缓冲区中，同时更新位指针。",
                    "detailed_logic": "函数接收一个符号（symbol）和其位长度（length），逐位提取符号中的位并将其写入输出缓冲区（out）。具体步骤如下：1. 遍历符号的每一位（从低位到高位），通过右移和按位与操作提取当前位的值（bit）。2. 如果当前位指针（bp）为0，表示需要在输出缓冲区中追加一个新字节，调用ZOPFLI_APPEND_DATA函数完成此操作。3. 将提取的位写入输出缓冲区的当前字节中，使用按位或操作将位值写入到由位指针（bp）指定的位置。4. 更新位指针（bp），使其指向下一个可用位位置。如果位指针超过7（即一个字节的范围），则循环回到0。",
                    "error_handling": "函数本身没有显式的错误检查机制，假设输入参数始终有效。依赖于调用者确保输入参数的正确性。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "size_t EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nEncodes the Huffman tree and returns how many bits its encoding takes. If out\nis a null pointer, only returns the size and runs faster.\n*/",
                "dependencies": {
                    "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t EncodeTree (const unsigned *ll_lengths ,const unsigned *d_lengths ,int use_16 ,int use_17 ,int use_18 ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){unsigned lld_total ;/* Total amount of literal, length, distance codes. */ /* Runlength encoded version of lengths of litlen and dist trees. */ unsigned *rle =0 ;unsigned *rle_bits =0 ;/* Extra bits for rle values 16, 17 and 18. */ size_t rle_size =0 ;/* Size of rle array. */ size_t rle_bits_size =0 ;/* Should have same value as rle_size. */ unsigned hlit =29 ;/* 286 - 257 */ unsigned hdist =29 ;/* 32 - 1, but gzip does not like hdist > 29.*/ unsigned hclen ;unsigned hlit2 ;size_t i ,j ;size_t clcounts [19 ];unsigned clcl [19 ];/* Code length code lengths. */ unsigned clsymbols [19 ];/* The order in which code length code lengths are encoded as per deflate. */ static const unsigned order [19 ]={16 ,17 ,18 ,0 ,8 ,7 ,9 ,6 ,10 ,5 ,11 ,4 ,12 ,3 ,13 ,2 ,14 ,1 ,15 };int size_only =!out ;size_t result_size =0 ;for (i =0 ;i <19 ;i ++)clcounts [i ]=0 ;/* Trim zeros. */ while (hlit >0 &&ll_lengths [257 +hlit -1 ]==0 )hlit --;while (hdist >0 &&d_lengths [1 +hdist -1 ]==0 )hdist --;hlit2 =hlit +257 ;lld_total =hlit2 +hdist +1 ;for (i =0 ;i <lld_total ;i ++){/* This is an encoding of a huffman tree, so now the length is a symbol */ unsigned char symbol =i <hlit2 ?ll_lengths [i ]:d_lengths [i -hlit2 ];unsigned count =1 ;if (use_16 ||(symbol ==0 &&(use_17 ||use_18 ))){for (j =i +1 ;j <lld_total &&symbol ==(j <hlit2 ?ll_lengths [j ]:d_lengths [j -hlit2 ]);j ++){count ++;}}i +=count -1 ;/* Repetitions of zeroes */ if (symbol ==0 &&count >=3 ){if (use_18 ){while (count >=11 ){unsigned count2 =count >138 ?138 :count ;if (!size_only ){ZOPFLI_APPEND_DATA (18 ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (count2 -11 ,&rle_bits ,&rle_bits_size );}clcounts [18 ]++;count -=count2 ;}}if (use_17 ){while (count >=3 ){unsigned count2 =count >10 ?10 :count ;if (!size_only ){ZOPFLI_APPEND_DATA (17 ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (count2 -3 ,&rle_bits ,&rle_bits_size );}clcounts [17 ]++;count -=count2 ;}}}/* Repetitions of any symbol */ if (use_16 &&count >=4 ){count --;/* Since the first one is hardcoded. */ clcounts [symbol ]++;if (!size_only ){ZOPFLI_APPEND_DATA (symbol ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (0 ,&rle_bits ,&rle_bits_size );}while (count >=3 ){unsigned count2 =count >6 ?6 :count ;if (!size_only ){ZOPFLI_APPEND_DATA (16 ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (count2 -3 ,&rle_bits ,&rle_bits_size );}clcounts [16 ]++;count -=count2 ;}}/* No or insufficient repetition */ clcounts [symbol ]+=count ;while (count >0 ){if (!size_only ){ZOPFLI_APPEND_DATA (symbol ,&rle ,&rle_size );ZOPFLI_APPEND_DATA (0 ,&rle_bits ,&rle_bits_size );}count --;}}ZopfliCalculateBitLengths (clcounts ,19 ,7 ,clcl );if (!size_only )ZopfliLengthsToSymbols (clcl ,19 ,7 ,clsymbols );hclen =15 ;/* Trim zeros. */ while (hclen >0 &&clcounts [order [hclen +4 -1 ]]==0 )hclen --;if (!size_only ){AddBits (hlit ,5 ,bp ,out ,outsize );AddBits (hdist ,5 ,bp ,out ,outsize );AddBits (hclen ,4 ,bp ,out ,outsize );for (i =0 ;i <hclen +4 ;i ++){AddBits (clcl [order [i ]],3 ,bp ,out ,outsize );}for (i =0 ;i <rle_size ;i ++){unsigned symbol =clsymbols [rle [i ]];AddHuffmanBits (symbol ,clcl [rle [i ]],bp ,out ,outsize );/* Extra bits. */ if (rle [i ]==16 )AddBits (rle_bits [i ],2 ,bp ,out ,outsize );else if (rle [i ]==17 )AddBits (rle_bits [i ],3 ,bp ,out ,outsize );else if (rle [i ]==18 )AddBits (rle_bits [i ],7 ,bp ,out ,outsize );}}result_size +=14 ;/* hlit, hdist, hclen bits */ result_size +=(hclen +4 )*3 ;/* clcl bits */ for (i =0 ;i <19 ;i ++){result_size +=clcl [i ]*clcounts [i ];}/* Extra bits. */ result_size +=clcounts [16 ]*2 ;result_size +=clcounts [17 ]*3 ;result_size +=clcounts [18 ]*7 ;/* Note: in case of \"size_only\" these are null pointers so no effect. */ free (rle );free (rle_bits );return result_size ;}",
                "rust_signature": "pub fn encode_tree(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    use_16: bool,\n    use_17: bool,\n    use_18: bool,\n    bp: &mut u8,\n    out: Option<&mut Vec<u8>>,\n    outsize: &mut usize,\n) -> usize {\n    // Function body placeholder\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "EncodeTree",
                    "main_purpose": "对输入的字面长度和距离长度数组进行霍夫曼树编码，并将结果以压缩格式输出，同时支持运行长度编码优化。",
                    "detailed_logic": "函数首先计算字面长度和距离长度的总数，并对输入数组进行修剪以去除尾部的零值。接着，函数对输入数组进行遍历，根据符号值和重复次数生成运行长度编码（RLE），并根据使用的编码类型（16、17、18）进行优化。随后，函数计算代码长度的霍夫曼编码，并将其转换为符号表。最后，函数将编码结果写入输出缓冲区，并返回编码数据的总大小。",
                    "error_handling": "函数通过检查输入指针是否为空来决定是否仅计算编码大小（size_only模式）。此外，函数在使用动态分配的内存（rle和rle_bits）后确保释放，以避免内存泄漏。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "CalculateTreeSize(const unsigned int *, const unsigned int *)": {
                "signature": "size_t CalculateTreeSize(const unsigned int *, const unsigned int *)",
                "description": "/*\nGives the exact size of the tree, in bits, as it will be encoded in DEFLATE.\n*/",
                "dependencies": {
                    "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateTreeSize (const unsigned *ll_lengths ,const unsigned *d_lengths ){size_t result =0 ;int i ;for (i =0 ;i <8 ;i ++){size_t size =EncodeTree (ll_lengths ,d_lengths ,i &1 ,i &2 ,i &4 ,0 ,0 ,0 );if (result ==0 ||size <result )result =size ;}return result ;}",
                "rust_signature": "pub fn calculate_tree_size(ll_lengths: &[u32], d_lengths: &[u32]) -> usize {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "CalculateTreeSize",
                    "main_purpose": "计算霍夫曼树编码的最小压缩大小，通过尝试不同的运行长度编码优化选项。",
                    "detailed_logic": "函数接收两个数组（字面长度和距离长度），并通过调用EncodeTree函数尝试8种不同的运行长度编码优化组合（由i的三个最低位控制）。对于每种组合，计算压缩后的大小，并记录最小值。最终返回最小压缩大小。",
                    "error_handling": "函数未显式处理错误情况。如果EncodeTree返回无效结果（如0），可能导致逻辑错误，但此处假设EncodeTree总是返回有效的压缩大小。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "PatchDistanceCodesForBuggyDecoders(unsigned int *)": {
                "signature": "void PatchDistanceCodesForBuggyDecoders(unsigned int *)",
                "description": "/*\nEnsures there are at least 2 distance codes to support buggy decoders.\nZlib 1.2.1 and below have a bug where it fails if there isn't at least 1\ndistance code (with length > 0), even though it's valid according to the\ndeflate spec to have 0 distance codes. On top of that, some mobile phones\nrequire at least two distance codes. To support these decoders too (but\npotentially at the cost of a few bytes), add dummy code lengths of 1.\nReferences to this bug can be found in the changelog of\nZlib 1.2.2 and here: http://www.jonof.id.au/forum/index.php?topic=515.0.\n\nd_lengths: the 32 lengths of the distance codes.\n*/",
                "dependencies": {},
                "full_text": "static void PatchDistanceCodesForBuggyDecoders (unsigned *d_lengths ){int num_dist_codes =0 ;/* Amount of non-zero distance codes */ int i ;for (i =0 ;i <30 /* Ignore the two unused codes from the spec */ ;i ++){if (d_lengths [i ])num_dist_codes ++;if (num_dist_codes >=2 )return ;/* Two or more codes is fine. */ }if (num_dist_codes ==0 ){d_lengths [0 ]=d_lengths [1 ]=1 ;}else if (num_dist_codes ==1 ){d_lengths [d_lengths [0 ]?1 :0 ]=1 ;}}",
                "rust_signature": "fn patch_distance_codes_for_buggy_decoders(d_lengths: &mut [u32; 30]) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "PatchDistanceCodesForBuggyDecoders",
                    "main_purpose": "修复可能存在问题的解码器的距离码表，以确保至少有两个有效的距离码。",
                    "detailed_logic": "函数接收一个长度为30的数组，表示距离码的长度表。首先统计数组中非零元素的数量（即有效距离码的数量）。如果有效距离码数量达到2或更多，则函数直接返回，表示无需修复。如果有效距离码数量为0，则将数组的前两个元素设置为1，确保至少有两个有效距离码。如果有效距离码数量为1，则检查数组的第一个元素是否为非零值，并根据结果设置另一个元素为1，以确保有两个有效距离码。",
                    "error_handling": "函数没有显式的错误处理机制，但通过逻辑检查和修复操作确保输入数组满足解码器的要求。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)": {
                "signature": "double TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)",
                "description": "/*\nTries out OptimizeHuffmanForRle for this block, if the result is smaller,\nuses it, otherwise keeps the original. Returns size of encoded tree and data in\nbits, not including the 3-bit block header.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CalculateTreeSize(const unsigned int *, const unsigned int *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateTreeSize(const unsigned int *, const unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::OptimizeHuffmanForRle(int, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::OptimizeHuffmanForRle(int, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "static double TryOptimizeHuffmanForRle (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,const size_t *ll_counts ,const size_t *d_counts ,unsigned *ll_lengths ,unsigned *d_lengths ){size_t ll_counts2 [ZOPFLI_NUM_LL ];size_t d_counts2 [ZOPFLI_NUM_D ];unsigned ll_lengths2 [ZOPFLI_NUM_LL ];unsigned d_lengths2 [ZOPFLI_NUM_D ];double treesize ;double datasize ;double treesize2 ;double datasize2 ;treesize =CalculateTreeSize (ll_lengths ,d_lengths );datasize =CalculateBlockSymbolSizeGivenCounts (ll_counts ,d_counts ,ll_lengths ,d_lengths ,lz77 ,lstart ,lend );memcpy (ll_counts2 ,ll_counts ,sizeof (ll_counts2 ));memcpy (d_counts2 ,d_counts ,sizeof (d_counts2 ));OptimizeHuffmanForRle (ZOPFLI_NUM_LL ,ll_counts2 );OptimizeHuffmanForRle (ZOPFLI_NUM_D ,d_counts2 );ZopfliCalculateBitLengths (ll_counts2 ,ZOPFLI_NUM_LL ,15 ,ll_lengths2 );ZopfliCalculateBitLengths (d_counts2 ,ZOPFLI_NUM_D ,15 ,d_lengths2 );PatchDistanceCodesForBuggyDecoders (d_lengths2 );treesize2 =CalculateTreeSize (ll_lengths2 ,d_lengths2 );datasize2 =CalculateBlockSymbolSizeGivenCounts (ll_counts ,d_counts ,ll_lengths2 ,d_lengths2 ,lz77 ,lstart ,lend );if (treesize2 +datasize2 <treesize +datasize ){memcpy (ll_lengths ,ll_lengths2 ,sizeof (ll_lengths2 ));memcpy (d_lengths ,d_lengths2 ,sizeof (d_lengths2 ));return treesize2 +datasize2 ;}return treesize +datasize ;}",
                "rust_signature": "pub fn try_optimize_huffman_for_rle(\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    ll_counts: &[usize],\n    d_counts: &[usize],\n    ll_lengths: &mut [u32; ZOPFLI_NUM_LL],\n    d_lengths: &mut [u32; ZOPFLI_NUM_D]\n) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "TryOptimizeHuffmanForRle",
                    "main_purpose": "尝试优化霍夫曼编码以提高运行长度编码（RLE）的效率，并返回优化后的压缩大小。",
                    "detailed_logic": "函数首先计算当前霍夫曼树的大小和数据块符号大小。然后复制输入的计数数组，并对其进行RLE优化。接着计算优化后的位长度分布，并修复可能存在问题的距离码表。最后重新计算优化后的霍夫曼树大小和数据块符号大小。如果优化后的总大小小于原始总大小，则更新位长度数组并返回优化后的总大小；否则返回原始总大小。",
                    "error_handling": "函数未显式进行错误检查或处理，假设所有输入参数有效且依赖函数不会失败。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)": {
                "signature": "void ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *, size_t, size_t *, size_t *)",
                "description": "/* Gets the histogram of lit/len and dist symbols in the given range, using the\ncumulative histograms, so faster than adding one by one for large range. Does\nnot add the one end symbol of value 256. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "static void ZopfliLZ77GetHistogramAt (const ZopfliLZ77Store *lz77 ,size_t lpos ,size_t *ll_counts ,size_t *d_counts ){/* The real histogram is created by using the histogram for this chunk, but\n    all superfluous values of this chunk subtracted. */ size_t llpos =ZOPFLI_NUM_LL *(lpos /ZOPFLI_NUM_LL );size_t dpos =ZOPFLI_NUM_D *(lpos /ZOPFLI_NUM_D );size_t i ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){ll_counts [i ]=lz77 ->ll_counts [llpos +i ];}for (i =lpos +1 ;i <llpos +ZOPFLI_NUM_LL &&i <lz77 ->size ;i ++){ll_counts [lz77 ->ll_symbol [i ]]--;}for (i =0 ;i <ZOPFLI_NUM_D ;i ++){d_counts [i ]=lz77 ->d_counts [dpos +i ];}for (i =lpos +1 ;i <dpos +ZOPFLI_NUM_D &&i <lz77 ->size ;i ++){if (lz77 ->dists [i ]!=0 )d_counts [lz77 ->d_symbol [i ]]--;}}",
                "rust_signature": "fn zopfli_lz77_get_histogram_at(\n    lz77: &ZopfliLZ77Store,\n    lpos: usize,\n    ll_counts: &mut [usize],\n    d_counts: &mut [usize],\n) {\n    // The real histogram is created by using the histogram for this chunk, but\n    // all superfluous values of this chunk subtracted.\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "zopfli_lz77_get_histogram_at",
                    "main_purpose": "计算给定位置的LZ77符号和距离的直方图，并从全局直方图中减去不属于当前块的符号和距离。",
                    "detailed_logic": "函数首先根据输入位置lpos计算当前块的起始位置llpos和dpos，分别用于处理符号和距离的直方图。然后，函数执行以下步骤：\n1. 初始化ll_counts数组，将其设置为全局ll_counts中对应块的值。\n2. 遍历从lpos+1到当前块结束位置的范围，减去这些位置上符号的计数，以排除不属于当前块的符号。\n3. 初始化d_counts数组，将其设置为全局d_counts中对应块的值。\n4. 遍历从lpos+1到当前块结束位置的范围，检查每个位置的距离值是否为非零。如果是，则减去这些位置上距离符号的计数，以排除不属于当前块的距离。",
                    "error_handling": "函数未显式处理错误情况，例如输入参数的有效性检查或越界访问保护。假设调用者确保输入参数有效。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)": {
                "signature": "double GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)",
                "description": "/*\nCalculates the bit lengths for the symbols for dynamic blocks. Chooses bit\nlengths that give the smallest size of tree encoding + encoding of all the\nsymbols to have smallest output size. This are not necessarily the ideal Huffman\nbit lengths. Returns size of encoded tree and data in bits, not including the\n3-bit block header.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateBitLengths(const size_t *, size_t, int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::PatchDistanceCodesForBuggyDecoders(unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::TryOptimizeHuffmanForRle(const ZopfliLZ77Store *, size_t, size_t, const size_t *, const size_t *, unsigned int *, unsigned int *)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetDynamicLengths (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,unsigned *ll_lengths ,unsigned *d_lengths ){size_t ll_counts [ZOPFLI_NUM_LL ];size_t d_counts [ZOPFLI_NUM_D ];ZopfliLZ77GetHistogram (lz77 ,lstart ,lend ,ll_counts ,d_counts );ll_counts [256 ]=1 ;/* End symbol. */ ZopfliCalculateBitLengths (ll_counts ,ZOPFLI_NUM_LL ,15 ,ll_lengths );ZopfliCalculateBitLengths (d_counts ,ZOPFLI_NUM_D ,15 ,d_lengths );PatchDistanceCodesForBuggyDecoders (d_lengths );return TryOptimizeHuffmanForRle (lz77 ,lstart ,lend ,ll_counts ,d_counts ,ll_lengths ,d_lengths );}",
                "rust_signature": "pub fn get_dynamic_lengths(\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    ll_lengths: &mut [u32; ZOPFLI_NUM_LL],\n    d_lengths: &mut [u32; ZOPFLI_NUM_D]\n) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "GetDynamicLengths",
                    "main_purpose": "计算动态哈夫曼编码的位长度分布，并优化压缩效率。",
                    "detailed_logic": "函数首先通过调用ZopfliLZ77GetHistogram生成给定范围内的LZ77符号和距离的直方图。然后将结束符号的计数设置为1，以确保其在编码中存在。接着调用ZopfliCalculateBitLengths分别计算符号和距离的哈夫曼编码位长度分布，限制最大位数为15。随后调用PatchDistanceCodesForBuggyDecoders修复可能存在问题的距离码表。最后，调用TryOptimizeHuffmanForRle尝试优化哈夫曼编码以提高运行长度编码（RLE）的效率，并返回优化后的压缩大小。",
                    "error_handling": "函数未显式处理错误，假定所有依赖函数能够正确执行。如果依赖函数内部出现错误，可能会导致未定义行为或错误结果。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "GetFixedTree(unsigned int *, unsigned int *)": {
                "signature": "void GetFixedTree(unsigned int *, unsigned int *)",
                "description": "",
                "dependencies": {},
                "full_text": "static void GetFixedTree (unsigned *ll_lengths ,unsigned *d_lengths ){size_t i ;for (i =0 ;i <144 ;i ++)ll_lengths [i ]=8 ;for (i =144 ;i <256 ;i ++)ll_lengths [i ]=9 ;for (i =256 ;i <280 ;i ++)ll_lengths [i ]=7 ;for (i =280 ;i <288 ;i ++)ll_lengths [i ]=8 ;for (i =0 ;i <32 ;i ++)d_lengths [i ]=5 ;}",
                "rust_signature": "fn get_fixed_tree(ll_lengths: &mut [u32; 288], d_lengths: &mut [u32; 32]) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "GetFixedTree",
                    "main_purpose": "初始化两个数组，分别表示固定的哈夫曼编码树的长度信息，用于数据压缩和解压。",
                    "detailed_logic": "函数通过四个循环分别设置ll_lengths数组的不同区间的值：前144个元素设置为8，接着112个元素设置为9，然后24个元素设置为7，最后8个元素设置为8。随后，通过一个循环将d_lengths数组的所有32个元素设置为5。这些值是固定的，用于构建特定的哈夫曼编码树。",
                    "error_handling": "函数没有任何错误检查或处理机制，假设传入的数组大小符合预期。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "size_t CalculateBlockSymbolSize(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nCalculates size of the part after the header and tree of an LZ77 block, in bits.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeSmall(const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77GetHistogram(const ZopfliLZ77Store *, size_t, size_t, size_t *, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::CalculateBlockSymbolSizeGivenCounts(const size_t *, const size_t *, const unsigned int *, const unsigned int *, const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static size_t CalculateBlockSymbolSize (const unsigned *ll_lengths ,const unsigned *d_lengths ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){if (lstart +ZOPFLI_NUM_LL *3 >lend ){return CalculateBlockSymbolSizeSmall (ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}else {size_t ll_counts [ZOPFLI_NUM_LL ];size_t d_counts [ZOPFLI_NUM_D ];ZopfliLZ77GetHistogram (lz77 ,lstart ,lend ,ll_counts ,d_counts );return CalculateBlockSymbolSizeGivenCounts (ll_counts ,d_counts ,ll_lengths ,d_lengths ,lz77 ,lstart ,lend );}}",
                "rust_signature": "pub fn calculate_block_symbol_size(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize\n) -> usize {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "CalculateBlockSymbolSize",
                    "main_purpose": "计算给定范围内的LZ77块的符号大小，用于压缩算法中的熵编码。",
                    "detailed_logic": "函数首先检查范围是否较小（通过判断 lstart + ZOPFLI_NUM_LL * 3 是否大于 lend）。如果范围较小，则调用 CalculateBlockSymbolSizeSmall 函数直接计算符号大小；否则，函数通过调用 ZopfliLZ77GetHistogram 生成符号和距离的直方图，然后调用 CalculateBlockSymbolSizeGivenCounts 使用生成的直方图和符号长度计算符号大小。",
                    "error_handling": "函数未显式处理错误情况，但依赖函数可能包含错误检查逻辑，例如检查输入参数的有效性。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "EstimateCost(const ZopfliLZ77Store *, size_t, size_t)": {
                "signature": "double EstimateCost(const ZopfliLZ77Store *, size_t, size_t)",
                "description": "/*\nReturns estimated cost of a block in bits.  It includes the size to encode the\ntree and the size to encode all literal, length and distance symbols and their\nextra bits.\n\nlitlens: lz77 lit/lengths\ndists: ll77 distances\nlstart: start of block\nlend: end of block (not inclusive)\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static double EstimateCost (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ){return ZopfliCalculateBlockSizeAutoType (lz77 ,lstart ,lend );}",
                "rust_signature": "fn estimate_cost(lz77: &ZopfliLZ77Store, lstart: usize, lend: usize) -> f64 {\n    // Placeholder implementation. Original C code calls ZopfliCalculateBlockSizeAutoType.\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "estimate_cost",
                    "main_purpose": "计算给定LZ77块范围的压缩成本。",
                    "detailed_logic": "函数直接调用ZopfliCalculateBlockSizeAutoType函数，传递LZ77存储结构和指定的起始与结束索引范围。ZopfliCalculateBlockSizeAutoType函数会根据不同的块类型（未压缩、固定哈夫曼编码、动态哈夫曼编码）计算该范围内的最小压缩大小，并将结果返回给estimate_cost函数。",
                    "error_handling": "该函数本身没有进行任何错误检查或处理，假设调用的依赖函数（ZopfliCalculateBlockSizeAutoType）会处理所有可能的错误情况。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "SplitCost(size_t, void *)": {
                "signature": "double SplitCost(size_t, void *)",
                "description": "/*\nGets the cost which is the sum of the cost of the left and the right section\nof the data.\ntype: FindMinimumFun\n*/",
                "dependencies": {
                    "zopfli::SplitCostContext": {
                        "return_type": "SplitCostContext",
                        "qualified_name": "zopfli::SplitCostContext",
                        "type": "structs"
                    },
                    "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::EstimateCost(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static double SplitCost (size_t i ,void *context ){SplitCostContext *c =(SplitCostContext *)context ;return EstimateCost (c ->lz77 ,c ->start ,i )+EstimateCost (c ->lz77 ,i ,c ->end );}",
                "rust_signature": "fn split_cost(i: usize, context: *mut std::ffi::c_void) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "split_cost",
                    "main_purpose": "计算将LZ77压缩块分割为两个子块后的总压缩成本。",
                    "detailed_logic": "函数接收一个分割点索引 i 和上下文 context。上下文包含 LZ77 数据存储指针以及当前块的起始和结束索引。函数将当前块分为两部分：[start, i) 和 [i, end)，分别调用 estimate_cost 计算这两部分的压缩成本，并返回它们的总和。",
                    "error_handling": "函数未显式处理错误。假设上下文和 LZ77 数据存储指针有效，且 estimate_cost 函数能够正确处理输入范围。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliGetLengthExtraBits(int)": {
                "signature": "int ZopfliGetLengthExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given length, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthExtraBits (int l ){static const int table [259 ]={0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,4 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,5 ,0 };return table [l ];}",
                "rust_signature": "fn zopfli_get_length_extra_bits(l: usize) -> i32 {\n    todo!(\"Function implementation is not provided.\")\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "zopfli_get_length_extra_bits",
                    "main_purpose": "根据输入的长度值返回对应的额外位数，用于Zopfli压缩算法中的长度编码。",
                    "detailed_logic": "函数通过查表的方式，根据输入参数l（长度值）直接返回预定义的额外位数。查找表是一个静态数组，包含从0到258的长度值对应的额外位数。输入值l作为数组的索引，函数返回table[l]的值。",
                    "error_handling": "函数没有显式的错误检查机制。假设输入值l在有效范围（0到258）内。如果输入值超出范围，可能会导致未定义行为（如数组越界访问）。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliGetDistExtraBits(int)": {
                "signature": "int ZopfliGetDistExtraBits(int)",
                "description": "/* Gets the amount of extra bits for the given dist, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistExtraBits (int dist ){if (dist <5 )return 0 ;return (31 ^__builtin_clz (dist -1 ))-1 ;/* log2(dist - 1) - 1 */ }",
                "rust_signature": "pub fn zopfli_get_dist_extra_bits(dist: i32) -> i32 {\n    // 原始C代码逻辑未实现，仅提供函数签名\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ZopfliGetDistExtraBits",
                    "main_purpose": "计算给定距离值的额外位数（extra bits），用于压缩算法中的距离编码。",
                    "detailed_logic": "函数首先检查输入的距离值dist是否小于5。如果是，则直接返回0，表示不需要额外位数。否则，函数通过位操作计算log2(dist - 1) - 1的值。具体实现中，使用了内建函数__builtin_clz来计算dist - 1的前导零位数，并通过31减去前导零的结果得到log2(dist - 1)。最后再减去1以符合算法需求。",
                    "error_handling": "函数未对输入参数dist进行显式的错误检查，例如是否为负数。假设调用者保证输入值为有效的正整数。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "GetCostStat(unsigned int, unsigned int, void *)": {
                "signature": "double GetCostStat(unsigned int, unsigned int, void *)",
                "description": "/*\nCost model based on symbol statistics.\ntype: CostModelFun\n*/",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetCostStat (unsigned litlen ,unsigned dist ,void *context ){SymbolStats *stats =(SymbolStats *)context ;if (dist ==0 ){return stats ->ll_symbols [litlen ];}else {int lsym =ZopfliGetLengthSymbol (litlen );int lbits =ZopfliGetLengthExtraBits (litlen );int dsym =ZopfliGetDistSymbol (dist );int dbits =ZopfliGetDistExtraBits (dist );return lbits +dbits +stats ->ll_symbols [lsym ]+stats ->d_symbols [dsym ];}}",
                "rust_signature": "pub unsafe fn get_cost_stat(litlen: u32, dist: u32, context: *mut std::ffi::c_void) -> f64 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "GetCostStat",
                    "main_purpose": "计算给定的文字/长度符号和距离符号的编码成本（以位为单位），用于数据压缩算法中的符号选择和优化。",
                    "detailed_logic": "函数首先将上下文参数转换为SymbolStats结构体指针。如果距离值为0，则直接返回对应文字/长度符号的编码成本（从SymbolStats的ll_symbols数组中获取）。否则，函数通过调用ZopfliGetLengthSymbol和ZopfliGetDistSymbol计算长度和距离的符号索引，并通过ZopfliGetLengthExtraBits和ZopfliGetDistExtraBits计算长度和距离的额外位数。最终，函数将长度符号的编码成本、距离符号的编码成本以及额外位数相加，返回总的编码成本。",
                    "error_handling": "函数假设输入参数有效，没有显式的错误检查。如果上下文指针无效或依赖函数返回异常值，可能导致未定义行为。",
                    "dependencies": {
                        "zopfli::SymbolStats": {
                            "signature": "pub struct SymbolStats { pub litlens: [usize; ZOPFLI_NUM_LL], pub dists: [usize; ZOPFLI_NUM_D], pub ll_symbols: [f64; ZOPFLI_NUM_LL], pub d_symbols: [f64; ZOPFLI_NUM_D] }",
                            "usage": "提供符号的编码成本数据。ll_symbols数组存储文字/长度符号的编码成本，d_symbols数组存储距离符号的编码成本。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "GetCostFixed(unsigned int, unsigned int, void *)": {
                "signature": "double GetCostFixed(unsigned int, unsigned int, void *)",
                "description": "/*\nCost model which should exactly match fixed tree.\ntype: CostModelFun\n*/",
                "dependencies": {
                    "zopfli::ZopfliGetDistExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetCostFixed (unsigned litlen ,unsigned dist ,void *unused ){(void )unused ;if (dist ==0 ){if (litlen <=143 )return 8 ;else return 9 ;}else {int dbits =ZopfliGetDistExtraBits (dist );int lbits =ZopfliGetLengthExtraBits (litlen );int lsym =ZopfliGetLengthSymbol (litlen );int cost =0 ;if (lsym <=279 )cost +=7 ;else cost +=8 ;cost +=5 ;/* Every dist symbol has length 5. */ return cost +dbits +lbits ;}}",
                "rust_signature": "pub fn get_cost_fixed(litlen: u32, dist: u32, unused: *mut std::ffi::c_void) -> f64 {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "GetCostFixed",
                    "main_purpose": "计算给定字面长度和距离的固定压缩成本，用于Zopfli压缩算法的成本估算。",
                    "detailed_logic": "函数首先检查距离值是否为0。如果距离为0，则根据字面长度值决定返回固定成本（8或9）。如果距离不为0，函数通过调用依赖函数计算距离的额外位数、长度的额外位数以及长度符号。然后根据长度符号的范围决定基础成本（7或8），加上固定的距离符号长度（5），最后将所有成本值相加并返回。",
                    "error_handling": "函数没有显式的错误处理逻辑。它假设输入参数（litlen和dist）总是有效，并且依赖函数总是返回正确的值。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "AddBit(int, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddBit(int, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nbp = bitpointer, always in range [0, 7].\nThe outsize is number of necessary bytes to encode the bits.\nGiven the value of bp and the amount of bytes, the amount of bits represented\nis not simply bytesize * 8 + bp because even representing one bit requires a\nwhole byte. It is: (bp == 0) ? (bytesize * 8) : ((bytesize - 1) * 8 + bp)\n*/",
                "dependencies": {},
                "full_text": "static void AddBit (int bit ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){if (*bp ==0 )ZOPFLI_APPEND_DATA (0 ,out ,outsize );(*out )[*outsize -1 ]|=bit <<*bp ;*bp =(*bp +1 )&7 ;}",
                "rust_signature": "pub fn add_bit(bit: i32, bp: &mut u8, out: &mut Vec<u8>, outsize: &mut usize) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "AddBit",
                    "main_purpose": "将一个位添加到输出缓冲区中，并根据需要更新缓冲区和位指针。",
                    "detailed_logic": "函数首先检查当前位指针（bp）是否为0。如果是0，则调用ZOPFLI_APPEND_DATA函数向输出缓冲区中追加一个字节（初始化为0）。接着，将传入的bit值左移bp指定的位数，并将其与当前输出缓冲区的最后一个字节进行按位或操作，从而将bit值写入正确的位置。最后，更新位指针bp，使其指向下一个位位置（通过加1并对8取模实现）。",
                    "error_handling": "函数本身没有显式的错误检查机制，假定所有输入参数均有效（例如，bp指针和out指针不为NULL，outsize指向的值有效）。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/* Since an uncompressed block can be max 65535 in size, it actually adds\nmultible blocks if needed. */",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddNonCompressedBlock (const ZopfliOptions *options ,int final ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t pos =instart ;(void )options ;for (;;){size_t i ;unsigned short blocksize =65535 ;unsigned short nlen ;int currentfinal ;if (pos +blocksize >inend )blocksize =inend -pos ;currentfinal =pos +blocksize >=inend ;nlen =~blocksize ;AddBit (final &&currentfinal ,bp ,out ,outsize );/* BTYPE 00 */ AddBit (0 ,bp ,out ,outsize );AddBit (0 ,bp ,out ,outsize );/* Any bits of input up to the next byte boundary are ignored. */ *bp =0 ;ZOPFLI_APPEND_DATA (blocksize %256 ,out ,outsize );ZOPFLI_APPEND_DATA ((blocksize /256 )%256 ,out ,outsize );ZOPFLI_APPEND_DATA (nlen %256 ,out ,outsize );ZOPFLI_APPEND_DATA ((nlen /256 )%256 ,out ,outsize );for (i =0 ;i <blocksize ;i ++){ZOPFLI_APPEND_DATA (in [pos +i ],out ,outsize );}if (currentfinal )break ;pos +=blocksize ;}}",
                "rust_signature": "pub fn add_non_compressed_block(\n    options: &ZopfliOptions,\n    final_block: i32,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    bp: &mut u8,\n    out: &mut Vec<u8>,\n    outsize: &mut usize,\n) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "AddNonCompressedBlock",
                    "main_purpose": "将输入数据作为非压缩块添加到输出缓冲区中，并按照Deflate格式生成块头和块数据。",
                    "detailed_logic": "函数首先初始化起始位置，并进入一个循环处理输入数据。每次循环处理一个块，块大小最多为65535字节（Deflate格式的最大块大小）。如果剩余数据不足65535字节，则调整块大小为剩余数据长度。函数生成块头，包括是否为最终块标志和块类型（非压缩块类型为00）。接着，计算块大小和其按位取反值，并将这些值以小端字节序写入输出缓冲区。随后，将块中的数据逐字节写入输出缓冲区。循环继续处理剩余数据，直到所有数据处理完毕或当前块为最终块。",
                    "error_handling": "函数未显式处理错误。假设输入参数有效，并且输出缓冲区有足够空间容纳数据。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliGetLengthExtraBitsValue(int)": {
                "signature": "int ZopfliGetLengthExtraBitsValue(int)",
                "description": "/* Gets value of the extra bits for the given length, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetLengthExtraBitsValue (int l ){static const int table [259 ]={0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,0 ,1 ,0 ,1 ,0 ,1 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,31 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,31 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,31 ,0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ,30 ,0 };return table [l ];}",
                "rust_signature": "fn zopfli_get_length_extra_bits_value(l: usize) -> Option<i32> {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "zopfli_get_length_extra_bits_value",
                    "main_purpose": "根据输入的长度值l，返回对应的额外位数值，用于Zopfli压缩算法中的长度编码。",
                    "detailed_logic": "函数通过一个静态常量表table，根据输入参数l（假定为0到258之间的整数）直接索引并返回对应的值。table是一个长度为259的数组，预定义了每个可能长度值l对应的额外位数值。函数的核心逻辑是简单的数组查找操作，返回table[l]。",
                    "error_handling": "函数没有显式的错误检查机制。如果输入参数l超出table的索引范围（即小于0或大于258），行为是未定义的，可能导致越界访问或程序崩溃。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "ZopfliGetDistExtraBitsValue(int)": {
                "signature": "int ZopfliGetDistExtraBitsValue(int)",
                "description": "/* Gets value of the extra bits for the given dist, cfr. the DEFLATE spec. */",
                "dependencies": {},
                "full_text": "static int ZopfliGetDistExtraBitsValue (int dist ){if (dist <5 ){return 0 ;}else {int l =31 ^__builtin_clz (dist -1 );/* log2(dist - 1) */ return (dist -(1 +(1 <<l )))&((1 <<(l -1 ))-1 );}}",
                "rust_signature": "pub fn zopfli_get_dist_extra_bits_value(dist: i32) -> i32 {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "ZopfliGetDistExtraBitsValue",
                    "main_purpose": "计算给定距离值的额外位值，用于数据压缩算法中的距离编码。",
                    "detailed_logic": "函数首先检查输入的距离值是否小于5。如果是，则直接返回0，因为这些距离值不需要额外位。否则，函数计算距离值减1的二进制对数（log2(dist - 1)），使用内置函数__builtin_clz来高效实现。接着，根据计算出的对数值l，计算距离值的偏移量，并通过位运算提取额外位值。最终返回该额外位值。",
                    "error_handling": "函数没有显式的错误处理机制，假定输入的距离值始终为有效的正整数。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nAdds all lit/len and dist codes from the lists as huffman symbols. Does not add\nend code 256. expected_data_size is the uncompressed block size, used for\nassert, but you can set it to 0 to not do the assertion.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBitsValue(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBitsValue(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetLengthExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthExtraBits(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistExtraBitsValue(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBitsValue(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistExtraBits(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistExtraBits(int)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddLZ77Data (const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t expected_data_size ,const unsigned *ll_symbols ,const unsigned *ll_lengths ,const unsigned *d_symbols ,const unsigned *d_lengths ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){size_t testlength =0 ;size_t i ;for (i =lstart ;i <lend ;i ++){unsigned dist =lz77 ->dists [i ];unsigned litlen =lz77 ->litlens [i ];if (dist ==0 ){assert (litlen <256 );assert (ll_lengths [litlen ]>0 );AddHuffmanBits (ll_symbols [litlen ],ll_lengths [litlen ],bp ,out ,outsize );testlength ++;}else {unsigned lls =ZopfliGetLengthSymbol (litlen );unsigned ds =ZopfliGetDistSymbol (dist );assert (litlen >=3 &&litlen <=288 );assert (ll_lengths [lls ]>0 );assert (d_lengths [ds ]>0 );AddHuffmanBits (ll_symbols [lls ],ll_lengths [lls ],bp ,out ,outsize );AddBits (ZopfliGetLengthExtraBitsValue (litlen ),ZopfliGetLengthExtraBits (litlen ),bp ,out ,outsize );AddHuffmanBits (d_symbols [ds ],d_lengths [ds ],bp ,out ,outsize );AddBits (ZopfliGetDistExtraBitsValue (dist ),ZopfliGetDistExtraBits (dist ),bp ,out ,outsize );testlength +=litlen ;}}assert (expected_data_size ==0 ||testlength ==expected_data_size );}",
                "rust_signature": "pub fn add_lz77_data(\n    lz77: &ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    ll_symbols: &[u32],\n    ll_lengths: &[u32],\n    d_symbols: &[u32],\n    d_lengths: &[u32],\n    bp: &mut u8,\n    out: &mut Vec<u8>,\n    outsize: &mut usize,\n) {\n    // Function body is intentionally left unimplemented.\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "AddLZ77Data",
                    "main_purpose": "将LZ77压缩数据转换为霍夫曼编码并写入输出缓冲区，同时验证数据长度是否符合预期。",
                    "detailed_logic": "函数遍历指定范围内的LZ77数据（从lstart到lend），根据每个数据项的类型（字面值或长度/距离对）进行不同的处理。如果数据项是字面值（dist为0），则直接将其转换为霍夫曼编码并写入输出缓冲区，同时更新testlength计数器。如果数据项是长度/距离对，则计算其对应的符号和额外位数，将这些信息编码为霍夫曼编码并写入输出缓冲区，同时更新testlength计数器。最后，函数通过断言验证testlength是否与expected_data_size匹配（如果expected_data_size不为0）。",
                    "error_handling": "函数通过assert语句进行错误检查，包括验证字面值和长度/距离对的范围是否有效，以及霍夫曼编码长度是否大于0。如果断言失败，程序将终止执行。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                "description": "",
                "dependencies": {
                    "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::EncodeTree(const unsigned int *, const unsigned int *, int, int, int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddDynamicTree (const unsigned *ll_lengths ,const unsigned *d_lengths ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){int i ;int best =0 ;size_t bestsize =0 ;for (i =0 ;i <8 ;i ++){size_t size =EncodeTree (ll_lengths ,d_lengths ,i &1 ,i &2 ,i &4 ,0 ,0 ,0 );if (bestsize ==0 ||size <bestsize ){bestsize =size ;best =i ;}}EncodeTree (ll_lengths ,d_lengths ,best &1 ,best &2 ,best &4 ,bp ,out ,outsize );}",
                "rust_signature": "",
                "conversion_status": "success",
                "conversion_rounds": 4
            },
            "AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "/*\nAdds a deflate block with the given LZ77 data to the output.\noptions: global program options\nbtype: the block type, must be 1 or 2\nfinal: whether to set the \"final\" bit on this block, must be the last block\nlitlens: literal/length array of the LZ77 data, in the same format as in\nZopfliLZ77Store.\ndists: distance array of the LZ77 data, in the same format as in\nZopfliLZ77Store.\nlstart: where to start in the LZ77 data\nlend: where to end in the LZ77 data (not inclusive)\nexpected_data_size: the uncompressed block size, used for assert, but you can\nset it to 0 to not do the assertion.\nbp: output bit pointer\nout: dynamic output array to append to\noutsize: dynamic output array size\n*/",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddNonCompressedBlock(const ZopfliOptions *, int, const unsigned char *, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBit(int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::GetFixedTree(unsigned int *, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::GetFixedTree(unsigned int *, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetDynamicLengths(const ZopfliLZ77Store *, size_t, size_t, unsigned int *, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddDynamicTree(const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLengthsToSymbols(const unsigned int *, size_t, unsigned int, unsigned int *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77Data(const ZopfliLZ77Store *, size_t, size_t, size_t, const unsigned int *, const unsigned int *, const unsigned int *, const unsigned int *, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddHuffmanBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddLZ77Block (const ZopfliOptions *options ,int btype ,int final ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t expected_data_size ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){unsigned ll_lengths [ZOPFLI_NUM_LL ];unsigned d_lengths [ZOPFLI_NUM_D ];unsigned ll_symbols [ZOPFLI_NUM_LL ];unsigned d_symbols [ZOPFLI_NUM_D ];size_t detect_block_size =*outsize ;size_t compressed_size ;size_t uncompressed_size =0 ;size_t i ;if (btype ==0 ){size_t length =ZopfliLZ77GetByteRange (lz77 ,lstart ,lend );size_t pos =lstart ==lend ?0 :lz77 ->pos [lstart ];size_t end =pos +length ;AddNonCompressedBlock (options ,final ,lz77 ->data ,pos ,end ,bp ,out ,outsize );return ;}AddBit (final ,bp ,out ,outsize );AddBit (btype &1 ,bp ,out ,outsize );AddBit ((btype &2 )>>1 ,bp ,out ,outsize );if (btype ==1 ){/* Fixed block. */ GetFixedTree (ll_lengths ,d_lengths );}else {/* Dynamic block. */ unsigned detect_tree_size ;assert (btype ==2 );GetDynamicLengths (lz77 ,lstart ,lend ,ll_lengths ,d_lengths );detect_tree_size =*outsize ;AddDynamicTree (ll_lengths ,d_lengths ,bp ,out ,outsize );if (options ->verbose ){fprintf (stderr ,\"treesize: %d\\n\" ,(int )(*outsize -detect_tree_size ));}}ZopfliLengthsToSymbols (ll_lengths ,ZOPFLI_NUM_LL ,15 ,ll_symbols );ZopfliLengthsToSymbols (d_lengths ,ZOPFLI_NUM_D ,15 ,d_symbols );detect_block_size =*outsize ;AddLZ77Data (lz77 ,lstart ,lend ,expected_data_size ,ll_symbols ,ll_lengths ,d_symbols ,d_lengths ,bp ,out ,outsize );/* End symbol. */ AddHuffmanBits (ll_symbols [256 ],ll_lengths [256 ],bp ,out ,outsize );for (i =lstart ;i <lend ;i ++){uncompressed_size +=lz77 ->dists [i ]==0 ?1 :lz77 ->litlens [i ];}compressed_size =*outsize -detect_block_size ;if (options ->verbose ){fprintf (stderr ,\"compressed block size: %d (%dk) (unc: %d)\\n\" ,(int )compressed_size ,(int )(compressed_size /1024 ),(int )(uncompressed_size ));}}",
                "rust_signature": "pub fn add_lz77_block(\n    options: *const ZopfliOptions,\n    btype: i32,\n    final_block: i32,\n    lz77: *const ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    bp: *mut u8,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)": {
                "signature": "void StoreInLongestMatchCache(ZopfliBlockState *, size_t, size_t, const unsigned short *, unsigned short, unsigned short)",
                "description": "/*\nStores the found sublen, distance and length in the longest match cache, if\npossible.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliSublenToCache(const unsigned short *, size_t, size_t, ZopfliLongestMatchCache *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void StoreInLongestMatchCache (ZopfliBlockState *s ,size_t pos ,size_t limit ,const unsigned short *sublen ,unsigned short distance ,unsigned short length ){/* The LMC cache starts at the beginning of the block rather than the\n       beginning of the whole array. */ size_t lmcpos =pos -s ->blockstart ;/* Length > 0 and dist 0 is invalid combination, which indicates on purpose\n       that this cache value is not filled in yet. */ unsigned char cache_available =s ->lmc &&(s ->lmc ->length [lmcpos ]==0 ||s ->lmc ->dist [lmcpos ]!=0 );if (s ->lmc &&limit ==ZOPFLI_MAX_MATCH &&sublen &&!cache_available ){assert (s ->lmc ->length [lmcpos ]==1 &&s ->lmc ->dist [lmcpos ]==0 );s ->lmc ->dist [lmcpos ]=length <ZOPFLI_MIN_MATCH ?0 :distance ;s ->lmc ->length [lmcpos ]=length <ZOPFLI_MIN_MATCH ?0 :length ;assert (!(s ->lmc ->length [lmcpos ]==1 &&s ->lmc ->dist [lmcpos ]==0 ));ZopfliSublenToCache (sublen ,lmcpos ,length ,s ->lmc );}}",
                "rust_signature": "pub fn store_in_longest_match_cache(\n    s: &mut ZopfliBlockState,\n    pos: usize,\n    limit: usize,\n    sublen: Option<&[u16]>,\n    distance: u16,\n    length: u16,\n) {\n    todo!(\"Function body not implemented. Placeholder for StoreInLongestMatchCache logic.\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "StoreInLongestMatchCache",
                    "main_purpose": "将匹配的长度和距离信息存储到最长匹配缓存中，以优化压缩算法的性能。",
                    "detailed_logic": "函数首先计算缓存位置（lmcpos），该位置基于当前块的起始位置和输入参数pos。接着检查缓存是否可用，通过验证缓存的长度和距离值是否符合预期。若缓存不可用且满足特定条件（limit为最大匹配值、sublen非空、缓存未填充），则将匹配的长度和距离信息存储到缓存中。存储时，若长度小于最小匹配值，则将距离和长度设置为0。最后调用ZopfliSublenToCache函数，将子长度数组转换并存储到缓存中。",
                    "error_handling": "函数通过assert语句验证缓存的状态是否符合预期，例如在存储前后检查缓存的长度和距离值是否有效。若断言失败，程序将终止运行。此外，函数对输入参数进行了条件检查（如sublen是否为空），以确保操作的安全性。",
                    "dependencies": {
                        "zopfli::ZopfliBlockState": {
                            "signature": "pub struct ZopfliBlockState { pub options: *const ZopfliOptions, pub lmc: *mut ZopfliLongestMatchCache, pub blockstart: usize, pub blockend: usize }",
                            "usage": "使用blockstart字段计算缓存位置（lmcpos），使用lmc字段访问和更新最长匹配缓存。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)": {
                "signature": "int TryGetFromLongestMatchCache(ZopfliBlockState *, size_t, size_t *, unsigned short *, unsigned short *, unsigned short *)",
                "description": "/*\nGets distance, length and sublen values from the cache if possible.\nReturns 1 if it got the values from the cache, 0 if not.\nUpdates the limit value to a smaller one if possible with more limited\ninformation from the cache.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCacheToSublen(const ZopfliLongestMatchCache *, size_t, size_t, unsigned short *)",
                        "type": "functions"
                    }
                },
                "full_text": "static int TryGetFromLongestMatchCache (ZopfliBlockState *s ,size_t pos ,size_t *limit ,unsigned short *sublen ,unsigned short *distance ,unsigned short *length ){/* The LMC cache starts at the beginning of the block rather than the\n       beginning of the whole array. */ size_t lmcpos =pos -s ->blockstart ;/* Length > 0 and dist 0 is invalid combination, which indicates on purpose\n       that this cache value is not filled in yet. */ unsigned char cache_available =s ->lmc &&(s ->lmc ->length [lmcpos ]==0 ||s ->lmc ->dist [lmcpos ]!=0 );unsigned char limit_ok_for_cache =cache_available &&(*limit ==ZOPFLI_MAX_MATCH ||s ->lmc ->length [lmcpos ]<=*limit ||(sublen &&ZopfliMaxCachedSublen (s ->lmc ,lmcpos ,s ->lmc ->length [lmcpos ])>=*limit ));if (s ->lmc &&limit_ok_for_cache &&cache_available ){if (!sublen ||s ->lmc ->length [lmcpos ]<=ZopfliMaxCachedSublen (s ->lmc ,lmcpos ,s ->lmc ->length [lmcpos ])){*length =s ->lmc ->length [lmcpos ];if (*length >*limit )*length =*limit ;if (sublen ){ZopfliCacheToSublen (s ->lmc ,lmcpos ,*length ,sublen );*distance =sublen [*length ];if (*limit ==ZOPFLI_MAX_MATCH &&*length >=ZOPFLI_MIN_MATCH ){assert (sublen [*length ]==s ->lmc ->dist [lmcpos ]);}}else {*distance =s ->lmc ->dist [lmcpos ];}return 1 ;}/* Can't use much of the cache, since the \"sublens\" need to be calculated,\n           but at  least we already know when to stop. */ *limit =s ->lmc ->length [lmcpos ];}return 0 ;}",
                "rust_signature": "fn try_get_from_longest_match_cache(\n    s: &ZopfliBlockState,\n    pos: usize,\n    limit: &mut usize,\n    sublen: Option<&mut [u16]>,\n    distance: &mut u16,\n    length: &mut u16,\n) -> i32 {\n    // The function body is not implemented.\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "TryGetFromLongestMatchCache",
                    "main_purpose": "尝试从最长匹配缓存中获取匹配长度和距离信息，以优化压缩算法中的匹配查找。",
                    "detailed_logic": "函数首先计算当前位置在缓存中的偏移量（lmcpos）。然后检查缓存是否可用以及限制条件是否满足。如果缓存可用且限制条件满足，函数会根据是否需要子长度数组（sublen）来决定如何处理缓存数据。如果需要子长度数组，函数会调用ZopfliCacheToSublen将缓存数据转换为子长度数组，并更新距离和长度值；否则直接从缓存中获取距离和长度值。最后返回1表示成功。如果缓存不可用或限制条件不满足，函数更新限制值并返回0表示失败。",
                    "error_handling": "函数通过检查缓存是否可用（cache_available）以及限制条件是否满足（limit_ok_for_cache）来确保数据的有效性。如果条件不满足，函数不会使用缓存数据，并返回0表示失败。",
                    "dependencies": {
                        "zopfli::ZopfliBlockState": {
                            "signature": "pub struct ZopfliBlockState",
                            "usage": "提供当前块的起始位置（blockstart）和缓存指针（lmc），用于计算缓存偏移量和访问缓存数据。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)": {
                "signature": "const unsigned char * GetMatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)",
                "description": "/*\nFinds how long the match of scan and match is. Can be used to find how many\nbytes starting from scan, and from match, are equal. Returns the last byte\nafter scan, which is still equal to the correspondinb byte after match.\nscan is the position to compare\nmatch is the earlier position to compare.\nend is the last possible byte, beyond which to stop looking.\nsafe_end is a few (8) bytes before end, for comparing multiple bytes at once.\n*/",
                "dependencies": {},
                "full_text": "static const unsigned char *GetMatch (const unsigned char *scan ,const unsigned char *match ,const unsigned char *end ,const unsigned char *safe_end ){if (sizeof (size_t )==8 ){/* 8 checks at once per array bounds check (size_t is 64-bit). */ while (scan <safe_end &&*((size_t *)scan )==*((size_t *)match )){scan +=8 ;match +=8 ;}}else if (sizeof (unsigned int )==4 ){/* 4 checks at once per array bounds check (unsigned int is 32-bit). */ while (scan <safe_end &&*((unsigned int *)scan )==*((unsigned int *)match )){scan +=4 ;match +=4 ;}}else {/* do 8 checks at once per array bounds check. */ while (scan <safe_end &&*scan ==*match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match &&*++scan ==*++match ){scan ++;match ++;}}/* The remaining few bytes. */ while (scan !=end &&*scan ==*match ){scan ++;match ++;}return scan ;}",
                "rust_signature": "pub fn get_match(scan: *const u8, match_: *const u8, end: *const u8, safe_end: *const u8) -> *const u8 {\n    // Function body intentionally left unimplemented\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "GetMatch",
                    "main_purpose": "比较两个字节序列(scan和match)的内容，找到它们最长的匹配前缀，并返回匹配结束时scan的位置。",
                    "detailed_logic": "函数通过逐字节或逐块比较两个字节序列(scan和match)的内容，找到它们的最长匹配前缀。具体逻辑如下：\n1. 根据系统的字长，选择最优的比较策略：\n   - 如果size_t为64位(8字节)，则以8字节为单位进行比较。\n   - 如果unsigned int为32位(4字节)，则以4字节为单位进行比较。\n   - 如果上述条件都不满足，则逐字节进行比较。\n2. 在每次比较前，确保scan指针未越过safe_end，以避免越界访问。\n3. 在块比较结束后，处理剩余的少量字节，逐字节比较直到scan到达end。\n4. 返回匹配结束时的scan指针位置。",
                    "error_handling": "函数未显式处理错误，但通过以下方式避免潜在问题：\n1. 使用safe_end作为边界检查，确保指针解引用不会越界。\n2. 在逐字节比较阶段，确保scan指针不会超过end。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "UpdateHashValue(ZopfliHash *, unsigned char)": {
                "signature": "void UpdateHashValue(ZopfliHash *, unsigned char)",
                "description": "/*\nUpdate the sliding hash value with the given byte. All calls to this function\nmust be made on consecutive input characters. Since the hash value exists out\nof multiple input bytes, a few warmups with this function are needed initially.\n*/",
                "dependencies": {
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::HASH_MASK": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::HASH_MASK",
                        "type": "defines"
                    },
                    "zopfli::HASH_SHIFT": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::HASH_SHIFT",
                        "type": "defines"
                    }
                },
                "full_text": "static void UpdateHashValue (ZopfliHash *h ,unsigned char c ){h ->val =(((h ->val )<<HASH_SHIFT )^(c ))&HASH_MASK ;}",
                "rust_signature": "fn update_hash_value(h: *mut ZopfliHash, c: u8) { unimplemented!() }",
                "conversion_status": "success",
                "conversion_rounds": 3,
                "function_summary": {
                    "function_name": "update_hash_value",
                    "main_purpose": "更新ZopfliHash结构中的当前哈希值字段（val），根据输入字符计算新的哈希值。",
                    "detailed_logic": "函数通过以下步骤更新哈希值：\n1. 将当前哈希值（h->val）左移HASH_SHIFT位。\n2. 使用按位异或操作将左移后的值与输入字符c结合。\n3. 使用HASH_MASK对结果进行按位与操作，以确保哈希值在有效范围内。\n4. 将计算结果存储回ZopfliHash结构的val字段。",
                    "error_handling": "该函数没有显式的错误检查或处理机制。假设输入参数有效并且操作不会失败。",
                    "dependencies": {
                        "zopfli::ZopfliHash": {
                            "signature": "pub struct ZopfliHash",
                            "usage": "函数直接修改ZopfliHash结构的val字段，用于存储更新后的哈希值。"
                        },
                        "zopfli::HASH_MASK": {
                            "signature": "const HASH_MASK: u32",
                            "usage": "用于限制哈希值的范围，通过按位与操作确保结果在有效范围内。"
                        },
                        "zopfli::HASH_SHIFT": {
                            "signature": "const HASH_SHIFT: usize",
                            "usage": "用于控制哈希值的左移位数，从而影响哈希计算的结果。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                "signature": "void FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::ZopfliResetHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliResetHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliVerifyLenDist(const unsigned char *, size_t, size_t, unsigned short, unsigned short)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliStoreLitLenDist(unsigned short, unsigned short, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void FollowPath (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned short *path ,size_t pathsize ,ZopfliLZ77Store *store ,ZopfliHash *h ){size_t i ,j ,pos =0 ;size_t windowstart =instart >ZOPFLI_WINDOW_SIZE ?instart -ZOPFLI_WINDOW_SIZE :0 ;size_t total_length_test =0 ;if (instart ==inend )return ;ZopfliResetHash (ZOPFLI_WINDOW_SIZE ,h );ZopfliWarmupHash (in ,windowstart ,inend ,h );for (i =windowstart ;i <instart ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );}pos =instart ;for (i =0 ;i <pathsize ;i ++){unsigned short length =path [i ];unsigned short dummy_length ;unsigned short dist ;assert (pos <inend );ZopfliUpdateHash (in ,pos ,inend ,h );/* Add to output. */ if (length >=ZOPFLI_MIN_MATCH ){/* Get the distance by recalculating longest match. The found length\n            should match the length from the path. */ ZopfliFindLongestMatch (s ,h ,in ,pos ,inend ,length ,0 ,&dist ,&dummy_length );assert (!(dummy_length !=length &&length >2 &&dummy_length >2 ));ZopfliVerifyLenDist (in ,inend ,pos ,dist ,length );ZopfliStoreLitLenDist (length ,dist ,pos ,store );total_length_test +=length ;}else {length =1 ;ZopfliStoreLitLenDist (in [pos ],0 ,pos ,store );total_length_test ++;}assert (pos +length <=inend );for (j =1 ;j <length ;j ++){ZopfliUpdateHash (in ,pos +j ,inend ,h );}pos +=length ;}}",
                "rust_signature": "pub unsafe fn follow_path(\n    s: &mut ZopfliBlockState,\n    input: &[u8],\n    instart: usize,\n    inend: usize,\n    path: &[u16],\n    store: &mut ZopfliLZ77Store,\n    h: &mut ZopfliHash,\n) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "FollowPath",
                    "main_purpose": "根据给定的路径信息（path数组），对输入数据进行哈希更新和匹配查找，并将匹配结果存储到LZ77存储结构中，用于优化数据压缩。",
                    "detailed_logic": "函数首先初始化哈希结构并预热哈希值，然后从输入数据的起始位置开始，逐步按照路径信息（path数组）处理每个匹配或字节。对于每个路径元素，如果路径长度大于等于最小匹配长度，则通过重新计算最长匹配来获取匹配的距离，并验证匹配的正确性，最后将匹配结果存储到LZ77存储结构中。如果路径长度小于最小匹配长度，则将当前字节作为文字存储。函数在每次处理后更新哈希值，并移动当前位置指针以处理下一个路径元素。",
                    "error_handling": "函数通过assert语句检查输入数据的有效性，包括路径长度、当前位置是否超出输入数据范围、以及匹配长度和距离的正确性。如果断言失败，程序将终止运行。",
                    "dependencies": {
                        "zopfli::ZopfliBlockState": {
                            "signature": "pub struct ZopfliBlockState",
                            "usage": "作为函数的输入参数，提供当前块的状态信息，包括压缩选项和匹配缓存。"
                        },
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "作为函数的输入参数，用于存储路径处理过程中生成的LZ77匹配和文字信息。"
                        },
                        "zopfli::ZopfliHash": {
                            "signature": "pub struct ZopfliHash",
                            "usage": "作为函数的输入参数，用于跟踪和更新输入数据的哈希值，以支持匹配查找和验证。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)": {
                "signature": "void TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)",
                "description": "/*\nCalculates the optimal path of lz77 lengths to use, from the calculated\nlength_array. The length_array must contain the optimal length to reach that\nbyte. The path will be filled with the lengths to use, so its data size will be\nthe amount of lz77 symbols.\n*/",
                "dependencies": {},
                "full_text": "static void TraceBackwards (size_t size ,const unsigned short *length_array ,unsigned short **path ,size_t *pathsize ){size_t index =size ;if (size ==0 )return ;for (;;){ZOPFLI_APPEND_DATA (length_array [index ],path ,pathsize );assert (length_array [index ]<=index );assert (length_array [index ]<=ZOPFLI_MAX_MATCH );assert (length_array [index ]!=0 );index -=length_array [index ];if (index ==0 )break ;}/* Mirror result. */ for (index =0 ;index <*pathsize /2 ;index ++){unsigned short temp =(*path )[index ];(*path )[index ]=(*path )[*pathsize -index -1 ];(*path )[*pathsize -index -1 ]=temp ;}}",
                "rust_signature": "pub fn trace_backwards(size: usize, length_array: &[u16], path: &mut *mut u16, pathsize: &mut usize) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "TraceBackwards",
                    "main_purpose": "从给定的长度数组中回溯路径，并生成一个反转的路径序列。",
                    "detailed_logic": "函数首先检查输入大小是否为0，如果是则直接返回。然后从输入的size开始，通过length_array逐步回溯路径，将每一步的长度值追加到path中，同时更新当前索引。回溯过程中，函数通过断言确保长度值的有效性（长度值不为0，且不超过当前索引和最大匹配长度）。当索引回溯到0时结束。最后，函数对生成的路径序列进行反转，以确保路径的顺序正确。",
                    "error_handling": "函数通过断言检查length_array中的值是否满足以下条件：1. 当前长度值不超过当前索引；2. 当前长度值不超过最大匹配长度；3. 当前长度值不为0。如果断言失败，程序会终止运行。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "zopfli_min(size_t, size_t)": {
                "signature": "size_t zopfli_min(size_t, size_t)",
                "description": "",
                "dependencies": {},
                "full_text": "static size_t zopfli_min (size_t a ,size_t b ){return a <b ?a :b ;}",
                "rust_signature": "fn zopfli_min(a: usize, b: usize) -> usize { unimplemented!() }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "zopfli_min",
                    "main_purpose": "比较两个无符号整数并返回其中较小的值。",
                    "detailed_logic": "函数接收两个无符号整数参数 `a` 和 `b`，通过条件表达式 `a < b ? a : b` 判断 `a` 是否小于 `b`。如果条件为真，则返回 `a`；否则返回 `b`。这实现了一个简单的最小值计算逻辑。",
                    "error_handling": "该函数没有任何错误检查或处理机制，因为其逻辑简单且参数类型为无符号整数，无法产生错误状态。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "GetCostModelMinCost(CostModelFun *, void *)": {
                "signature": "double GetCostModelMinCost(CostModelFun *, void *)",
                "description": "/*\nFinds the minimum possible cost this cost model can return for valid length and\ndistance symbols.\n*/",
                "dependencies": {
                    "zopfli::CostModelFun": {
                        "return_type": "CostModelFun",
                        "qualified_name": "zopfli::CostModelFun",
                        "type": "typedefs"
                    }
                },
                "full_text": "static double GetCostModelMinCost (CostModelFun *costmodel ,void *costcontext ){double mincost ;int bestlength =0 ;/* length that has lowest cost in the cost model */ int bestdist =0 ;/* distance that has lowest cost in the cost model */ int i ;/*\n    Table of distances that have a different distance symbol in the deflate\n    specification. Each value is the first distance that has a new symbol. Only\n    different symbols affect the cost model so only these need to be checked.\n    See RFC 1951 section 3.2.5. Compressed blocks (length and distance codes).\n    */ static const int dsymbols [30 ]={1 ,2 ,3 ,4 ,5 ,7 ,9 ,13 ,17 ,25 ,33 ,49 ,65 ,97 ,129 ,193 ,257 ,385 ,513 ,769 ,1025 ,1537 ,2049 ,3073 ,4097 ,6145 ,8193 ,12289 ,16385 ,24577 };mincost =ZOPFLI_LARGE_FLOAT ;for (i =3 ;i <259 ;i ++){double c =costmodel (i ,1 ,costcontext );if (c <mincost ){bestlength =i ;mincost =c ;}}mincost =ZOPFLI_LARGE_FLOAT ;for (i =0 ;i <30 ;i ++){double c =costmodel (3 ,dsymbols [i ],costcontext );if (c <mincost ){bestdist =dsymbols [i ];mincost =c ;}}return costmodel (bestlength ,bestdist ,costcontext );}",
                "rust_signature": "fn get_cost_model_min_cost(costmodel: CostModelFun, costcontext: Option<*mut core::ffi::c_void>) -> f64 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "get_cost_model_min_cost",
                    "main_purpose": "计算并返回基于给定成本模型的最小成本值，结合最佳长度和最佳距离的组合。",
                    "detailed_logic": "函数首先初始化最小成本值为一个非常大的浮点数（ZOPFLI_LARGE_FLOAT）。然后，它分两部分执行：\n1. 遍历可能的长度值范围（3到258），调用成本模型函数计算每个长度值的成本。如果发现某个长度的成本低于当前最小成本，则更新最小成本和对应的最佳长度。\n2. 遍历一个预定义的距离符号数组（dsymbols），调用成本模型函数计算每个距离符号的成本（固定长度为3）。如果发现某个距离符号的成本低于当前最小成本，则更新最小成本和对应的最佳距离。\n最后，函数使用找到的最佳长度和最佳距离再次调用成本模型函数，并返回最终的成本值。",
                    "error_handling": "函数本身没有显式的错误处理机制。它假设成本模型函数始终返回有效的浮点值，并且输入参数（如成本模型函数指针和上下文）是有效的。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)": {
                "signature": "double GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)",
                "description": "/*\nPerforms the forward pass for \"squeeze\". Gets the most optimal length to reach\nevery byte from a previous byte, using cost calculations.\ns: the ZopfliBlockState\nin: the input data array\ninstart: where to start\ninend: where to stop (not inclusive)\ncostmodel: function to calculate the cost of some lit/len/dist pair.\ncostcontext: abstract context for the costmodel function\nlength_array: output array of size (inend - instart) which will receive the best\nlength to reach this byte from a previous byte.\nreturns the cost that was, according to the costmodel, needed to get to the end.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::CostModelFun": {
                        "return_type": "CostModelFun",
                        "qualified_name": "zopfli::CostModelFun",
                        "type": "typedefs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::GetCostModelMinCost(CostModelFun *, void *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetCostModelMinCost(CostModelFun *, void *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliResetHash(size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliResetHash(size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliWarmupHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliUpdateHash(const unsigned char *, size_t, size_t, ZopfliHash *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliFindLongestMatch(ZopfliBlockState *, const ZopfliHash *, const unsigned char *, size_t, size_t, size_t, unsigned short *, unsigned short *, unsigned short *)",
                        "type": "functions"
                    },
                    "zopfli::zopfli_min(size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::zopfli_min(size_t, size_t)",
                        "type": "functions"
                    }
                },
                "full_text": "static double GetBestLengths (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,CostModelFun *costmodel ,void *costcontext ,unsigned short *length_array ,ZopfliHash *h ,float *costs ){/* Best cost to get here so far. */ size_t blocksize =inend -instart ;size_t i =0 ,k ,kend ;unsigned short leng ;unsigned short dist ;unsigned short sublen [259 ];size_t windowstart =instart >ZOPFLI_WINDOW_SIZE ?instart -ZOPFLI_WINDOW_SIZE :0 ;double result ;double mincost =GetCostModelMinCost (costmodel ,costcontext );double mincostaddcostj ;if (instart ==inend )return 0 ;ZopfliResetHash (ZOPFLI_WINDOW_SIZE ,h );ZopfliWarmupHash (in ,windowstart ,inend ,h );for (i =windowstart ;i <instart ;i ++){ZopfliUpdateHash (in ,i ,inend ,h );}for (i =1 ;i <blocksize +1 ;i ++)costs [i ]=ZOPFLI_LARGE_FLOAT ;costs [0 ]=0 ;/* Because it's the start. */ length_array [0 ]=0 ;for (i =instart ;i <inend ;i ++){size_t j =i -instart ;/* Index in the costs array and length_array. */ ZopfliUpdateHash (in ,i ,inend ,h );/* If we're in a long repetition of the same character and have more than\n        ZOPFLI_MAX_MATCH characters before and after our position. */ if (h ->same [i &ZOPFLI_WINDOW_MASK ]>ZOPFLI_MAX_MATCH *2 &&i >instart +ZOPFLI_MAX_MATCH +1 &&i +ZOPFLI_MAX_MATCH *2 +1 <inend &&h ->same [(i -ZOPFLI_MAX_MATCH )&ZOPFLI_WINDOW_MASK ]>ZOPFLI_MAX_MATCH ){double symbolcost =costmodel (ZOPFLI_MAX_MATCH ,1 ,costcontext );/* Set the length to reach each one to ZOPFLI_MAX_MATCH, and the cost to\n            the cost corresponding to that length. Doing this, we skip\n            ZOPFLI_MAX_MATCH values to avoid calling ZopfliFindLongestMatch. */ for (k =0 ;k <ZOPFLI_MAX_MATCH ;k ++){costs [j +ZOPFLI_MAX_MATCH ]=costs [j ]+symbolcost ;length_array [j +ZOPFLI_MAX_MATCH ]=ZOPFLI_MAX_MATCH ;i ++;j ++;ZopfliUpdateHash (in ,i ,inend ,h );}}ZopfliFindLongestMatch (s ,h ,in ,i ,inend ,ZOPFLI_MAX_MATCH ,sublen ,&dist ,&leng );/* Literal. */ if (i +1 <=inend ){double newCost =costmodel (in [i ],0 ,costcontext )+costs [j ];assert (newCost >=0 );if (newCost <costs [j +1 ]){costs [j +1 ]=newCost ;length_array [j +1 ]=1 ;}}/* Lengths. */ kend =zopfli_min (leng ,inend -i );mincostaddcostj =mincost +costs [j ];for (k =3 ;k <=kend ;k ++){double newCost ;/* Calling the cost model is expensive, avoid this if we are already at\n            the minimum possible cost that it can return. */ if (costs [j +k ]<=mincostaddcostj )continue ;newCost =costmodel (k ,sublen [k ],costcontext )+costs [j ];assert (newCost >=0 );if (newCost <costs [j +k ]){assert (k <=ZOPFLI_MAX_MATCH );costs [j +k ]=newCost ;length_array [j +k ]=k ;}}}assert (costs [blocksize ]>=0 );result =costs [blocksize ];return result ;}",
                "rust_signature": "pub fn get_best_lengths(\n    s: &mut ZopfliBlockState,\n    input: Option<&[u8]>,\n    instart: usize,\n    inend: usize,\n    costmodel: CostModelFun,\n    costcontext: Option<*mut core::ffi::c_void>,\n    length_array: Option<&mut [u16]>,\n    h: &mut ZopfliHash,\n    costs: Option<&mut [f32]>,\n) -> f64 {\n    // Best cost to get here so far.\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "GetBestLengths",
                    "main_purpose": "计算输入数据的最佳长度和对应的压缩成本，用于优化数据压缩算法。",
                    "detailed_logic": "函数首先初始化哈希结构和成本数组，然后逐字节处理输入数据，计算每个位置的压缩成本和最佳长度。具体步骤如下：\n1. 初始化哈希结构和成本数组。\n2. 对输入数据进行哈希预热和更新。\n3. 遍历输入数据，计算每个位置的压缩成本：\n   - 如果当前字符处于长重复序列中，跳过部分计算以优化性能。\n   - 使用成本模型计算字面值的压缩成本。\n   - 查找最长匹配字符串，并计算其压缩成本。\n4. 更新成本数组和长度数组，记录每个位置的最佳长度和对应成本。\n5. 返回整个数据块的最小压缩成本。",
                    "error_handling": "函数通过断言确保成本值始终为非负数，并检查输入数据范围是否有效。如果输入范围为空，直接返回0作为结果。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)": {
                "signature": "double LZ77OptimalRun(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short **, size_t *, unsigned short *, CostModelFun *, void *, ZopfliLZ77Store *, ZopfliHash *, float *)",
                "description": "/*\nDoes a single run for ZopfliLZ77Optimal. For good compression, repeated runs\nwith updated statistics should be performed.\ns: the block state\nin: the input data array\ninstart: where to start\ninend: where to stop (not inclusive)\npath: pointer to dynamically allocated memory to store the path\npathsize: pointer to the size of the dynamic path array\nlength_array: array of size (inend - instart) used to store lengths\ncostmodel: function to use as the cost model for this squeeze run\ncostcontext: abstract context for the costmodel function\nstore: place to output the LZ77 data\nreturns the cost that was, according to the costmodel, needed to get to the end.\nThis is not the actual cost.\n*/",
                "dependencies": {
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::CostModelFun": {
                        "return_type": "CostModelFun",
                        "qualified_name": "zopfli::CostModelFun",
                        "type": "typedefs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliHash": {
                        "return_type": "ZopfliHash",
                        "qualified_name": "zopfli::ZopfliHash",
                        "type": "structs"
                    },
                    "zopfli::GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::GetBestLengths(ZopfliBlockState *, const unsigned char *, size_t, size_t, CostModelFun *, void *, unsigned short *, ZopfliHash *, float *)",
                        "type": "functions"
                    },
                    "zopfli::TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::TraceBackwards(size_t, const unsigned short *, unsigned short **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::FollowPath(ZopfliBlockState *, const unsigned char *, size_t, size_t, unsigned short *, size_t, ZopfliLZ77Store *, ZopfliHash *)",
                        "type": "functions"
                    }
                },
                "full_text": "static double LZ77OptimalRun (ZopfliBlockState *s ,const unsigned char *in ,size_t instart ,size_t inend ,unsigned short **path ,size_t *pathsize ,unsigned short *length_array ,CostModelFun *costmodel ,void *costcontext ,ZopfliLZ77Store *store ,ZopfliHash *h ,float *costs ){double cost =GetBestLengths (s ,in ,instart ,inend ,costmodel ,costcontext ,length_array ,h ,costs );free (*path );*path =0 ;*pathsize =0 ;TraceBackwards (inend -instart ,length_array ,path ,pathsize );FollowPath (s ,in ,instart ,inend ,*path ,*pathsize ,store ,h );assert (cost <ZOPFLI_LARGE_FLOAT );return cost ;}",
                "rust_signature": "pub fn lz77_optimal_run(\n    s: &mut ZopfliBlockState,\n    input: Option<&[u8]>,\n    instart: usize,\n    inend: usize,\n    path: &mut Option<Box<[u16]>>,\n    pathsize: &mut usize,\n    length_array: Option<&mut [u16]>,\n    costmodel: CostModelFun,\n    costcontext: Option<*mut core::ffi::c_void>,\n    store: &mut ZopfliLZ77Store,\n    h: &mut ZopfliHash,\n    costs: Option<&mut [f32]>\n) -> f64 {\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "LZ77OptimalRun",
                    "main_purpose": "优化LZ77压缩过程，通过计算最佳长度、回溯路径并存储压缩结果。",
                    "detailed_logic": "函数首先调用GetBestLengths计算输入数据的最佳长度和压缩成本，并将结果存储到length_array中。接着释放之前的路径内存并重置path和pathsize。然后调用TraceBackwards从length_array中回溯路径，生成一个反转的路径序列并存储到path中。最后调用FollowPath根据生成的路径信息对输入数据进行哈希更新和匹配查找，并将匹配结果存储到LZ77存储结构中。函数返回计算出的压缩成本。",
                    "error_handling": "函数通过assert确保返回的压缩成本小于ZOPFLI_LARGE_FLOAT。如果path的内存释放失败或其他依赖函数出现问题，可能会导致未定义行为，但函数本身未显式处理这些错误。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                "signature": "void AddLZ77BlockAutoType(const ZopfliOptions *, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)": {
                        "return_type": "double",
                        "qualified_name": "zopfli::ZopfliCalculateBlockSize(const ZopfliLZ77Store *, size_t, size_t, int)",
                        "type": "functions"
                    },
                    "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddBits(unsigned int, unsigned int, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitLZ77Store(const unsigned char *, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)": {
                        "return_type": "size_t",
                        "qualified_name": "zopfli::ZopfliLZ77GetByteRange(const ZopfliLZ77Store *, size_t, size_t)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliBlockState": {
                        "return_type": "ZopfliBlockState",
                        "qualified_name": "zopfli::ZopfliBlockState",
                        "type": "structs"
                    },
                    "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliInitBlockState(const ZopfliOptions *, size_t, size_t, int, ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliLZ77OptimalFixed(ZopfliBlockState *, const unsigned char *, size_t, size_t, ZopfliLZ77Store *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanBlockState(ZopfliBlockState *)",
                        "type": "functions"
                    },
                    "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::AddLZ77Block(const ZopfliOptions *, int, int, const ZopfliLZ77Store *, size_t, size_t, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCleanLZ77Store(ZopfliLZ77Store *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void AddLZ77BlockAutoType (const ZopfliOptions *options ,int final ,const ZopfliLZ77Store *lz77 ,size_t lstart ,size_t lend ,size_t expected_data_size ,unsigned char *bp ,unsigned char **out ,size_t *outsize ){double uncompressedcost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,0 );double fixedcost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,1 );double dyncost =ZopfliCalculateBlockSize (lz77 ,lstart ,lend ,2 );/* Whether to perform the expensive calculation of creating an optimal block\n    with fixed huffman tree to check if smaller. Only do this for small blocks or\n    blocks which already are pretty good with fixed huffman tree. */ int expensivefixed =(lz77 ->size <1000 )||fixedcost <=dyncost *1.1 ;ZopfliLZ77Store fixedstore ;if (lstart ==lend ){/* Smallest empty block is represented by fixed block */ AddBits (final ,1 ,bp ,out ,outsize );AddBits (1 ,2 ,bp ,out ,outsize );/* btype 01 */ AddBits (0 ,7 ,bp ,out ,outsize );/* end symbol has code 0000000 */ return ;}ZopfliInitLZ77Store (lz77 ->data ,&fixedstore );if (expensivefixed ){/* Recalculate the LZ77 with ZopfliLZ77OptimalFixed */ size_t instart =lz77 ->pos [lstart ];size_t inend =instart +ZopfliLZ77GetByteRange (lz77 ,lstart ,lend );ZopfliBlockState s ;ZopfliInitBlockState (options ,instart ,inend ,1 ,&s );ZopfliLZ77OptimalFixed (&s ,lz77 ->data ,instart ,inend ,&fixedstore );fixedcost =ZopfliCalculateBlockSize (&fixedstore ,0 ,fixedstore .size ,1 );ZopfliCleanBlockState (&s );}if (uncompressedcost <fixedcost &&uncompressedcost <dyncost ){AddLZ77Block (options ,0 ,final ,lz77 ,lstart ,lend ,expected_data_size ,bp ,out ,outsize );}else if (fixedcost <dyncost ){if (expensivefixed ){AddLZ77Block (options ,1 ,final ,&fixedstore ,0 ,fixedstore .size ,expected_data_size ,bp ,out ,outsize );}else {AddLZ77Block (options ,1 ,final ,lz77 ,lstart ,lend ,expected_data_size ,bp ,out ,outsize );}}else {AddLZ77Block (options ,2 ,final ,lz77 ,lstart ,lend ,expected_data_size ,bp ,out ,outsize );}ZopfliCleanLZ77Store (&fixedstore );}",
                "rust_signature": "pub fn add_lz77_block_auto_type(\n    options: *const ZopfliOptions,\n    final_block: i32,\n    lz77: *const ZopfliLZ77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    bp: *mut u8,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "GetLengthScore(int, int)": {
                "signature": "int GetLengthScore(int, int)",
                "description": "/*\nGets a score of the length given the distance. Typically, the score of the\nlength is the length itself, but if the distance is very long, decrease the\nscore of the length a bit to make up for the fact that long distances use large\namounts of extra bits.\n\nThis is not an accurate score, it is a heuristic only for the greedy LZ77\nimplementation. More accurate cost models are employed later. Making this\nheuristic more accurate may hurt rather than improve compression.\n\nThe two direct uses of this heuristic are:\n-avoid using a length of 3 in combination with a long distance. This only has\nan effect if length == 3.\n-make a slightly better choice between the two options of the lazy matching.\n\nIndirectly, this affects:\n-the block split points if the default of block splitting first is used, in a\nrather unpredictable way\n-the first zopfli run, so it affects the chance of the first run being closer\nto the optimal output\n*/",
                "dependencies": {},
                "full_text": "static int GetLengthScore (int length ,int distance ){/*\n    At 1024, the distance uses 9+ extra bits and this seems to be the sweet spot\n    on tested files.\n    */ return distance >1024 ?length -1 :length ;}",
                "rust_signature": "pub fn get_length_score(length: i32, distance: i32) -> i32 {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "get_length_score",
                    "main_purpose": "根据给定的长度和距离计算一个评分值，用于优化或调整某些逻辑（例如压缩算法中的距离权重）。",
                    "detailed_logic": "函数接收两个整数参数：length和distance。如果distance大于1024，则返回length减去1；否则直接返回length。此逻辑可能用于调整评分值，以便在距离较大时降低长度的权重。",
                    "error_handling": "函数没有显式的错误检查或处理机制，假设输入参数始终有效。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "CalculateStatistics(SymbolStats *)": {
                "signature": "void CalculateStatistics(SymbolStats *)",
                "description": "/* Calculates the entropy of the statistics */",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::ZopfliCalculateEntropy(const size_t *, size_t, double *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliCalculateEntropy(const size_t *, size_t, double *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void CalculateStatistics (SymbolStats *stats ){ZopfliCalculateEntropy (stats ->litlens ,ZOPFLI_NUM_LL ,stats ->ll_symbols );ZopfliCalculateEntropy (stats ->dists ,ZOPFLI_NUM_D ,stats ->d_symbols );}",
                "rust_signature": "fn calculate_statistics(stats: &mut SymbolStats) {\n    todo!(\"Implement the function logic\");\n}\n",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "calculate_statistics",
                    "main_purpose": "计算符号统计信息的熵值，用于压缩算法中的成本模型。",
                    "detailed_logic": "函数接收一个可变引用的SymbolStats结构体作为参数。它分别调用ZopfliCalculateEntropy函数两次：第一次计算litlens数组中每个符号的熵值，并将结果存储在ll_symbols数组中；第二次计算dists数组中每个符号的熵值，并将结果存储在d_symbols数组中。",
                    "error_handling": "原始C代码中未包含显式的错误处理逻辑。假设依赖函数ZopfliCalculateEntropy能够正确处理输入数据并返回有效结果。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "GetStatistics(const ZopfliLZ77Store *, SymbolStats *)": {
                "signature": "void GetStatistics(const ZopfliLZ77Store *, SymbolStats *)",
                "description": "/* Appends the symbol statistics from the store. */",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    },
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::ZopfliGetLengthSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetLengthSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::ZopfliGetDistSymbol(int)": {
                        "return_type": "int",
                        "qualified_name": "zopfli::ZopfliGetDistSymbol(int)",
                        "type": "functions"
                    },
                    "zopfli::CalculateStatistics(SymbolStats *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::CalculateStatistics(SymbolStats *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void GetStatistics (const ZopfliLZ77Store *store ,SymbolStats *stats ){size_t i ;for (i =0 ;i <store ->size ;i ++){if (store ->dists [i ]==0 ){stats ->litlens [store ->litlens [i ]]++;}else {stats ->litlens [ZopfliGetLengthSymbol (store ->litlens [i ])]++;stats ->dists [ZopfliGetDistSymbol (store ->dists [i ])]++;}}stats ->litlens [256 ]=1 ;/* End symbol. */ CalculateStatistics (stats );}",
                "rust_signature": "pub fn get_statistics(store: &ZopfliLZ77Store, stats: &mut SymbolStats) {\n    // Placeholder implementation\n    todo!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "GetStatistics",
                    "main_purpose": "统计LZ77压缩存储中的符号频率，用于后续的熵编码优化。",
                    "detailed_logic": "函数遍历输入的LZ77存储（store），根据每个元素的距离值（dists）和文字/长度值（litlens）更新符号统计（stats）。如果距离值为0，表示当前元素是一个文字符号，直接增加对应文字符号的计数；否则，将长度值和距离值分别转换为符号（通过ZopfliGetLengthSymbol和ZopfliGetDistSymbol），并增加对应符号的计数。最后，设置特殊的结束符号（256）的计数为1，并调用CalculateStatistics计算统计信息的熵值。",
                    "error_handling": "函数没有显式的错误处理机制，假设输入参数store和stats始终有效。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "作为输入参数，提供LZ77压缩存储的数据，包括文字/长度值数组（litlens）、距离值数组（dists）和存储大小（size）。函数通过遍历store.size来访问每个元素的litlens和dists字段。"
                        },
                        "zopfli::SymbolStats": {
                            "signature": "pub struct SymbolStats",
                            "usage": "作为输出参数，存储符号统计信息，包括文字/长度符号计数（litlens）和距离符号计数（dists）。函数通过直接访问stats.litlens和stats.dists更新符号计数，并在最后调用CalculateStatistics进一步处理。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "ClearStatFreqs(SymbolStats *)": {
                "signature": "void ClearStatFreqs(SymbolStats *)",
                "description": "",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void ClearStatFreqs (SymbolStats *stats ){size_t i ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++)stats ->litlens [i ]=0 ;for (i =0 ;i <ZOPFLI_NUM_D ;i ++)stats ->dists [i ]=0 ;}",
                "rust_signature": "pub fn clear_stat_freqs(stats: &mut SymbolStats) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "clear_stat_freqs",
                    "main_purpose": "重置SymbolStats结构中的litlens和dists数组，将它们的所有元素设置为0。",
                    "detailed_logic": "函数通过两个for循环依次遍历SymbolStats结构中的litlens和dists数组。第一个循环从索引0到ZOPFLI_NUM_LL-1，将litlens数组的每个元素设置为0。第二个循环从索引0到ZOPFLI_NUM_D-1，将dists数组的每个元素设置为0。",
                    "error_handling": "该函数没有任何错误检查或处理机制，因为它假设输入参数stats始终是有效的，并且数组的大小由常量ZOPFLI_NUM_LL和ZOPFLI_NUM_D定义。",
                    "dependencies": {
                        "zopfli::SymbolStats": {
                            "signature": "pub struct SymbolStats { pub litlens: [usize; ZOPFLI_NUM_LL], pub dists: [usize; ZOPFLI_NUM_D], pub ll_symbols: [f64; ZOPFLI_NUM_LL], pub d_symbols: [f64; ZOPFLI_NUM_D] }",
                            "usage": "函数直接访问SymbolStats结构中的litlens和dists数组，并将它们的所有元素设置为0。未使用ll_symbols和d_symbols字段。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "Ran(RanState *)": {
                "signature": "unsigned int Ran(RanState *)",
                "description": "/* Get random number: \"Multiply-With-Carry\" generator of G. Marsaglia */",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    }
                },
                "full_text": "static unsigned int Ran (RanState *state ){state ->m_z =36969 *(state ->m_z &65535 )+(state ->m_z >>16 );state ->m_w =18000 *(state ->m_w &65535 )+(state ->m_w >>16 );return (state ->m_z <<16 )+state ->m_w ;/* 32-bit result. */ }",
                "rust_signature": "fn ran(state: &mut RanState) -> u32 {\n    // 更新state的m_z和m_w，并返回32位结果\n    // 原始C代码逻辑未实现，仅提供函数签名\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "Ran",
                    "main_purpose": "生成一个伪随机数并更新RanState的内部状态",
                    "detailed_logic": "函数通过两个线性同余生成器（LCG）更新RanState中的m_z和m_w字段。具体步骤如下：\n1. 更新m_z：使用公式 `m_z = 36969 * (m_z & 65535) + (m_z >> 16)`，其中 `(m_z & 65535)` 提取m_z的低16位，`(m_z >> 16)` 提取m_z的高16位。\n2. 更新m_w：使用公式 `m_w = 18000 * (m_w & 65535) + (m_w >> 16)`，其中 `(m_w & 65535)` 提取m_w的低16位，`(m_w >> 16)` 提取m_w的高16位。\n3. 返回结果：将更新后的m_z左移16位并与m_w相加，生成一个32位的伪随机数作为返回值。",
                    "error_handling": "该函数没有显式的错误检查或处理机制。假设输入的RanState对象始终有效。",
                    "dependencies": {
                        "zopfli::RanState": {
                            "signature": "struct RanState { m_w: u32, m_z: u32 }",
                            "usage": "函数通过引用修改RanState的m_z和m_w字段以更新其内部状态，并使用这些字段生成伪随机数。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "RandomizeFreqs(RanState *, size_t *, int)": {
                "signature": "void RandomizeFreqs(RanState *, size_t *, int)",
                "description": "",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    },
                    "zopfli::Ran(RanState *)": {
                        "return_type": "unsigned int",
                        "qualified_name": "zopfli::Ran(RanState *)",
                        "type": "functions"
                    }
                },
                "full_text": "static void RandomizeFreqs (RanState *state ,size_t *freqs ,int n ){int i ;for (i =0 ;i <n ;i ++){if ((Ran (state )>>4 )%3 ==0 )freqs [i ]=freqs [Ran (state )%n ];}}",
                "rust_signature": "fn randomize_freqs(state: &mut RanState, freqs: &mut [usize], n: i32) {\n    // 原始C代码逻辑未实现，仅提供函数签名\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "RandomizeFreqs",
                    "main_purpose": "随机化输入频率数组freqs的部分元素，使其值基于数组中的其他随机元素。",
                    "detailed_logic": "函数遍历频率数组freqs的每个元素（索引范围为0到n-1）。对于每个元素，调用Ran函数生成一个伪随机数并右移4位，然后对结果取模3。如果结果为0，则将当前元素freqs[i]的值替换为freqs中另一个随机索引处的值。随机索引通过再次调用Ran函数并对n取模生成。",
                    "error_handling": "函数未显式处理任何错误条件，例如Ran函数调用失败或输入参数无效。假设输入参数state、freqs和n均有效。",
                    "dependencies": {
                        "zopfli::RanState": {
                            "signature": "struct RanState { m_w: u32, m_z: u32 }",
                            "usage": "RanState结构体用于存储伪随机数生成器的内部状态。函数通过引用传递RanState，并在调用Ran函数时更新其状态。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "RandomizeStatFreqs(RanState *, SymbolStats *)": {
                "signature": "void RandomizeStatFreqs(RanState *, SymbolStats *)",
                "description": "",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    },
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    },
                    "zopfli::RandomizeFreqs(RanState *, size_t *, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::RandomizeFreqs(RanState *, size_t *, int)",
                        "type": "functions"
                    }
                },
                "full_text": "static void RandomizeStatFreqs (RanState *state ,SymbolStats *stats ){RandomizeFreqs (state ,stats ->litlens ,ZOPFLI_NUM_LL );RandomizeFreqs (state ,stats ->dists ,ZOPFLI_NUM_D );stats ->litlens [256 ]=1 ;/* End symbol. */ }",
                "rust_signature": "pub fn randomize_stat_freqs(state: &mut RanState, stats: &mut SymbolStats) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "randomize_stat_freqs",
                    "main_purpose": "随机化符号统计中的频率数组，以增加数据的随机性，同时确保特定符号的频率被正确设置。",
                    "detailed_logic": "函数接收一个随机状态对象和符号统计对象作为输入。首先调用RandomizeFreqs函数对符号统计中的litlens数组进行随机化处理，数组长度为ZOPFLI_NUM_LL。然后再次调用RandomizeFreqs函数对dists数组进行随机化处理，数组长度为ZOPFLI_NUM_D。最后，将litlens数组的第256个元素（表示结束符号）设置为1，以确保结束符号的频率固定为1。",
                    "error_handling": "函数本身没有显式的错误处理机制，假设输入参数总是有效。依赖的RandomizeFreqs函数可能包含内部错误处理。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "InitRanState(RanState *)": {
                "signature": "void InitRanState(RanState *)",
                "description": "",
                "dependencies": {
                    "zopfli::RanState": {
                        "return_type": "RanState",
                        "qualified_name": "zopfli::RanState",
                        "type": "structs"
                    }
                },
                "full_text": "static void InitRanState (RanState *state ){state ->m_w =1 ;state ->m_z =2 ;}",
                "rust_signature": "fn init_ran_state(state: &mut RanState) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "InitRanState",
                    "main_purpose": "初始化RanState结构体的内部状态，将其成员变量设置为固定的初始值。",
                    "detailed_logic": "函数接收一个指向RanState结构体的指针，并将其成员变量m_w和m_z分别设置为固定值1和2。此操作确保RanState对象在使用前处于已知的初始状态。",
                    "error_handling": "该函数没有任何错误检查或处理机制，假定传入的指针始终有效。",
                    "dependencies": {
                        "zopfli::RanState": {
                            "signature": "struct RanState { m_w: u32, m_z: u32 }",
                            "usage": "函数直接修改RanState结构体的成员变量m_w和m_z，将它们分别设置为1和2。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)": {
                "signature": "void AddWeighedStatFreqs(const SymbolStats *, double, const SymbolStats *, double, SymbolStats *)",
                "description": "/* Adds the bit lengths. */",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void AddWeighedStatFreqs (const SymbolStats *stats1 ,double w1 ,const SymbolStats *stats2 ,double w2 ,SymbolStats *result ){size_t i ;for (i =0 ;i <ZOPFLI_NUM_LL ;i ++){result ->litlens [i ]=(size_t )(stats1 ->litlens [i ]*w1 +stats2 ->litlens [i ]*w2 );}for (i =0 ;i <ZOPFLI_NUM_D ;i ++){result ->dists [i ]=(size_t )(stats1 ->dists [i ]*w1 +stats2 ->dists [i ]*w2 );}result ->litlens [256 ]=1 ;/* End symbol. */ }",
                "rust_signature": "pub fn add_weighed_stat_freqs(stats1: &SymbolStats, w1: f64, stats2: &SymbolStats, w2: f64, result: &mut SymbolStats) {\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "add_weighed_stat_freqs",
                    "main_purpose": "合并两个符号统计数据，根据权重计算加权平均值，并将结果存储到目标符号统计数据中。",
                    "detailed_logic": "函数接收两个符号统计数据（stats1 和 stats2）及其对应的权重（w1 和 w2），然后对每个符号的频率进行加权平均计算。具体步骤如下：\n1. 遍历 litlens 数组（长度为 ZOPFLI_NUM_LL），对每个元素计算加权平均值，将结果存储到 result.litlens。\n2. 遍历 dists 数组（长度为 ZOPFLI_NUM_D），对每个元素计算加权平均值，将结果存储到 result.dists。\n3. 将 result.litlens[256] 设置为 1，表示结束符号。",
                    "error_handling": "函数没有显式的错误检查或处理机制，假设所有输入参数均有效。",
                    "dependencies": {
                        "zopfli::SymbolStats": {
                            "signature": "pub struct SymbolStats { litlens: [usize; ZOPFLI_NUM_LL], dists: [usize; ZOPFLI_NUM_D], ll_symbols: [f64; ZOPFLI_NUM_LL], d_symbols: [f64; ZOPFLI_NUM_D] }",
                            "usage": "函数使用 SymbolStats 的 litlens 和 dists 数组来存储符号频率数据。stats1 和 stats2 提供输入数据，result 用于存储加权平均后的结果。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "CeilDiv(size_t, size_t)": {
                "signature": "size_t CeilDiv(size_t, size_t)",
                "description": "",
                "dependencies": {},
                "full_text": "static size_t CeilDiv (size_t a ,size_t b ){return (a +b -1 )/b ;}",
                "rust_signature": "pub fn ceil_div(a: usize, b: usize) -> usize {\n    // 原始C代码逻辑未实现，仅占位\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "ceil_div",
                    "main_purpose": "计算两个正整数的向上取整除法结果，即确定a除以b的最小整数值。",
                    "detailed_logic": "函数接收两个正整数a和b作为输入参数。通过公式(a + b - 1) / b实现向上取整的除法逻辑：1. 首先将b减去1，然后加到a上；2. 通过整数除法操作(/)计算结果。该公式确保即使a不能被b整除，结果也会向上取整到最近的整数。",
                    "error_handling": "该函数未包含任何错误检查机制，假设输入参数a和b均为有效的正整数。未处理b为0的情况，这会导致除以零的未定义行为。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "CopyStats(SymbolStats *, SymbolStats *)": {
                "signature": "void CopyStats(SymbolStats *, SymbolStats *)",
                "description": "",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void CopyStats (SymbolStats *source ,SymbolStats *dest ){memcpy (dest ->litlens ,source ->litlens ,ZOPFLI_NUM_LL *sizeof (dest ->litlens [0 ]));memcpy (dest ->dists ,source ->dists ,ZOPFLI_NUM_D *sizeof (dest ->dists [0 ]));memcpy (dest ->ll_symbols ,source ->ll_symbols ,ZOPFLI_NUM_LL *sizeof (dest ->ll_symbols [0 ]));memcpy (dest ->d_symbols ,source ->d_symbols ,ZOPFLI_NUM_D *sizeof (dest ->d_symbols [0 ]));}",
                "rust_signature": "pub fn copy_stats(source: &SymbolStats, dest: &mut SymbolStats) {\n    todo!(\"Function implementation is not provided as per the requirements.\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "CopyStats",
                    "main_purpose": "将一个SymbolStats结构体中的所有统计数据复制到另一个SymbolStats结构体中。",
                    "detailed_logic": "函数通过调用memcpy逐字段地复制源结构体中的数据到目标结构体中。具体步骤如下：1. 将源结构体的litlens数组复制到目标结构体的litlens数组。2. 将源结构体的dists数组复制到目标结构体的dists数组。3. 将源结构体的ll_symbols数组复制到目标结构体的ll_symbols数组。4. 将源结构体的d_symbols数组复制到目标结构体的d_symbols数组。每次复制时，使用数组的大小和元素类型的大小计算所需的字节数。",
                    "error_handling": "该函数没有显式的错误检查或处理机制。假设输入的指针和数据结构是有效的，并且内存操作不会失败。",
                    "dependencies": {
                        "zopfli::SymbolStats": {
                            "signature": "pub struct SymbolStats { pub litlens: [usize; ZOPFLI_NUM_LL], pub dists: [usize; ZOPFLI_NUM_D], pub ll_symbols: [f64; ZOPFLI_NUM_LL], pub d_symbols: [f64; ZOPFLI_NUM_D] }",
                            "usage": "函数直接操作SymbolStats结构体的字段，将源结构体的数组数据逐字段复制到目标结构体的对应字段中。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "InitStats(SymbolStats *)": {
                "signature": "void InitStats(SymbolStats *)",
                "description": "/* Sets everything to 0. */",
                "dependencies": {
                    "zopfli::SymbolStats": {
                        "return_type": "SymbolStats",
                        "qualified_name": "zopfli::SymbolStats",
                        "type": "structs"
                    }
                },
                "full_text": "static void InitStats (SymbolStats *stats ){memset (stats ->litlens ,0 ,ZOPFLI_NUM_LL *sizeof (stats ->litlens [0 ]));memset (stats ->dists ,0 ,ZOPFLI_NUM_D *sizeof (stats ->dists [0 ]));memset (stats ->ll_symbols ,0 ,ZOPFLI_NUM_LL *sizeof (stats ->ll_symbols [0 ]));memset (stats ->d_symbols ,0 ,ZOPFLI_NUM_D *sizeof (stats ->d_symbols [0 ]));}",
                "rust_signature": "pub fn init_stats(stats: &mut SymbolStats) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "init_stats",
                    "main_purpose": "初始化SymbolStats结构体，将其所有字段重置为默认值（零值）。",
                    "detailed_logic": "函数通过调用memset将SymbolStats结构体中的四个数组字段（litlens、dists、ll_symbols、d_symbols）分别初始化为零值。每个数组的大小由ZOPFLI_NUM_LL或ZOPFLI_NUM_D常量定义，memset会将数组的所有字节设置为0。",
                    "error_handling": "该函数没有显式的错误检查或处理机制，假定传入的指针stats始终有效。",
                    "dependencies": {
                        "zopfli::SymbolStats": {
                            "signature": "pub struct SymbolStats { pub litlens: [usize; ZOPFLI_NUM_LL], pub dists: [usize; ZOPFLI_NUM_D], pub ll_symbols: [f64; ZOPFLI_NUM_LL], pub d_symbols: [f64; ZOPFLI_NUM_D] }",
                            "usage": "函数直接操作SymbolStats结构体中的四个数组字段（litlens、dists、ll_symbols、d_symbols），通过将它们的所有元素初始化为零值来完成重置操作。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)": {
                "signature": "int FindLargestSplittableBlock(size_t, const unsigned char *, const size_t *, size_t, size_t *, size_t *)",
                "description": "/*\nFinds next block to try to split, the largest of the available ones.\nThe largest is chosen to make sure that if only a limited amount of blocks is\nrequested, their sizes are spread evenly.\nlz77size: the size of the LL77 data, which is the size of the done array here.\ndone: array indicating which blocks starting at that position are no longer\nsplittable (splitting them increases rather than decreases cost).\nsplitpoints: the splitpoints found so far.\nnpoints: the amount of splitpoints found so far.\nlstart: output variable, giving start of block.\nlend: output variable, giving end of block.\nreturns 1 if a block was found, 0 if no block found (all are done).\n*/",
                "dependencies": {},
                "full_text": "static int FindLargestSplittableBlock (size_t lz77size ,const unsigned char *done ,const size_t *splitpoints ,size_t npoints ,size_t *lstart ,size_t *lend ){size_t longest =0 ;int found =0 ;size_t i ;for (i =0 ;i <=npoints ;i ++){size_t start =i ==0 ?0 :splitpoints [i -1 ];size_t end =i ==npoints ?lz77size -1 :splitpoints [i ];if (!done [start ]&&end -start >longest ){*lstart =start ;*lend =end ;found =1 ;longest =end -start ;}}return found ;}",
                "rust_signature": "pub unsafe fn find_largest_splittable_block(lz77size: usize, done: *const u8, splitpoints: *const usize, npoints: usize, lstart: *mut usize, lend: *mut usize) -> i32 {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "FindLargestSplittableBlock",
                    "main_purpose": "查找未处理的、可分割的最大块，并返回其起始和结束位置。",
                    "detailed_logic": "函数遍历分割点数组splitpoints，计算每个块的起始和结束位置。对于每个块，如果起始位置未被标记为已处理（done[start]为0），且块的长度大于当前最长块，则更新最长块的长度，并记录其起始和结束位置到lstart和lend指针中。最终返回是否找到符合条件的块（found）。",
                    "error_handling": "函数未显式处理错误情况，但依赖调用者保证输入参数的有效性，例如done、splitpoints指针的合法性，以及npoints和lz77size的合理性。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)": {
                "signature": "void PrintBlockSplitPoints(const ZopfliLZ77Store *, const size_t *, size_t)",
                "description": "/*\nPrints the block split points as decimal and hex values in the terminal.\n*/",
                "dependencies": {
                    "zopfli::ZopfliLZ77Store": {
                        "return_type": "ZopfliLZ77Store",
                        "qualified_name": "zopfli::ZopfliLZ77Store",
                        "type": "structs"
                    }
                },
                "full_text": "static void PrintBlockSplitPoints (const ZopfliLZ77Store *lz77 ,const size_t *lz77splitpoints ,size_t nlz77points ){size_t *splitpoints =0 ;size_t npoints =0 ;size_t i ;/* The input is given as lz77 indices, but we want to see the uncompressed\n    index values. */ size_t pos =0 ;if (nlz77points >0 ){for (i =0 ;i <lz77 ->size ;i ++){size_t length =lz77 ->dists [i ]==0 ?1 :lz77 ->litlens [i ];if (lz77splitpoints [npoints ]==i ){ZOPFLI_APPEND_DATA (pos ,&splitpoints ,&npoints );if (npoints ==nlz77points )break ;}pos +=length ;}}assert (npoints ==nlz77points );fprintf (stderr ,\"block split points: \" );for (i =0 ;i <npoints ;i ++){fprintf (stderr ,\"%d \" ,(int )splitpoints [i ]);}fprintf (stderr ,\"(hex:\" );for (i =0 ;i <npoints ;i ++){fprintf (stderr ,\" %x\" ,(int )splitpoints [i ]);}fprintf (stderr ,\")\\n\" );free (splitpoints );}",
                "rust_signature": "fn print_block_split_points(lz77: &ZopfliLZ77Store, lz77splitpoints: *const usize, nlz77points: usize) {\n    // Function body is intentionally left unimplemented.\n    todo!(\"Implement function logic\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "PrintBlockSplitPoints",
                    "main_purpose": "计算并打印LZ77块分割点的未压缩索引值，同时以十进制和十六进制格式输出这些分割点。",
                    "detailed_logic": "函数首先将LZ77块分割点从压缩索引转换为未压缩索引。通过遍历LZ77存储中的每个元素，根据其距离值和长度值计算未压缩数据的位置。如果当前索引与分割点匹配，则记录该未压缩位置。最后，函数将所有分割点以十进制和十六进制格式打印到标准错误输出，并释放动态分配的内存。",
                    "error_handling": "函数使用断言确保计算出的分割点数量与预期数量一致。如果断言失败，程序会终止。此外，函数在结束时释放动态分配的内存以避免内存泄漏。",
                    "dependencies": {
                        "zopfli::ZopfliLZ77Store": {
                            "signature": "struct ZopfliLZ77Store",
                            "usage": "函数通过访问ZopfliLZ77Store的litlens和dists字段来获取LZ77编码的长度和距离信息，并使用size字段确定存储的总大小。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "AddSorted(size_t, size_t **, size_t *)": {
                "signature": "void AddSorted(size_t, size_t **, size_t *)",
                "description": "",
                "dependencies": {},
                "full_text": "static void AddSorted (size_t value ,size_t **out ,size_t *outsize ){size_t i ;ZOPFLI_APPEND_DATA (value ,out ,outsize );for (i =0 ;i +1 <*outsize ;i ++){if ((*out )[i ]>value ){size_t j ;for (j =*outsize -1 ;j >i ;j --){(*out )[j ]=(*out )[j -1 ];}(*out )[i ]=value ;break ;}}}",
                "rust_signature": "unsafe fn add_sorted(value: usize, out: *mut *mut usize, outsize: *mut usize) { todo!() }",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "AddSorted",
                    "main_purpose": "将一个值插入到一个动态数组中，并确保数组保持升序排列。",
                    "detailed_logic": "函数首先调用ZOPFLI_APPEND_DATA将值追加到动态数组中，然后通过遍历数组找到插入点。如果插入点的值大于新插入的值，则将插入点之后的所有元素向后移动一位，腾出空间插入新值，最终保持数组的升序排列。",
                    "error_handling": "函数没有显式的错误检查或处理机制。假设输入参数有效，并且ZOPFLI_APPEND_DATA能够正常工作。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)": {
                "signature": "size_t FindMinimum(FindMinimumFun, void *, size_t, size_t, double *)",
                "description": "/*\nFinds minimum of function f(i) where is is of type size_t, f(i) is of type\ndouble, i is in range start-end (excluding end).\nOutputs the minimum value in *smallest and returns the index of this value.\n*/",
                "dependencies": {
                    "zopfli::FindMinimumFun": {
                        "return_type": "FindMinimumFun",
                        "qualified_name": "zopfli::FindMinimumFun",
                        "type": "typedefs"
                    },
                    "zopfli::NUM": {
                        "return_type": "macro",
                        "qualified_name": "zopfli::NUM",
                        "type": "defines"
                    }
                },
                "full_text": "static size_t FindMinimum (FindMinimumFun f ,void *context ,size_t start ,size_t end ,double *smallest ){if (end -start <1024 ){double best =ZOPFLI_LARGE_FLOAT ;size_t result =start ;size_t i ;for (i =start ;i <end ;i ++){double v =f (i ,context );if (v <best ){best =v ;result =i ;}}*smallest =best ;return result ;}else {/* Try to find minimum faster by recursively checking multiple points. */ #define NUM 9 /* Good value: 9. */ size_t i ;size_t p [NUM ];double vp [NUM ];size_t besti ;double best ;double lastbest =ZOPFLI_LARGE_FLOAT ;size_t pos =start ;for (;;){if (end -start <=NUM )break ;for (i =0 ;i <NUM ;i ++){p [i ]=start +(i +1 )*((end -start )/(NUM +1 ));vp [i ]=f (p [i ],context );}besti =0 ;best =vp [0 ];for (i =1 ;i <NUM ;i ++){if (vp [i ]<best ){best =vp [i ];besti =i ;}}if (best >lastbest )break ;start =besti ==0 ?start :p [besti -1 ];end =besti ==NUM -1 ?end :p [besti +1 ];pos =p [besti ];lastbest =best ;}*smallest =lastbest ;return pos ;#undef NUM }}",
                "rust_signature": "pub fn find_minimum(f: FindMinimumFun, context: *mut core::ffi::c_void, start: usize, end: usize, smallest: &mut f64) -> usize {\n    // Placeholder implementation\n    unimplemented!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "find_minimum",
                    "main_purpose": "在[start, end)范围内，通过调用函数f找到使其返回值最小的索引，并将最小值存储在smallest中。",
                    "detailed_logic": "函数分为两种情况处理：\n1. 当范围[start, end)小于1024时，直接遍历范围内的每个索引，调用f计算其值，记录最小值及其对应的索引。\n2. 当范围[start, end)大于等于1024时，采用递归分治法：\n   - 定义一个常量NUM（值为9），将范围分为NUM+1个等间隔的点。\n   - 对这些点调用f计算其值，找到最小值及其对应的点。\n   - 根据最小值的位置，缩小范围为包含该点及其相邻点的子范围。\n   - 如果当前最小值大于上一次的最小值，则停止递归。\n   - 最终返回最小值及其对应的索引。",
                    "error_handling": "函数未显式处理错误情况，例如f可能返回无效值或context可能为空指针。假设调用者保证输入参数的有效性。",
                    "dependencies": {
                        "zopfli::NUM": {
                            "signature": "pub const NUM: i32 = 9",
                            "usage": "在范围[start, end)较大时，NUM用于确定递归分治法中分割范围的点数。函数将范围分为NUM+1个等间隔的点，并对这些点调用f以找到局部最小值。"
                        }
                    }
                },
                "summary_status": "success"
            },
            "single_test(const unsigned char *, int, int, int)": {
                "signature": "void single_test(const unsigned char *, int, int, int)",
                "description": "",
                "dependencies": {
                    "zopfli::ZopfliOptions": {
                        "return_type": "ZopfliOptions",
                        "qualified_name": "zopfli::ZopfliOptions",
                        "type": "structs"
                    },
                    "zopfli::ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::ZopfliDeflate(const ZopfliOptions *, int, int, const unsigned char *, size_t, unsigned char *, unsigned char **, size_t *)",
                        "type": "functions"
                    }
                },
                "full_text": "void single_test (const unsigned char *in ,int btype ,int blocksplitting ,int blocksplittingmax ){ZopfliOptions options ;// Configure options options .verbose =1 ;options .verbose_more =0 ;// Reduce internal verbose output options .numiterations =15 ;options .blocksplitting =blocksplitting ;options .blocksplittinglast =0 ;options .blocksplittingmax =blocksplittingmax ;unsigned char *out =0 ;size_t outsize =0 ;unsigned char bp =0 ;size_t insize =strlen (in );// Perform compression ZopfliDeflate (&options ,btype ,1 ,(const unsigned char *)in ,insize ,&bp ,&out ,&outsize );}",
                "rust_signature": "pub fn single_test(\n    input: *const u8,\n    btype: i32,\n    block_splitting: i32,\n    block_splitting_max: i32,\n    out: *mut *mut u8,\n    outsize: *mut usize,\n    bp: *mut u8,\n    insize: usize,\n) {\n    // Placeholder implementation\n    todo!(\"Function body not implemented\");\n}",
                "conversion_status": "success",
                "conversion_rounds": 2
            },
            "run_all_tests(const unsigned char *)": {
                "signature": "void run_all_tests(const unsigned char *)",
                "description": "",
                "dependencies": {
                    "zopfli::single_test(const unsigned char *, int, int, int)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::single_test(const unsigned char *, int, int, int)",
                        "type": "functions"
                    }
                },
                "full_text": "void run_all_tests (const unsigned char *in ){single_test (in ,2 ,1 ,15 );// Dynamic Huffman single_test (in ,1 ,1 ,15 );// Fixed Huffman single_test (in ,0 ,1 ,15 );// Uncompressed // Test with different block splitting settings single_test (in ,2 ,0 ,15 );// No block splitting single_test (in ,2 ,1 ,5 );// Limited splits single_test (in ,2 ,1 ,0 );// No splits single_test (in ,2 ,1 ,1 );// No splits single_test (in ,2 ,1 ,50 );// No splits single_test (in ,2 ,1 ,30 );// More splits allowed }",
                "rust_signature": "pub fn run_all_tests(input: *const u8) {\n    // Placeholder implementation\n    // Original C code calls single_test multiple times with different parameters\n    unimplemented!();\n}",
                "conversion_status": "success",
                "conversion_rounds": 1
            },
            "read_stdin_to_bytes(size_t *)": {
                "signature": "unsigned char * read_stdin_to_bytes(size_t *)",
                "description": "",
                "dependencies": {},
                "full_text": "unsigned char *read_stdin_to_bytes (size_t *out_size ){// Initial buffer size size_t buffer_size =1024 ;size_t total_read =0 ;// Allocate initial buffer unsigned char *buffer =malloc (buffer_size );if (buffer ==NULL ){fprintf (stderr ,\"Memory allocation failed\\n\" );return NULL ;}// Read stdin in chunks int ch ;while ((ch =getchar ())!=EOF ){// Resize buffer if needed if (total_read >=buffer_size ){buffer_size *=2 ;unsigned char *new_buffer =realloc (buffer ,buffer_size );if (new_buffer ==NULL ){fprintf (stderr ,\"Memory reallocation failed\\n\" );free (buffer );return NULL ;}buffer =new_buffer ;}// Store the character buffer [total_read ++]=(unsigned char )ch ;}// Set the output size *out_size =total_read ;return buffer ;}",
                "rust_signature": "fn read_stdin_to_bytes(out_size: &mut usize) -> Option<Vec<u8>> {\n    // Placeholder implementation\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 1,
                "function_summary": {
                    "function_name": "read_stdin_to_bytes",
                    "main_purpose": "从标准输入读取字节数据并存储到动态分配的缓冲区中，同时返回读取的字节数。",
                    "detailed_logic": "函数首先分配一个初始大小为1024字节的缓冲区，用于存储从标准输入读取的数据。然后通过循环逐字节读取标准输入数据，直到遇到EOF。如果缓冲区容量不足，函数会动态扩展缓冲区的大小（翻倍）。每次读取一个字节后，将其存储到缓冲区中，并更新已读取的字节计数。最后，函数返回包含所有读取数据的缓冲区，并通过指针参数返回总字节数。",
                    "error_handling": "函数在内存分配失败时打印错误信息并返回NULL。在缓冲区扩展失败时，打印错误信息，释放已分配的内存，并返回NULL。",
                    "dependencies": {}
                },
                "summary_status": "success"
            },
            "main()": {
                "signature": "int main()",
                "description": "",
                "dependencies": {
                    "zopfli::read_stdin_to_bytes(size_t *)": {
                        "return_type": "unsigned char *",
                        "qualified_name": "zopfli::read_stdin_to_bytes(size_t *)",
                        "type": "functions"
                    },
                    "zopfli::run_all_tests(const unsigned char *)": {
                        "return_type": "void",
                        "qualified_name": "zopfli::run_all_tests(const unsigned char *)",
                        "type": "functions"
                    }
                },
                "full_text": "int main (){size_t bytes_size ;unsigned char *bytes =read_stdin_to_bytes (&bytes_size );if (bytes ==NULL ){fprintf (stderr ,\"Failed to read stdin\\n\" );return 1 ;}// Run tests run_all_tests (bytes );// Free allocated memory free (bytes );return 0 ;}",
                "rust_signature": "",
                "conversion_status": "success",
                "conversion_rounds": 4
            },
            "ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)": {
                "name": "ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)",
                "signature": "ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)",
                "value": "\n{                                                                                \nif (!((*size) & ((*size) - 1)))                                              \n{                                                                            \n/*double alloc size if it's a power of two*/                             \n(*data) = (*size) == 0 ? malloc(sizeof(**data))                          \n: realloc((*data), (*size) * 2 * sizeof(**data)); \nmemset((*data) + (*size), 0, (*size) * sizeof(**data));                  \n}                                                                            \n(*data)[(*size)] = (value);                                                  \n(*size)++;                                                                   \n}",
                "full_text": "#define ZOPFLI_APPEND_DATA(/* T */ value, /* T** */ data, /* size_t* */ size)        \\\n    {                                                                                \\\n        if (!((*size) & ((*size) - 1)))                                              \\\n        {                                                                            \\\n            /*double alloc size if it's a power of two*/                             \\\n            (*data) = (*size) == 0 ? malloc(sizeof(**data))                          \\\n                                   : realloc((*data), (*size) * 2 * sizeof(**data)); \\\n            memset((*data) + (*size), 0, (*size) * sizeof(**data));                  \\\n        }                                                                            \\\n        (*data)[(*size)] = (value);                                                  \\\n        (*size)++;                                                                   \\\n    }",
                "original_type": "define",
                "rust_signature": "pub fn zopfli_append_data<T>(value: T, data: &mut Vec<T>) {\n    todo!()\n}",
                "conversion_status": "success",
                "conversion_rounds": 2,
                "function_summary": {
                    "function_name": "zopfli_append_data",
                    "main_purpose": "动态地向数组中添加元素，同时根据需要调整数组的容量。",
                    "detailed_logic": "1. 检查当前数组大小是否是2的幂（即(*size) & ((*size) - 1) == 0）。如果是，则需要调整数组容量。2. 如果当前大小为0，则使用malloc分配一个元素的空间；否则，使用realloc将数组容量扩展为当前大小的两倍。3. 调用memset初始化新分配的内存区域为0，确保未使用的部分被清零。4. 将新值(value)添加到数组的末尾位置(*data)[*size]。5. 增加数组的大小计数器(*size)。",
                    "error_handling": "函数未显式处理内存分配失败的情况。如果malloc或realloc返回NULL，程序可能会崩溃。此外，函数假定传入的指针(*data)和(*size)是有效的，没有对其进行空指针检查。",
                    "dependencies": {}
                },
                "summary_status": "success"
            }
        },
        "fields": {}
    }
}